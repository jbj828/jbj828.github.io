<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Developer Javit</title>
  
  <subtitle>Slowly and Steadily</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jbj828.github.io/"/>
  <updated>2020-02-22T03:43:18.193Z</updated>
  <id>http://jbj828.github.io/</id>
  
  <author>
    <name>Jay Chung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>How to write ReadMe?</title>
    <link href="http://jbj828.github.io/2020/02/22/WritingReadMe/"/>
    <id>http://jbj828.github.io/2020/02/22/WritingReadMe/</id>
    <published>2020-02-22T04:30:25.000Z</published>
    <updated>2020-02-22T03:43:18.193Z</updated>
    
    <content type="html"><![CDATA[<p>Information about writing ReadME documentation.</p><a id="more"></a><h3 id="Anatomy-of-a-README"><a href="#Anatomy-of-a-README" class="headerlink" title="Anatomy of a README"></a>Anatomy of a README</h3><ol><li>What <strong>steps</strong> need to be taken?</li><li>What should the user already have <strong>installed</strong> or <strong>configured</strong>?</li><li>What might they have a hard time understading <strong>right away</strong>?</li></ol><br><h3 id="Basic-Structure"><a href="#Basic-Structure" class="headerlink" title="Basic Structure"></a>Basic Structure</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 프로젝트 제목</span><br><span class="line">프로젝트 설명 (with 프로젝트 Logo)</span><br><span class="line"></span><br><span class="line">## 설치 방법 (Installation)</span><br><span class="line">설치 방법 설명 (with 예시코드)</span><br><span class="line"></span><br><span class="line">## 사용 방법 (Usage)</span><br><span class="line">사용 방법 설명 (with 예시코드)</span><br></pre></td></tr></table></figure><ul><li>If it is Open Source Project<br></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 기여 방법 (Contributing)</span><br><span class="line">기여 방법 설명</span><br><span class="line"></span><br><span class="line">## 라이센스 (License)</span><br><span class="line">해당하는 License (choosealicense.com 참고)</span><br></pre></td></tr></table></figure><ul><li>Big project</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 버그들 (Known Bugs)</span><br><span class="line">## FAQ (Frequently Asked Qustions)</span><br><span class="line">## ToC (Table of Contents)</span><br></pre></td></tr></table></figure><p><Br><Br></p><p>ref : “Udacity - Writing READMEs”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Information about writing ReadME documentation.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Github" scheme="http://jbj828.github.io/categories/Github/"/>
    
    
      <category term="github" scheme="http://jbj828.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hashing - Direct Chaining Coding</title>
    <link href="http://jbj828.github.io/2020/02/19/Al-HashingDirectChaining/"/>
    <id>http://jbj828.github.io/2020/02/19/Al-HashingDirectChaining/</id>
    <published>2020-02-19T06:30:25.000Z</published>
    <updated>2020-02-19T05:03:42.928Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><Br><p>DirectChaining.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class DirectChaining &#123;</span><br><span class="line">LinkedList&lt;String&gt;[] hashTable;</span><br><span class="line">int maximumChainSize &#x3D; 5;</span><br><span class="line"></span><br><span class="line">DirectChaining() &#123;</span><br><span class="line">hashTable &#x3D; new LinkedList[13];</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashFunction to be used on Keys</span><br><span class="line">public int simpleASCIIHashFunction(String x, int M) &#123;</span><br><span class="line">char ch[];</span><br><span class="line">ch &#x3D; x.toCharArray();</span><br><span class="line">int i, sum;</span><br><span class="line">for (sum &#x3D; 0, i &#x3D; 0; i &lt; x.length(); i++) &#123;</span><br><span class="line">sum &#x3D; sum + ch[i];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; System.out.println(&quot;Index from hashfunction: &quot; + sum % M);</span><br><span class="line">return sum % M;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Insert Key in HashTable</span><br><span class="line">public void insertKeyInHashTable(String value) &#123;</span><br><span class="line">int newIndex &#x3D; simpleASCIIHashFunction(value, hashTable.length); &#x2F;&#x2F;returns in which index we need to store this string</span><br><span class="line">if(hashTable[newIndex] &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;Index: &quot; + newIndex + &quot; is empty. Creating a new LinkedList there...&quot;);</span><br><span class="line">hashTable[newIndex] &#x3D; new LinkedList&lt;String&gt;(); </span><br><span class="line">hashTable[newIndex].add(value);</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + &quot;\&quot;&quot; + value + &quot;\&quot;&quot; + &quot; in location: &quot; + newIndex);</span><br><span class="line">System.out.println(&quot;-------------------------------------------\n&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\nIndex: &quot; + newIndex + &quot; is having sufficient space. Inserting there...&quot;);</span><br><span class="line">hashTable[newIndex].add(value);</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + &quot;\&quot;&quot; + value + &quot;\&quot;&quot; + &quot; in location: &quot; + newIndex);</span><br><span class="line">System.out.println(&quot;-------------------------------------------\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Search for a given key in hashTable</span><br><span class="line">public boolean searchKeyInHashTable(String stringToBeSearched) &#123;</span><br><span class="line">int newIndex &#x3D; simpleASCIIHashFunction(stringToBeSearched, hashTable.length);</span><br><span class="line">if (hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].contains(stringToBeSearched)) &#123;</span><br><span class="line">System.out.println(&quot;\n&quot; + &quot;\&quot;&quot; + stringToBeSearched + &quot;\&quot;&quot; + &quot; found in HashTable at location: &quot;+newIndex);</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\n&quot; + &quot;\&quot;&quot; + stringToBeSearched + &quot;\&quot;&quot; + &quot; not found in HashTable.&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete key from HashTable</span><br><span class="line">public void deleteKeyFromHashTable(String stringToBeDeleted) &#123;</span><br><span class="line">int newIndex &#x3D; simpleASCIIHashFunction(stringToBeDeleted, hashTable.length);</span><br><span class="line">if (hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].contains(stringToBeDeleted)) &#123;</span><br><span class="line">System.out.println(&quot;\n&quot; + &quot;\&quot;&quot; + stringToBeDeleted + &quot;\&quot;&quot; + &quot; has been found in HashTable.&quot; );</span><br><span class="line">hashTable[newIndex].remove(stringToBeDeleted);</span><br><span class="line">System.out.println(&quot;\&quot;&quot; + stringToBeDeleted + &quot;\&quot;&quot; + &quot; has been deleted from HashTable !&quot; );</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\nCould not find &quot; + &quot;\&quot;&quot; + stringToBeDeleted + &quot;\&quot;&quot; + &quot; in HashTable&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; display the hash table</span><br><span class="line">public void displayHashTable() &#123;</span><br><span class="line">if(hashTable &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;\nHashTable does not exits !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\n---------- HashTable ---------&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; hashTable.length; i++) &#123;</span><br><span class="line">System.out.println(&quot;Index: &quot; + i + &quot;, key: &quot; + hashTable[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; &#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deletes entire HashTable</span><br><span class="line">public void deleteHashTable() &#123;</span><br><span class="line">hashTable &#x3D; null;</span><br><span class="line">System.out.println(&quot;Successfully deleted HashTable !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><br><p>Main.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class DirectChainingMain &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Constructor</span><br><span class="line">DirectChaining directChaining &#x3D; new DirectChaining();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;The&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;quick&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;brown&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;over&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;lazy&quot;);</span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;); &#x2F;&#x2F; use for showing collision</span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * DirectChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.searchKeyInHashTable(&quot;jump&quot;);</span><br><span class="line"> * DirectChaining.searchKeyInHashTable(&quot;brown&quot;);</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.deleteKeyFromHashTable(&quot;jump&quot;);</span><br><span class="line"> * DirectChaining.deleteKeyFromHashTable(&quot;quick&quot;);</span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.deleteHashTable(); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure><br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;Br&gt;


&lt;p&gt;DirectChaining.java&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hashing</title>
    <link href="http://jbj828.github.io/2020/02/18/Al-hasing/"/>
    <id>http://jbj828.github.io/2020/02/18/Al-hasing/</id>
    <published>2020-02-18T14:30:25.000Z</published>
    <updated>2020-02-19T00:59:23.048Z</updated>
    
    <content type="html"><![CDATA[<p>Hashing</p><a id="more"></a><br><p><strong>What is Hashing</strong></p><ul><li>Hashing is a method of sorting and indexing data. The idea behind hasing is to allow large amounts of data to be indexed using keys commonly created by formulas.</li><li>해시함수란 데이터의 효율적 관리를 목적으로 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 매핑 전 원래 데이터의 값을 키(key), 매핑 후 데이터의 값을 해시값(hash value), 매핑하는 과정 자체를 해싱(hashing) 이라고 한다.</li></ul><p><strong>Why we need Hashing</strong></p><ul><li>Time efficient<img src="/2020/02/18/Al-hasing/hasing1.png" class="" width="400" height="200" title="hashing time complexity"></li></ul><br><p><strong>Terminologies</strong></p><ul><li><p>Hash Function : A hash function is any function that can be used to map data of arbitrary size to data of fixed size.</p></li><li><p>Key : Input data given by user</p></li><li><p>Hash Value : The values returned by a hash function are called hash values, hash codes, digests, or simply hashes.</p></li><li><p>Hash Tables : It is a data structure which implements an associative array abstract data type, a structure that can map keys to values.</p></li><li><p>Collision : A collision occurs when two different key to a hash function produce the same output called hash values.</p><img src="/2020/02/18/Al-hasing/hashing2.png" class="" width="600" height="500" title="hashing structure"></li></ul><br><p><strong>Characteristics of good Hash function</strong></p><ul><li>It distributes hash values uniformly across the hash table.</li><li>The hash function uses all the input data.</li></ul><br><h4 id="Collision-Resolution-Techniques"><a href="#Collision-Resolution-Techniques" class="headerlink" title="Collision Resolution Techniques"></a>Collision Resolution Techniques</h4><img src="/2020/02/18/Al-hasing/hashing3.png" class="" width="400" height="300" title="hashing structure"><br><ul><li><p>Direct Chaining </p><ul><li>Implements the buckets as linked lists. Colliding elements are stored in these lists.<img src="/2020/02/18/Al-hasing/hashing4.png" class="" width="400" height="300" title="Direct Chaining"><br></li></ul></li><li><p>Open Addressing</p><ul><li>Colliding elements are stored in other vacant buckets. During storage and lookup, there are found through so called “probing”<br></li></ul><ul><li><p>Linear Probing :</p><ul><li>Linear probing is a strategy for resolving collisions by replacing the new key into the closest following empty cell.<img src="/2020/02/18/Al-hasing/hashing5.png" class="" width="400" height="300" title="Linear Probing"><br></li></ul></li><li><p>Quadratic Probing : </p><ul><li>Qudratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.<img src="/2020/02/18/Al-hasing/hashing6.png" class="" width="400" height="300" title="Quadratic Probing"><br></li></ul></li><li><p>Double Hashing :</p><ul><li>Interval between probes is computed by another hash function.<img src="/2020/02/18/Al-hasing/hashing7.png" class="" width="400" height="300" title="Double Hashing"></li></ul></li></ul></li></ul><br><p><strong>What happens when Hash Table is full?</strong></p><ul><li><p>Direct Chaining </p><ul><li>This situation will never arise.</li></ul></li><li><p>Open Addressing</p><ul><li>Need to create 2x size of current table and redo Hashing for existing keys.<img src="/2020/02/18/Al-hasing/hashing8.png" class="" width="400" height="300" title="resizeHashTable"></li></ul></li></ul><br><p><strong>Pros &amp; Cons of Collision Resolution Technique</strong></p><ul><li><p>Direct Chaining</p><ul><li>No fear of exhausting Hash Table buckets.</li><li>Fear of big Linked Lists(can effect performance big time).</li></ul></li><li><p>Open Addressing</p><ul><li>Easy implementation</li><li>Fear of exhasuting Hash Table buckets.</li></ul></li></ul><ol><li><p>If input size is known then always use “Open Addressing”, else can use any of the two.</p></li><li><p>If Deletion is very high, then we should always go for ‘Direct Chaining’. Because when we delet a lot on ‘Open Addressing’, there’s gonna have lots of Hole and it will make problem. We can do “restruction”, but it’s not that efficient way.</p></li></ol><br><p><strong>Practical Use of Hashing</strong></p><ul><li>Password Verification</li><li>File System : File path is mapped to physical location on disk.</li></ul><br><p><strong>Pros &amp; Cons of Hashing</strong></p><ul><li><p>Pros</p><ul><li>On an average Insertion/Deletion/Search operation takes O(1) time.</li></ul></li><li><p>Cons</p><ul><li>In the worst case Insertion/Deletion/Search might take O(n) time(when hash function is not good enough)</li></ul></li></ul><br>출처 : "Data Structures & Algorithms" by DS GUY]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hashing&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Trie Coding</title>
    <link href="http://jbj828.github.io/2020/02/18/Al-Trie-Coding/"/>
    <id>http://jbj828.github.io/2020/02/18/Al-Trie-Coding/</id>
    <published>2020-02-18T07:30:25.000Z</published>
    <updated>2020-02-18T09:14:30.541Z</updated>
    
    <content type="html"><![CDATA[<p>Trie coding</p><a id="more"></a><br><p>Trie.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">package trie;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Trie &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Private class</span><br><span class="line">private class TrieNode &#123;</span><br><span class="line">Map&lt;Character, TrieNode&gt; children;</span><br><span class="line">boolean endOfWord;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Constructor</span><br><span class="line">public TrieNode() &#123;</span><br><span class="line">children &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">endOfWord &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; End of inner class</span><br><span class="line"></span><br><span class="line">private final TrieNode root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Constructor</span><br><span class="line">public Trie() &#123;</span><br><span class="line">root &#x3D; new TrieNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Insert word into Trie</span><br><span class="line">public void insert(String word) &#123;</span><br><span class="line">TrieNode current &#x3D; root;</span><br><span class="line">for (int i &#x3D; 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">char ch &#x3D; word.charAt(i);</span><br><span class="line">TrieNode node &#x3D; current.children.get(ch);</span><br><span class="line">if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">node &#x3D; new TrieNode();</span><br><span class="line">current.children.put(ch, node);</span><br><span class="line">&#125;</span><br><span class="line">current &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line">current.endOfWord &#x3D; true;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + word + &quot; in Trie !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Search for a word in Trie</span><br><span class="line">public boolean search(String word) &#123;</span><br><span class="line">TrieNode currentNode &#x3D; root;</span><br><span class="line">for (int i &#x3D; 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">char ch &#x3D; word.charAt(i);</span><br><span class="line">TrieNode node &#x3D; currentNode.children.get(ch); </span><br><span class="line">if (node &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;CASE#1 -- if node does not exist for given char then return false</span><br><span class="line">System.out.println(&quot;Word: &quot; + word + &quot; does not exists in Trie !&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">currentNode &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line">if(currentNode.endOfWord &#x3D;&#x3D; true) &#123;</span><br><span class="line">System.out.println(&quot;Word: &quot; + word + &quot; exists in Trie !&quot;); &#x2F;&#x2F;CASE#2 -- Word exists in Trie</span><br><span class="line">&#125;else &#123;&#x2F;&#x2F;CASE#3 -- Current word is a prefix of another word. But this word does not exists</span><br><span class="line">System.out.println(&quot;Word: &quot; + word + &quot; does not exists in Trie ! But this is a Prefix of another Word !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return currentNode.endOfWord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Delete word from Trie</span><br><span class="line">public void delete(String word) &#123;</span><br><span class="line">if (search(word) &#x3D;&#x3D; true) &#123;</span><br><span class="line">delete(root, word, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Returns true if parent should delete the mapping</span><br><span class="line">private boolean delete(TrieNode parentNode, String word, int index) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; CASE#1 -- Some other word&#39;s prefix is same as Prefix of this word (BCDE, BCKG)</span><br><span class="line">&#x2F;&#x2F; CASE#2 -- We are at last character of this word and This word is a Prefix of some other word (BCDE, BCDEFG)</span><br><span class="line">&#x2F;&#x2F; CASE#3 -- Some other word is a Prefix of this word (BCDE, BC)</span><br><span class="line">&#x2F;&#x2F; CASE#4 -- No one is dependent on this Word (BCDE, BCDE)</span><br><span class="line"></span><br><span class="line">char ch &#x3D; word.charAt(index);</span><br><span class="line">TrieNode currentNode &#x3D; parentNode.children.get(ch);</span><br><span class="line"></span><br><span class="line">boolean canThisNodeBeDeleted;</span><br><span class="line"></span><br><span class="line">if (currentNode.children.size() &gt; 1) &#123;</span><br><span class="line">System.out.println(&quot;Entering Case#1&quot;);</span><br><span class="line">delete(currentNode, word, index + 1); &#x2F;&#x2F; CASE#1</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (index &#x3D;&#x3D; word.length() - 1) &#123; &#x2F;&#x2F; CASE#2</span><br><span class="line">System.out.println(&quot;Entering Case#2&quot;);</span><br><span class="line">if (currentNode.children.size() &gt;&#x3D; 1) &#123;</span><br><span class="line">currentNode.endOfWord &#x3D; false;&#x2F;&#x2F;updating endOfWord will signify that this word is not there in Trie</span><br><span class="line">return false;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Character &quot; + ch + &quot; has no dependency, hence deleting it from last&quot;);</span><br><span class="line">parentNode.children.remove(ch);</span><br><span class="line">return true;&#x2F;&#x2F; If this word is not a prefix of some other word, and since this is last</span><br><span class="line">&#x2F;&#x2F; character, we should</span><br><span class="line">&#x2F;&#x2F; return true, indicating we are ok to delete this node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (currentNode.endOfWord &#x3D;&#x3D; true) &#123; &#x2F;&#x2F; CASE#3</span><br><span class="line">System.out.println(&quot;Entering Case#3&quot;);</span><br><span class="line">delete(currentNode, word, index + 1); </span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Entering Case#1&quot;);</span><br><span class="line">canThisNodeBeDeleted &#x3D; delete(currentNode, word, index + 1); &#x2F;&#x2F; CASE#4</span><br><span class="line">if (canThisNodeBeDeleted &#x3D;&#x3D; true) &#123;</span><br><span class="line">System.out.println(&quot;Character &quot; + ch + &quot; has no dependency, hence deleting it&quot;);</span><br><span class="line">parentNode.children.remove(ch);</span><br><span class="line">return true; &#x2F;&#x2F; Current node can also be deleted</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false; &#x2F;&#x2F; Someone is dependent on this node, hence dont delete it</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; End of class</span><br></pre></td></tr></table></figure><br><p>Main.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package trie;</span><br><span class="line"></span><br><span class="line">public class TrieMain &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Trie t  &#x3D;new Trie();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;CASE#1</span><br><span class="line">t.insert(&quot;bcde&quot;);</span><br><span class="line">t.insert(&quot;bckg&quot;);</span><br><span class="line">t.delete(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bckg&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*&#x2F;&#x2F;CASE#2</span><br><span class="line">t.insert(&quot;bcde&quot;);</span><br><span class="line">t.insert(&quot;bcdefg&quot;);</span><br><span class="line">t.delete(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcdefg&quot;);*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*&#x2F;&#x2F;CASE#3</span><br><span class="line">t.insert(&quot;bcde&quot;);</span><br><span class="line">t.insert(&quot;bc&quot;);</span><br><span class="line">t.delete(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bc&quot;);</span><br><span class="line">t.search(&quot;b&quot;);*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*&#x2F;&#x2F;CASE#4</span><br><span class="line">t.insert(&quot;bcde&quot;);</span><br><span class="line">t.delete(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);*&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;End of Class</span><br></pre></td></tr></table></figure><Br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Trie coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://jbj828.github.io/2020/02/16/Al-Trie/"/>
    <id>http://jbj828.github.io/2020/02/16/Al-Trie/</id>
    <published>2020-02-16T06:30:25.000Z</published>
    <updated>2020-02-17T00:43:39.182Z</updated>
    
    <content type="html"><![CDATA[<p>trie</p><a id="more"></a><p><strong>What is Trie?</strong></p><ul><li>It is a search tree, which is typically used to store/search strings in space/time efficient way.</li><li>In it, any node can store non repetitive multiple characters.</li><li>Also, every node stores ‘link’ of next character of the string.</li><li>Also, every node keeps a track of ‘end of String’</li></ul><br><p><strong>Why learn Trie?</strong></p><ul><li>Used to solve many standard problems in efficient ways<ul><li>Spelling checker</li><li>Auto Complete string</li><li>Etc..</li></ul></li></ul><br><p><strong>Creating a Trie</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Trie()</span><br><span class="line">  create a blank node</span><br></pre></td></tr></table></figure><br><p><strong>Inserting a String in Trie</strong></p><ul><li>Case#1 - Trie is blank(air)</li><li>Case#2 - New String’s prefix is common with another String’s Prefix(aio)</li><li>Case#3 - New String’s prefix is already present as complete String(airk)</li><li>Case#4 - String to be inserted is already present in Trie</li></ul><br><p><strong>Searching a String in Trie</strong> </p><p>ex)abc</p><ul><li>Case#1 - String does not exist in Trie(ex) xyz)</li><li>Case#2 - String exists in Trie(ex) abc)</li><li>Case#3 - Current String is a prefix of another String. But this string does not exist in Trie.(ex) ab)</li></ul><br><p><strong>Deleting a String from Trie</strong></p><ul><li>Case#1 - Some other word’s prefix is same as Prefix of this word(BCDE, BCKG)</li><li>Case#2 - This word is a prefix of some other word(BCDE,BCDEF)</li><li>Case#3 - Some other word is a prefix of this word(BCDE,BC)</li><li>Case#4 - No one is dependent on this word(k)</li></ul><Br><p><strong>Trie-Practical use</strong></p><ul><li>Auto Complete</li><li>Spell Checkers</li></ul><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;trie&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Heap Coding</title>
    <link href="http://jbj828.github.io/2020/02/15/Al-BinaryHeapCoding/"/>
    <id>http://jbj828.github.io/2020/02/15/Al-BinaryHeapCoding/</id>
    <published>2020-02-15T13:30:25.000Z</published>
    <updated>2020-02-15T13:26:55.261Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Heap Coding</p><a id="more"></a><p>HeapByArray.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class HeapByArray &#123;</span><br><span class="line">int[] arr;</span><br><span class="line">int sizeOfTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor</span><br><span class="line">public HeapByArray(int size) &#123;</span><br><span class="line">&#x2F;&#x2F;We are adding 1 here so that first cell of the array can be left blank all the time. This is eliminate problem of array starting from index 0.</span><br><span class="line">arr &#x3D; new int[size+1];</span><br><span class="line">this.sizeOfTree &#x3D; 0;</span><br><span class="line">System.out.println(&quot;Empty Heap has been created !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int sizeOfArray() &#123;</span><br><span class="line">return arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int sizeOfTree() &#123;</span><br><span class="line">System.out.println(&quot;Size Of Tree: &quot; + sizeOfTree);</span><br><span class="line">return sizeOfTree;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isHeapEmpty() &#123;</span><br><span class="line">if (sizeOfTree &lt;&#x3D; 0) &#123;</span><br><span class="line">System.out.println(&quot;Tree is empty !&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Tree is not empty !&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteheap() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Heap has been deleted !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Insert a new value in Heap</span><br><span class="line">public void insertInHeap(int value) &#123;</span><br><span class="line">&#x2F;&#x2F;Doing +1 because sizeOfTree always points to the last occupied cell of the array </span><br><span class="line">System.out.println(&quot;Inserting &quot; + value + &quot; in Heap...&quot;);</span><br><span class="line">arr[sizeOfTree+1] &#x3D; value;</span><br><span class="line">sizeOfTree++;</span><br><span class="line">HeapifyBottomToTop(sizeOfTree);</span><br><span class="line">System.out.println(&quot;Inserted &quot; + value + &quot; successfully in Heap !&quot;);</span><br><span class="line">levelOrder();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Peek into Heap</span><br><span class="line">public void peek() &#123;</span><br><span class="line">if(sizeOfTree &#x3D;&#x3D; 0) &#123;</span><br><span class="line">System.out.println(&quot;Heap is empty !&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Head of the Heap is: &quot; + arr[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Extract Head of Heap</span><br><span class="line">public int extractHeadOfHeap() &#123;</span><br><span class="line">if(sizeOfTree &#x3D;&#x3D; 0) &#123;</span><br><span class="line">System.out.println(&quot;Heap is empty !&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Head of the Heap is: &quot; + arr[1]);</span><br><span class="line">System.out.println(&quot;Extracting it now...&quot;);</span><br><span class="line">int extractedValue &#x3D; arr[1];</span><br><span class="line">arr[1] &#x3D; arr[sizeOfTree];</span><br><span class="line">sizeOfTree--;</span><br><span class="line">HeapifyTopToBottom(1);</span><br><span class="line">System.out.println(&quot;Successfully extracted value from Heap.&quot;);</span><br><span class="line">levelOrder();</span><br><span class="line">return extractedValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void HeapifyBottomToTop(int index) &#123;</span><br><span class="line">int parent &#x3D; index &#x2F; 2;</span><br><span class="line">&#x2F;&#x2F; We are at root of the tree. Hence no more Heapifying is required.</span><br><span class="line">if (index &lt;&#x3D; 1) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; If Current value is smaller than its parent, then we need to swap</span><br><span class="line">if (arr[index] &lt; arr[parent]) &#123;</span><br><span class="line">int tmp &#x3D; arr[index];</span><br><span class="line">arr[index] &#x3D; arr[parent];</span><br><span class="line">arr[parent] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">HeapifyBottomToTop(parent);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void HeapifyTopToBottom(int index) &#123;</span><br><span class="line">int left  &#x3D; index*2;</span><br><span class="line">int right &#x3D; (index*2)+1;</span><br><span class="line">int smallestChild &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (sizeOfTree &lt; left) &#123; &#x2F;&#x2F;If there is no child of this node, then nothing to do. Just return.</span><br><span class="line">return; </span><br><span class="line">&#125;else if (sizeOfTree &#x3D;&#x3D; left) &#123; &#x2F;&#x2F;If there is only left child of this node, then do a comparison and return.</span><br><span class="line">if(arr[index] &gt; arr[left]) &#123;</span><br><span class="line">int tmp &#x3D; arr[index];</span><br><span class="line">arr[index] &#x3D; arr[left];</span><br><span class="line">arr[left] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123; &#x2F;&#x2F;If both children are there</span><br><span class="line">if(arr[left] &lt; arr[right]) &#123; &#x2F;&#x2F;Find out the smallest child</span><br><span class="line">smallestChild &#x3D; left;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">smallestChild &#x3D; right;</span><br><span class="line">&#125;</span><br><span class="line">if(arr[index] &gt; arr[smallestChild]) &#123; &#x2F;&#x2F;If Parent is greater than smallest child, then swap</span><br><span class="line">int tmp &#x3D; arr[index];</span><br><span class="line">arr[index] &#x3D; arr[smallestChild];</span><br><span class="line">arr[smallestChild] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HeapifyTopToBottom(smallestChild);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void levelOrder() &#123;</span><br><span class="line">System.out.println(&quot;Printing all the elements of this Heap...&quot;);&#x2F;&#x2F; Printing from 1 because 0th cell is dummy</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; sizeOfTree; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Heap Coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Heap</title>
    <link href="http://jbj828.github.io/2020/02/14/Al-BinaryHeap/"/>
    <id>http://jbj828.github.io/2020/02/14/Al-BinaryHeap/</id>
    <published>2020-02-14T13:16:25.000Z</published>
    <updated>2020-02-15T14:46:04.039Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Heap theory </p><a id="more"></a><br><p><strong>What is Binary Heap</strong></p><ul><li><p>Definition : Binary Heap is a Binary Tree with some special properties.</p><br><ol><li><p>Heap property</p><ul><li>Value of any given node must be &lt;= value of its children(Min-Heap)</li><li>Value of any given node must be &gt;= value of its children(Max-Heap)<br></li></ul></li><li><p>Complete tree</p><ul><li>All levels are completely filled except possibly the last level and the last level has all keys as left as possible.</li><li>This makes Binary Heap ideal candidate for Array Implementation.</li></ul></li></ol></li></ul><Br><p><strong>Why should we learn Binary Heap?</strong></p><p>There are cases when we want to find ‘min/max’ number among set of numbers in log(n) time. Also, we want to make sure that Inserting additional numbers does not take more than O(log n) time.</p><br><ul><li><p>Possible Solutions:</p><ol><li>Store the numbers in sorted Array &lt;- Take O(n) time complexity</li><li>Store the numbers in Linked List in sorted manner &lt;- Take O(n) time complexity</li></ol></li></ul><br>Binary Heap will solve this problem with O(log n).<br><p><strong>Types of Binary Heap</strong></p><ol><li>Min-Heap : If the value of each node is less than or equal to value of both of its children.</li><li>Max-Heap : If the value of each node is more than or equal to value of both of its children.</li></ol><br><p><strong>Practical Use</strong></p><ol><li>Prim’s Algorithm</li><li>Heap Sort</li><li>Priority Queue</li></ol><p><br><br></p><h4 id="Binary-Heap-Array-Representaion"><a href="#Binary-Heap-Array-Representaion" class="headerlink" title="Binary Heap - Array Representaion"></a>Binary Heap - Array Representaion</h4><ul><li>Implementation options<ul><li>Array based Implementation</li><li>Reference/Pointer based Implementation</li></ul></li></ul><br><p><strong>Insertion in Heap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insertValueInHeap(value)</span><br><span class="line">  if tree does not exists</span><br><span class="line">    return error message</span><br><span class="line">  else</span><br><span class="line">    insert &#39;value&#39; in first unused cell of Array</span><br><span class="line">    sizeOfHeap++</span><br><span class="line">    heapifyBottomToTop(sizeOfHeap)  ----- O(log n) : this means the height of the tree, the recursive call will step every node until it reaches the number which is smaller(Min-Heap) than its children</span><br></pre></td></tr></table></figure><Br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>ExtractMin from Heap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extractMin()</span><br><span class="line">  if tree does not exist</span><br><span class="line">    return error message</span><br><span class="line">  else</span><br><span class="line">    extract 1st cell of Array</span><br><span class="line">    promote last element to first</span><br><span class="line">    sizeOfHeap--</span><br><span class="line">    heapifyTopToBottom(1)</span><br></pre></td></tr></table></figure><Br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>Delete Heap</strong></p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteHeap()</span><br><span class="line">  set array to null</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1) </li></ul><br><p><strong>Reason why we don’t use Reference implementation(linked list) on Binary Heap</strong></p><ul><li>When we try to extract min/max number from the tree using reference, we need to loop all over the tree to find the value. This procedure takes O(n) time complexity. Inefficient!!</li></ul><p><Br><Br></p><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Heap theory &lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>AVL Tree Coding</title>
    <link href="http://jbj828.github.io/2020/02/14/AVL-code/"/>
    <id>http://jbj828.github.io/2020/02/14/AVL-code/</id>
    <published>2020-02-14T05:16:25.000Z</published>
    <updated>2020-02-14T05:17:03.311Z</updated>
    
    <content type="html"><![CDATA[<p>AVL Tree Coding</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">import node.*;</span><br><span class="line"></span><br><span class="line">public class AVLTree &#123;</span><br><span class="line">    BinaryNode root;</span><br><span class="line">    public BinaryNode getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor</span><br><span class="line">    AVLTree() &#123;</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert values in AVL Tree</span><br><span class="line">    void insert(int value) &#123;</span><br><span class="line">        root &#x3D; insert(root, value);</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    BinaryNode insert(BinaryNode currentNode, int value) &#123;</span><br><span class="line">        &#x2F;&#x2F; THIS ELSE_IF BLOCK IS BST CONDITION</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Successfully inserted &quot; + value + &quot; in AVL Tree&quot;);</span><br><span class="line">            return createNewNode(value);</span><br><span class="line">        &#125; else if (value &lt;&#x3D; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setLeft(insert(currentNode.getLeft(), value));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.setRight(insert(currentNode.getRight(), value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; THIS IS WHERE WE WILL DO AVL SPECIFIC WORK</span><br><span class="line">        int balance &#x3D; checkBalance(currentNode.getLeft(), currentNode.getRight());</span><br><span class="line">        if (balance &gt; 1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getLeft().getLeft(), currentNode.getLeft().getRight()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);&#x2F;&#x2F; LL Condition</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setLeft(leftRotate(currentNode.getLeft())); &#x2F;&#x2F; LR Condition</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (balance &lt; -1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getRight().getRight(), currentNode.getRight().getLeft()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);&#x2F;&#x2F; RR Condition</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setRight(rightRotate(currentNode.getRight()));&#x2F;&#x2F; RL Condition</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getLeft().setHeight(calculateHeight(currentNode.getLeft()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentNode.getRight() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getRight().setHeight(calculateHeight(currentNode.getRight()));</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        return currentNode;</span><br><span class="line"></span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    private BinaryNode leftRotate(BinaryNode currentNode) &#123;</span><br><span class="line">        BinaryNode newRoot &#x3D; currentNode.getRight();</span><br><span class="line">        currentNode.setRight(currentNode.getRight().getLeft());</span><br><span class="line">        newRoot.setLeft(currentNode);</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        newRoot.setHeight(calculateHeight(newRoot));</span><br><span class="line">        return newRoot;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    private BinaryNode rightRotate(BinaryNode currentNode) &#123;</span><br><span class="line">        BinaryNode newRoot &#x3D; currentNode.getLeft();</span><br><span class="line">        currentNode.setLeft(currentNode.getLeft().getRight());</span><br><span class="line">        newRoot.setRight(currentNode);</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        newRoot.setHeight(calculateHeight(newRoot));</span><br><span class="line">        return newRoot;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    private int checkBalance(BinaryNode rootLeft, BinaryNode rootRight) &#123;</span><br><span class="line">        if((rootLeft &#x3D;&#x3D; null) &amp;&amp; (rootRight &#x3D;&#x3D; null)) &#123; &#x2F;&#x2F;if current node is a leaf node then no need to check balance of its children</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if (rootLeft &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return -1 * (rootRight.getHeight() + 1); &#x2F;&#x2F; if left node node is not there then simply return right node&#39;s</span><br><span class="line">            &#x2F;&#x2F; height + 1</span><br><span class="line">            &#x2F;&#x2F; we need to make it -1 because blank height is considered</span><br><span class="line">            &#x2F;&#x2F; having height as &#39;-1&#39;</span><br><span class="line">        &#125; else if (rootRight &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return rootLeft.getHeight() + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return rootLeft.getHeight() - rootRight.getHeight(); &#x2F;&#x2F; +1 is not required, as both right and left child</span><br><span class="line">            &#x2F;&#x2F; exits and 1 gets nullified</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Calculate height of Node</span><br><span class="line">    private int calculateHeight(BinaryNode currentNode) &#123;</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1 + Math.max((currentNode.getLeft() !&#x3D; null ? currentNode.getLeft().getHeight() : -1),</span><br><span class="line">                (currentNode.getRight() !&#x3D; null ? currentNode.getRight().getHeight() : -1));</span><br><span class="line"></span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; creates a new blank new node</span><br><span class="line">    public BinaryNode createNewNode(int value) &#123;</span><br><span class="line">        BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">        node.setValue(value);</span><br><span class="line">        node.setHeight(0);&#x2F;&#x2F; Since this is a leaf node, its height is 0</span><br><span class="line">        return node;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Level order traversal of BST</span><br><span class="line">    void levelOrderTraversal() &#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        System.out.println(&quot;Printing Level order traversal of AVL Tree...&quot;);</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists !&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">            System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">            if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getLeft());</span><br><span class="line">            if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deleting a node from BST</span><br><span class="line">    public void deleteNodeOfBST(int value) &#123;</span><br><span class="line">        System.out.println(&quot;Deleting &quot; + value + &quot; from AVL Tree ...&quot;);</span><br><span class="line">        root &#x3D; deleteNodeOfBST(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method for delete</span><br><span class="line">    public BinaryNode deleteNodeOfBST(BinaryNode currentNode, int value) &#123;</span><br><span class="line">        &#x2F;&#x2F; THIS ELSE_IF BLOCK IS BST CONDITION</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        if (value &lt; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setLeft(deleteNodeOfBST(currentNode.getLeft(), value));</span><br><span class="line">        &#125; else if (value &gt; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setRight(deleteNodeOfBST(currentNode.getRight(), value));</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; If currentNode is the node to be deleted</span><br><span class="line">            &#x2F;&#x2F;System.out.println(&quot;currentNode is the node to be deleted&quot;);</span><br><span class="line">            if (currentNode.getLeft() !&#x3D; null &amp;&amp; currentNode.getRight() !&#x3D; null) &#123; &#x2F;&#x2F; if nodeToBeDeleted have both children</span><br><span class="line">                BinaryNode temp &#x3D; currentNode;</span><br><span class="line">                BinaryNode minNodeForRight &#x3D; minimumElement(temp.getRight());&#x2F;&#x2F; Finding minimum element from right subtree</span><br><span class="line">                currentNode.setValue(minNodeForRight.getValue()); &#x2F;&#x2F; Replacing current node with minimum node from right subtree</span><br><span class="line">                deleteNodeOfBST(currentNode.getRight(), minNodeForRight.getValue());&#x2F;&#x2F; Deleting minimum node from right now</span><br><span class="line">            &#125; else if (currentNode.getLeft() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only left child</span><br><span class="line">                currentNode &#x3D; currentNode.getLeft();</span><br><span class="line">            &#125; else if (currentNode.getRight() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only right child</span><br><span class="line">                currentNode &#x3D; currentNode.getRight();</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; if nodeToBeDeleted do not have child (Leaf node)</span><br><span class="line">                &#x2F;&#x2F;System.out.println(&quot;This node is leaf node&quot;);</span><br><span class="line">                currentNode &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            return currentNode;&#x2F;&#x2F; if it is a leaf node,then no need to do balancing for this node, do only for its ancestors</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; THIS IS WHERE WE WILL DO AVL SPECIFIC WORK</span><br><span class="line">        int balance &#x3D; checkBalance(currentNode.getLeft(), currentNode.getRight());</span><br><span class="line">        if (balance &gt; 1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getLeft().getLeft(), currentNode.getLeft().getRight()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);&#x2F;&#x2F; LL Condition</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setLeft(leftRotate(currentNode.getLeft())); &#x2F;&#x2F; LR Condition</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (balance &lt; -1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getRight().getRight(), currentNode.getRight().getLeft()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);&#x2F;&#x2F; RR Condition</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setRight(rightRotate(currentNode.getRight()));&#x2F;&#x2F; RL Condition</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getLeft().setHeight(calculateHeight(currentNode.getLeft()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentNode.getRight() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getRight().setHeight(calculateHeight(currentNode.getRight()));</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        return currentNode;</span><br><span class="line"></span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Get minimum element in binary search tree</span><br><span class="line">    public static BinaryNode minimumElement(BinaryNode root) &#123;</span><br><span class="line">        if (root.getLeft() &#x3D;&#x3D; null)</span><br><span class="line">            return root;</span><br><span class="line">        else &#123;</span><br><span class="line">            return minimumElement(root.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void printTreeGraphically() &#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; level &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        int CurrentLevel &#x3D; 1;</span><br><span class="line">        boolean previousLevelWasAllNull &#x3D; false;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        level.add(1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\nPrinting Level order traversal of Tree...&quot;);</span><br><span class="line">        if(root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists !&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            if(CurrentLevel &#x3D;&#x3D; level.peek()) &#123; &#x2F;&#x2F;if we are in the same level</span><br><span class="line">                if(queue.peek()&#x3D;&#x3D;null) &#123;</span><br><span class="line">                    queue.add(null);level.add(CurrentLevel+1);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    queue.add(queue.peek().getLeft());level.add(CurrentLevel+1);</span><br><span class="line">                    queue.add(queue.peek().getRight());level.add(CurrentLevel+1);</span><br><span class="line">                    previousLevelWasAllNull &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(queue.remove() + &quot;  &quot;);level.remove();</span><br><span class="line">            &#125;else &#123; &#x2F;&#x2F;level has changed</span><br><span class="line">                System.out.println(&quot;\n&quot;);</span><br><span class="line">                CurrentLevel++;</span><br><span class="line">                if(previousLevelWasAllNull &#x3D;&#x3D; true) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                previousLevelWasAllNull &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#x2F;&#x2F;end of loop</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AVL Tree Coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>AVL Tree</title>
    <link href="http://jbj828.github.io/2020/02/12/Al-AVL-Tree/"/>
    <id>http://jbj828.github.io/2020/02/12/Al-AVL-Tree/</id>
    <published>2020-02-12T06:30:25.000Z</published>
    <updated>2020-02-12T14:47:49.330Z</updated>
    
    <content type="html"><![CDATA[<p>AVL Tree</p><a id="more"></a><p><strong>Why AVL Tree?</strong></p><ul><li>Depending on Incoming data, A Binary Search tree can get skewed and hence its performance starts going down. Instead of O(log n) for insertion/searching/deleting it can go up to O(n)</li><li>AVL tree attempts to solve this problem of ‘skewing’ by introducing concept called ‘Rotation’.</li></ul><p><strong>What is AVL Tree?</strong></p><ul><li>An AVL tree is a balanced ‘Binary Search Tree’ where the height of immediate subtrees of any node differs by at most one(also called balance factor).</li><li>If at any time heights differ by more than one, rebalancing is done to restore this property(called rotation).</li><li>Empty height is always considered -1.</li></ul><br><h3 id="Algorithm-of-AVL-Tree"><a href="#Algorithm-of-AVL-Tree" class="headerlink" title="Algorithm of AVL Tree"></a>Algorithm of AVL Tree</h3><ul><li>create, search, traverse Algorithm is totally same as the BST.</li></ul><h4 id="Insertion-of-node-in-AVL-Tree"><a href="#Insertion-of-node-in-AVL-Tree" class="headerlink" title="Insertion of node in AVL Tree"></a>Insertion of node in AVL Tree</h4><ul><li>Case#1 - Whene ‘rotation’ is not required.<ul><li>The algorithm is same as the BST Insertion.</li></ul></li><li>Case#2 - When ‘rotation is required(LL, LR, RR, RL).</li></ul><p><strong>Left-Left Condition</strong></p><ul><li>What is Left-Left condition?<ul><li>Left-Left Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Right Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rightRotate(currentDisbalancedNode)</span><br><span class="line">  newRoot &#x3D; currentDisbalancedNode.left</span><br><span class="line">  currentDisbalancedNode.left &#x3D; currentDisbalancedNode.left.right</span><br><span class="line">  newRoot.right &#x3D; currentDisbalancedNode</span><br><span class="line">  currentDisabledNode.height &#x3D; calculateHeight(currentDisbalancedNode)</span><br><span class="line">  newRoot.height &#x3D; calculateHeight(newRoot)</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Left-Right Condition</strong></p><ul><li>What is Left-Right condition?<ul><li>Left-Right Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Left Rotation followed by Right Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">leftRotate(currentDisbalancedNode&#39;sLeftChild)</span><br><span class="line">  newRoot &#x3D; currentDisbalancedNode&#39;sLeftChild.right</span><br><span class="line">  currentDisbalancedNode&#39;sLeftChild.right &#x3D; currentDisbalancedNode&#39;sLeftChild.right.left</span><br><span class="line">  newRoot.left &#x3D; currentDisbalancedNode&#39;sLeftChild</span><br><span class="line">  currentDisbalancedNode&#39;sLeftChild.Height &#x3D; calculateHeight(currentDisbalancedNode&#39;sLeftChild)</span><br><span class="line">  newRoot.Height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  rightRotate(currentDisbalancedNode)  ------ left-left Condition이랑 같음</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Right-Right Condition</strong></p><ul><li>What is Right-Right condition?<ul><li>Right-Right Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Left Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftRotate(currentDisbalancedNode)</span><br><span class="line">  newRoot &#x3D; currentDisbalancedNode.right</span><br><span class="line">  currentDisbalancedNode.right &#x3D; currentDisbalancedNode.right.left</span><br><span class="line">  newRoot.left &#x3D; currentDisbalancedNode</span><br><span class="line">  currentDisbalancedNode.Height &#x3D; calculateHeight(currentDisbalancedNode)</span><br><span class="line">  newRoot.Height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Right-left Condition</strong></p><ul><li>What is Right-left condition?<ul><li>Right-left Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Right Rotation followed by Left Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rightRotate(currentDisableNode&#39;sRight)</span><br><span class="line">  newRoot &#x3D; currentDisableNode&#39;sRight.left</span><br><span class="line">  currentDisableNode&#39;sRight.left.right &#x3D; currentDisableNode&#39;sRight</span><br><span class="line">  currentDisableNode&#39;sRight.height &#x3D; calculateHeight(currentDisableNode&#39;sRight)</span><br><span class="line">  newRoot.height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot;</span><br><span class="line"></span><br><span class="line">leftRotate(currentDisabledNode)</span><br><span class="line">  newRoot &#x3D; currentDisabledNode.right</span><br><span class="line">  currentDisabledNode.right &#x3D; currentDisabledNode.right.left</span><br><span class="line">  newRoot.left &#x3D; currentDisabledNode</span><br><span class="line">  currentDisabledNode.height &#x3D; calculateHeight(currentDisabledNode)</span><br><span class="line">  newRoot.height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Insertion Algorithm in AVL Tree</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Node Insert(Node root, int data)</span><br><span class="line">  if(root &#x3D;&#x3D; null) return new Node(data)</span><br><span class="line">  else if(data &lt;&#x3D; root.data) root.left &#x3D; insert(root.left, data)</span><br><span class="line">  else root.right &#x3D; insert(root.right, data)</span><br><span class="line">  </span><br><span class="line">  int balance &#x3D; height(root.left) - height(root.right)</span><br><span class="line">  if(balance &gt; 1)</span><br><span class="line">    if height(root.left.left) &gt;&#x3D; height(root.left.right)</span><br><span class="line">      RightRotation(root) &#x2F;&#x2F;LL condition</span><br><span class="line">    else</span><br><span class="line">      LeftRotation(root.left)</span><br><span class="line">      RightRotation(root)  &#x2F;&#x2F; LR condition</span><br><span class="line"></span><br><span class="line">  else if(balance &lt; -1)  &#x2F;&#x2F; if right subtree is overloaded</span><br><span class="line">    if height(root.right.right) &gt;&#x3D; height(root.right.left)</span><br><span class="line">      LeftRotation(root)  &#x2F;&#x2F; RR condition</span><br><span class="line">    else</span><br><span class="line">      RightRotation(root.right)</span><br><span class="line">      LeftRotation(root)  &#x2F;&#x2F; RL condition</span><br><span class="line">  </span><br><span class="line">  root.height &#x3D; max(root.left, root.right) + 1</span><br><span class="line">  return root</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n)</li></ul><br><h4 id="Deletion-of-Node-from-AVL-Tree"><a href="#Deletion-of-Node-from-AVL-Tree" class="headerlink" title="Deletion of Node from AVL Tree"></a>Deletion of Node from AVL Tree</h4><ul><li>Deletion of a node<ul><li>Case#1 - When tree does not exists</li><li>Case#2 - When ‘rotation’ is not required(BST Conditions)<ul><li>Node to be deleted is leaf node</li><li>Node to be deleted is having 1 child</li><li>Node to be deleted has 2 children</li></ul></li><li>Case#3 - When ‘rotation’ is required(LL, LR, RR, RL)</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeOfAVL(currentNode, valueToBeDeleted)</span><br><span class="line">  if(currentNode &#x3D;&#x3D; null) return null;</span><br><span class="line"></span><br><span class="line">  if(valueToBeDeleted &lt; currentNode.value)</span><br><span class="line">    then currentNode.left &#x3D; deleteNodeOfAVL(currentNode.left, valueToBeDeleted)</span><br><span class="line">  else if(valueToBeDeleted &gt; currentNode.value)</span><br><span class="line">    then currentNode.right &#x3D; deleteNodeOfAVL(currentNode.right, valueToBeDeleted)</span><br><span class="line">  else  &#x2F;&#x2F;if the currentNode is the node to be deleted</span><br><span class="line">      if currentNode have both children, then find minimum element from right subtree(Case#3)</span><br><span class="line">          replace current node with minimum node from right subtree and delete minimum node from right</span><br><span class="line"></span><br><span class="line">      else if nodeToBeDeleted has only left child(Case#2)</span><br><span class="line">            then currentNode &#x3D; currentNode.left</span><br><span class="line">      else if nodeToBeDeleted has only right child</span><br><span class="line">      (Case#2)</span><br><span class="line">            then currentNode &#x3D; currentNode.right</span><br><span class="line">      </span><br><span class="line">      else &#x2F;&#x2F;if nodeToBeDeleted do not have child(Case#1)</span><br><span class="line">            currentNode &#x3D; null;</span><br><span class="line"></span><br><span class="line">  int balance &#x3D; checkBalance(currentNode.left, currentNode.right);</span><br><span class="line"></span><br><span class="line">  if(balance &gt; 1)</span><br><span class="line">      if(checkBalance(currentNode.left().left(), currentNode.left().right()) &gt; 0)</span><br><span class="line">          currentNode &#x3D; rightRotate(currentNode); &#x2F;&#x2F;LL Condition</span><br><span class="line">      </span><br><span class="line">      else </span><br><span class="line">          currentNode.left &#x3D; leftRotate(currentNode.left);</span><br><span class="line">          currentNode &#x3D; rightRotate  &#x2F;&#x2F;LR condition</span><br><span class="line">    </span><br><span class="line">    else if(balance &lt; -1)</span><br><span class="line">      if(checkBalance(currentNode.right().right(), currentNode.right().left()) &gt; 0)</span><br><span class="line">          currentNode &#x3D; leftRotate(currentNode); &#x2F;&#x2F;RR Condition</span><br><span class="line"></span><br><span class="line">      else </span><br><span class="line">          currentNode.right &#x3D; rightRotate(currentNode.right); &#x2F;&#x2F;RL condition</span><br><span class="line">          currentNode &#x3D; leftRotate(currentNode);</span><br><span class="line"></span><br><span class="line">  if(currentNode.left() !&#x3D; null) then currentNode.left().setHeight(calculateHeight(currentNode.left));</span><br><span class="line">  if(currentNode.right() !&#x3D; null) then currentNode.right().setHeight(calculateHeight(currentNode.right());</span><br><span class="line">  currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line"></span><br><span class="line">  return currentNode;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n)</li></ul><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AVL Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree Coding</title>
    <link href="http://jbj828.github.io/2020/02/11/Al-BST-code/"/>
    <id>http://jbj828.github.io/2020/02/11/Al-BST-code/</id>
    <published>2020-02-11T09:30:25.000Z</published>
    <updated>2020-02-11T10:25:35.382Z</updated>
    
    <content type="html"><![CDATA[<p>BST Coding</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import node.BinaryNode;</span><br><span class="line"></span><br><span class="line">public class BinarySearchTreeByLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    BinaryNode root;</span><br><span class="line"></span><br><span class="line">    public BinaryNode getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor</span><br><span class="line">    BinarySearchTreeByLinkedList() &#123;</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert values in BST</span><br><span class="line">    void insert(int value) &#123;</span><br><span class="line">        root &#x3D; insert(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    BinaryNode insert(BinaryNode currentNode, int value) &#123;</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; if root node is blank then insert new node there</span><br><span class="line">            System.out.println(&quot;Successfully inserted &quot; + value + &quot; in BST&quot;);</span><br><span class="line">            return createNewNode(value);</span><br><span class="line">        &#125; else if (value &lt;&#x3D; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setLeft(insert(currentNode.getLeft(), value));</span><br><span class="line">            return currentNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.setRight(insert(currentNode.getRight(), value));</span><br><span class="line">            return currentNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; creates a new blank new node</span><br><span class="line">    public BinaryNode createNewNode(int value) &#123;</span><br><span class="line">        BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">        node.setValue(value);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deleting a node from BST</span><br><span class="line">    public void deleteNodeOfBST(int value) &#123;</span><br><span class="line">        System.out.println(&quot;\n\nDeleting &quot; + value + &quot; from BST...&quot;);</span><br><span class="line">        deleteNodeOfBST(root,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method for delete</span><br><span class="line">    public BinaryNode deleteNodeOfBST(BinaryNode root, int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Value not found in BST&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (value &lt; root.getValue()) &#123;</span><br><span class="line">            root.setLeft(deleteNodeOfBST(root.getLeft(), value));</span><br><span class="line">        &#125; else if (value &gt; root.getValue()) &#123;</span><br><span class="line">            root.setRight(deleteNodeOfBST(root.getRight(), value));</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; If currentNode is the node to be deleted</span><br><span class="line"></span><br><span class="line">            if (root.getLeft() !&#x3D; null &amp;&amp; root.getRight() !&#x3D; null) &#123; &#x2F;&#x2F; if nodeToBeDeleted have both children</span><br><span class="line">                BinaryNode temp &#x3D; root;</span><br><span class="line">                BinaryNode minNodeForRight &#x3D; minimumElement(temp.getRight());&#x2F;&#x2F; Finding minimum element from right subtree</span><br><span class="line">                root.setValue(minNodeForRight.getValue()); &#x2F;&#x2F; Replacing current node with minimum node from right subtree</span><br><span class="line">                root.setRight(deleteNodeOfBST(root.getRight(), minNodeForRight.getValue()));  &#x2F;&#x2F; Deleting minimum node from right now</span><br><span class="line">            &#125; else if (root.getLeft() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only left child</span><br><span class="line">                root &#x3D; root.getLeft();</span><br><span class="line">            &#125; else if (root.getRight() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only right child</span><br><span class="line">                root &#x3D; root.getRight();</span><br><span class="line">            &#125; else &#x2F;&#x2F; if nodeToBeDeleted do not have child (Leaf node)</span><br><span class="line">                root &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Get minimum element in binary search tree</span><br><span class="line">    public static BinaryNode minimumElement(BinaryNode root) &#123;</span><br><span class="line">        if (root.getLeft() &#x3D;&#x3D; null)</span><br><span class="line">            return root;</span><br><span class="line">        else &#123;</span><br><span class="line">            return minimumElement(root.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search a node in BST</span><br><span class="line">    void searchForValue(int value) &#123;</span><br><span class="line">        searchForValue(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search a node in BST</span><br><span class="line">    BinaryNode searchForValue(BinaryNode node, int value) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Value: &quot; + value + &quot; not found in BST.&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else if (node.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">            System.out.println(&quot;Value: &quot; + value + &quot; found in BST.&quot;);</span><br><span class="line">            return node;</span><br><span class="line">        &#125; else if (value &lt; node.getValue()) &#123;</span><br><span class="line">            return searchForValue(node.getLeft(), value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return searchForValue(node.getRight(), value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Level order traversal of BST</span><br><span class="line">    void levelOrderTraversal() &#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        System.out.println(&quot;\nPrinting Level order traversal of Tree...&quot;);</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists !&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">            System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">            if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getLeft());</span><br><span class="line">            if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete entire BST</span><br><span class="line">    public void deleteTree() &#123;</span><br><span class="line">        System.out.println(&quot;Deleting entire Tree...&quot;);</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">        System.out.println(&quot;Tree deleted successfully !&quot;);</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void printTreeGraphically()&#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; level &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        int CurrentLevel &#x3D; 1;</span><br><span class="line">        boolean previousLevelWasAllNull &#x3D; false;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        level.add(1);</span><br><span class="line"></span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            if(CurrentLevel &#x3D;&#x3D; level.peek())&#123;</span><br><span class="line">                if(queue.peek() &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    queue.add(null);</span><br><span class="line">                    level.add(CurrentLevel +1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    queue.add(queue.peek().getLeft());</span><br><span class="line">                    level.add(CurrentLevel + 1);</span><br><span class="line">                    queue.add(queue.peek().getRight());</span><br><span class="line">                    level.add(CurrentLevel + 1);</span><br><span class="line">                    previousLevelWasAllNull &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(queue.remove() + &quot; &quot;);</span><br><span class="line">                level.remove();</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;\n&quot;);</span><br><span class="line">                CurrentLevel++;</span><br><span class="line">                if(previousLevelWasAllNull &#x3D;&#x3D; true)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                previousLevelWasAllNull &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BST Coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree</title>
    <link href="http://jbj828.github.io/2020/02/10/Al-BST/"/>
    <id>http://jbj828.github.io/2020/02/10/Al-BST/</id>
    <published>2020-02-10T14:30:25.000Z</published>
    <updated>2020-02-11T02:55:18.265Z</updated>
    
    <content type="html"><![CDATA[<p>The theory of BST</p><a id="more"></a><p><strong>What is BST?</strong></p><ul><li>Binary Search Tree(BST) is a Binary Tree which all the nodes follows the below mentioned properties<ul><li>The left sub-tree of a node has a key less than or equal to its parent node’s key.</li><li>The right sub tree of a node has a key greater than to its parent node’s key.</li></ul></li></ul><br><p><strong>Why should we learn BST?</strong></p><ul><li>Binary tree implemented by linked list has good space efficient compared to the BT implemented by Array. However, it is not good on Insertion, deletion, searching, traversing which has time complexity of O(n). BST will improve the time complexity of binary tree by O(log n).</li></ul><p><br><br></p><p><strong>Algorithm - Creation of blank BST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createBST()</span><br><span class="line">  Initialize Root with null</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Algorithm - Searching a node in BST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BST_Search(root, value)  ------------T(n)</span><br><span class="line">  if(root is null)</span><br><span class="line">    return null</span><br><span class="line">  else if(root &#x3D;&#x3D; value)</span><br><span class="line">    return root</span><br><span class="line">  else if(value &lt; root)</span><br><span class="line">    BST_Search(root.left, value)  ----T(n&#x2F;2)</span><br><span class="line">  else if(value &gt; root)</span><br><span class="line">    BST_Search(root.right, value) ----T(n&#x2F;2)</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) —-beacuse of recursive call</li></ul><br><p><strong>Algorithm - Traverse in BST</strong></p><ul><li>Totally same as traversing Binary Tree</li></ul><br><p><strong>Algorithm - Inserting a node in BST</strong></p><ul><li>Cases<ul><li>BST is  blank</li><li>BST is non-blank</li></ul></li></ul><p>Using Stack on the behind of the scene.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BST_Insert(currentNode, valueToInsert)</span><br><span class="line">  if(currentNode is null)</span><br><span class="line">    create a node, insert &#39;valueToInsert&#39; in it</span><br><span class="line">  else if(valueToInsert &lt;&#x3D; currentNode&#39;s value)</span><br><span class="line">    currentNode.left &#x3D; BST_Insert(currentNode.left, valueToInsert)</span><br><span class="line">  else</span><br><span class="line">    currentNode.right &#x3D; BST_Insert(currentNode.right, valueToInsert)</span><br><span class="line">  return currentNode</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>Algorithm - Deleting a node in BST</strong></p><ul><li>Cases<ul><li>Node to be deleted is leaf node</li><li>Node to be deleted is having 1 child</li><li>Node to be deleted has 2 child</li></ul></li></ul><p>Using Stack on the behind of the scene.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeOfBST(root, valueToBeDeleted)  --------------------------------------T(n)</span><br><span class="line">  if(root &#x3D;&#x3D; null) return null;</span><br><span class="line">  if(valueToBeDeleted &lt; root.value)</span><br><span class="line">    then root.left &#x3D; deleteNodeOfBST(root.left, valueToBeDeleted)   ---------------T(n&#x2F;2)</span><br><span class="line">  else if(valueToBeDeleted &gt; root.value)</span><br><span class="line">    then root.right &#x3D; deleteNodeOfBST(root.right, valueToBeDeleted)  ---------------T(n&#x2F;2)</span><br><span class="line">  else &#x2F;&#x2F; if cuurentNode is the node to be deleted</span><br><span class="line">      if root have both children, then find minimum element from right subtree(Case#3)  -------------O(log n)</span><br><span class="line">          replace current node with minimum node from right subtree and delete minimum node from right</span><br><span class="line">      else if node ToBeDeleted has only left child(Case#2)</span><br><span class="line">            then root &#x3D; root.left();</span><br><span class="line">      else &#x2F;&#x2F; if node ToBeDeleted do not have child(Case#1)</span><br><span class="line">            root &#x3D; null;</span><br><span class="line">  return root;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>Algorithm - Deleting entire tree in BST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeleteBST()</span><br><span class="line">  root &#x3D; null;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1) </li></ul><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The theory of BST&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Code(Array Implementation)</title>
    <link href="http://jbj828.github.io/2020/02/10/Al-BT-arrayCode/"/>
    <id>http://jbj828.github.io/2020/02/10/Al-BT-arrayCode/</id>
    <published>2020-02-10T13:30:25.000Z</published>
    <updated>2020-02-10T13:57:29.861Z</updated>
    
    <content type="html"><![CDATA[<p>Array Implementation code</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeByArray &#123;</span><br><span class="line">int [] arr;</span><br><span class="line">int lastUsedIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor for blank Tree</span><br><span class="line">public BinaryTreeByArray(int size) &#123;</span><br><span class="line">arr &#x3D; new int[size+1];</span><br><span class="line">this.lastUsedIndex &#x3D; 0; </span><br><span class="line">System.out.println(&quot;Blank Tree of size &quot; +size+ &quot; has been created !\n&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Check if array is full</span><br><span class="line">boolean isTreeFull()&#123;</span><br><span class="line">if(arr.length-1 &#x3D;&#x3D; lastUsedIndex) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; New node should be inserted at the first empty place in the array</span><br><span class="line">void insert(int value) &#123;</span><br><span class="line">if(!isTreeFull()) &#123;</span><br><span class="line">arr[lastUsedIndex+1] &#x3D; value;</span><br><span class="line">lastUsedIndex++;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot;+value+ &quot; in the tree!&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Could not insert value in the Tree as it is full !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;level-Order traversal of binary tree</span><br><span class="line">public void levelOrder() &#123;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;lastUsedIndex;i++ ) &#123;</span><br><span class="line">System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Pre-Order traversal of binary tree</span><br><span class="line">public void preOrder(int index) &#123;</span><br><span class="line">if (index &gt; lastUsedIndex) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(arr[index] + &quot; &quot;);</span><br><span class="line">preOrder(index * 2);</span><br><span class="line">preOrder(index * 2 + 1);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Post-Order Traversal of binary tree</span><br><span class="line">void postOrder(int index) &#123;</span><br><span class="line">if (index &gt; lastUsedIndex) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">postOrder(index * 2);</span><br><span class="line">postOrder(index * 2 + 1);</span><br><span class="line">System.out.print(arr[index] + &quot; &quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; In-Order Traversal of binary tree</span><br><span class="line">void inOrder(int index) &#123;</span><br><span class="line">if (index &gt; lastUsedIndex) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">inOrder(index * 2);</span><br><span class="line">System.out.print(arr[index] + &quot; &quot;);</span><br><span class="line">inOrder(index * 2 + 1);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Do a linear search on the array </span><br><span class="line">public int search(int value) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; lastUsedIndex; i++) &#123;</span><br><span class="line">if (arr[i] &#x3D;&#x3D; value) &#123;</span><br><span class="line">System.out.print(value +&quot; exists in the Tree! &quot;);</span><br><span class="line">System.out.println(&quot;It is at the location: &quot; + i);</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(value + &quot; does not exists in Tree !&quot;);</span><br><span class="line">System.out.println();</span><br><span class="line">return -1;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; delete operation of binary tree</span><br><span class="line">public void delete(int value) &#123;</span><br><span class="line">int location &#x3D; search(value);</span><br><span class="line">&#x2F;&#x2F;If Value does not exists in Array</span><br><span class="line">if (location &#x3D;&#x3D; -1) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;insert last element of the Tree into current location</span><br><span class="line">arr[location] &#x3D; arr[lastUsedIndex];</span><br><span class="line">lastUsedIndex--;</span><br><span class="line">System.out.println(&quot;Successfully deleted &quot; + value + &quot; from the Tree !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteTree()&#123;</span><br><span class="line">try &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Tree has been deleted successfully !&quot;);</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">System.out.println(&quot;There was an error deleting the tree.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Array Implementation code&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree - Array Implementation</title>
    <link href="http://jbj828.github.io/2020/02/09/Al-BT-array/"/>
    <id>http://jbj828.github.io/2020/02/09/Al-BT-array/</id>
    <published>2020-02-09T13:30:25.000Z</published>
    <updated>2020-02-10T05:59:33.729Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree implemented by Array</p><a id="more"></a><p><strong>How does tree looks when implemented via Array?</strong></p><ul><li>Left Child - cell[2x]</li><li>Right Child - cell[2x+1]</li><li>cell[0] = null </li></ul><br><p><strong>Creation of Binary tree</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createBinaryTree()</span><br><span class="line">  create a blank array of &#39;size&#39;</span><br><span class="line">  update lastUsedIndex to 0</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(1)</li><li>Space Complextiy : O(n)</li></ul><br><p><strong>Insertion of node</strong></p><ul><li>Insertion<ul><li>If array is full, return error message</li><li>Insert at first vacant cell in Array</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insertValueInBinaryTree()</span><br><span class="line">  if Tree is full</span><br><span class="line">    return error message</span><br><span class="line">  else</span><br><span class="line">    insert value in first unused cell of array</span><br><span class="line">    update lastUsedIndex</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(1)</li><li>Space Complextiy : O(1)</li></ul><br><p><strong>Search a node</strong></p><ul><li>Search<ul><li>When the value to be searched does not exists in the tree</li><li>When the value to be searched exists in the tree</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">searchValueInBinaryTree()</span><br><span class="line">  traverse the entire array from 1 to lastUsedIndex</span><br><span class="line">  if value is found</span><br><span class="line">    return success message</span><br><span class="line">  return error message</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(1)</li></ul><br><p><strong>In-Order Traversal</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InorderTraversal(index)</span><br><span class="line">  if index &gt; lastUsedIndex</span><br><span class="line">      return</span><br><span class="line">  else</span><br><span class="line">    InorderTraversal(index*2)</span><br><span class="line">    print current index.value</span><br><span class="line">    InorderTraversal(index*2 + 1)</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(n) —- stack에 쌓이기 때문에</li></ul><br><p><strong>Levle-Order Traversal</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">levelOrderTraversal()</span><br><span class="line">  loop: 1 to lastUsedIndex</span><br><span class="line">    print current index.value</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(1) </li></ul><br><p><strong>Deletion of Node</strong></p><ul><li>Deletion<ul><li>When the value to be deleted is not existing in the tree</li><li>When the value to be deleted is exists in the tree</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeFromBinaryTree()</span><br><span class="line">  search for desired value in array</span><br><span class="line">    if value found</span><br><span class="line">      replace this cell&#39;s value with last cell and update lastUsedIndex</span><br><span class="line">  return error message</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(1) </li></ul><br><p><strong>Delete Binary Tree</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteBinaryTree()</span><br><span class="line">  set array as null</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(1)</li><li>Space Complextiy : O(1) </li></ul><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree implemented by Array&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Code(Linked list)</title>
    <link href="http://jbj828.github.io/2020/02/08/Al-BT-linkedlist-code/"/>
    <id>http://jbj828.github.io/2020/02/08/Al-BT-linkedlist-code/</id>
    <published>2020-02-08T13:30:25.000Z</published>
    <updated>2020-02-08T12:10:30.642Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree code by linked list</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">import node.BinaryNode;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeByLinkedList &#123;</span><br><span class="line">BinaryNode root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor for creating a blank Binary Tree</span><br><span class="line">BinaryTreeByLinkedList()&#123;</span><br><span class="line">this.root &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; inserts a new node at deepest place in Tree</span><br><span class="line">void insert(int value) &#123;</span><br><span class="line">BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">node.setValue(value);</span><br><span class="line">if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">root &#x3D; node;</span><br><span class="line">System.out.println(&quot;Successfully inserted new node at Root !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">presentNode.setLeft(node);</span><br><span class="line">System.out.println(&quot;Successfully inserted new node !&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;else if (presentNode.getRight() &#x3D;&#x3D; null) &#123;</span><br><span class="line">presentNode.setRight(node);</span><br><span class="line">System.out.println(&quot;Successfully inserted new node !&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of else-if</span><br><span class="line">&#125;&#x2F;&#x2F;end of loop</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Search for a given value in binary tree</span><br><span class="line">void search(int value) &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">System.out.println(&quot;Value-&quot;+value+&quot; is found in Tree !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if (presentNode.getLeft()!&#x3D;null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight()!&#x3D;null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of loop</span><br><span class="line">System.out.println(&quot;Value-&quot;+value+&quot; is not found in Tree !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; delete node from binary tree</span><br><span class="line">void deleteNodeOfBinaryTree(int value) &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">&#x2F;&#x2F; if node is found then copy deepest node here and delete deepest node.</span><br><span class="line">if (presentNode.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">presentNode.setValue(getDeepestNode().getValue());</span><br><span class="line">DeleteDeepestNode();</span><br><span class="line">System.out.println(&quot;Deleted the node !!&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of while loop</span><br><span class="line">System.out.println(&quot;Did not find the node!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete deepest node</span><br><span class="line">public void DeleteDeepestNode() &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">BinaryNode previousNode, presentNode &#x3D; null;</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">previousNode &#x3D; presentNode;</span><br><span class="line">presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">previousNode.setRight(null);</span><br><span class="line">return;</span><br><span class="line">&#125;else if ((presentNode.getRight() &#x3D;&#x3D; null)) &#123;</span><br><span class="line">presentNode.setLeft(null);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of while loop</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; get last node of last level of binary tree</span><br><span class="line">public BinaryNode getDeepestNode() &#123;</span><br><span class="line">&#x2F;&#x2F; make an empty queue. Queue is Interface and LinkedList is class</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">BinaryNode presentNode &#x3D; null;</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">return presentNode;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pre-order traversal of binary tree</span><br><span class="line">void preOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">preOrder(node.getLeft());</span><br><span class="line">preOrder(node.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; post-order traversal of binary tree</span><br><span class="line">void postOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">postOrder(node.getLeft());</span><br><span class="line">postOrder(node.getRight());</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; in-order traversal of binary tree</span><br><span class="line">void inOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">inOrder(node.getLeft());</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">inOrder(node.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; level order traversal of binary tree</span><br><span class="line">void levelOrder() &#123;</span><br><span class="line">&#x2F;&#x2F; make a queue for level order. Queue is Interface and LinkedList is class</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">&#125;</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Delete Tree</span><br><span class="line">void deleteTree() &#123;</span><br><span class="line">root &#x3D; null;</span><br><span class="line">System.out.println(&quot;Binary Tree has been deleted successfully&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree code by linked list&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree - Traverse, Search, Insertion,(Linked List Implementation)</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-binaryTreeTraverse/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-binaryTreeTraverse/</id>
    <published>2020-02-06T14:30:25.000Z</published>
    <updated>2020-02-09T12:45:04.868Z</updated>
    
    <content type="html"><![CDATA[<p>Traverse Binary Tree</p><a id="more"></a><h3 id="Traversing-all-nodes-of-Binary-Tree-Linked-List-implementation"><a href="#Traversing-all-nodes-of-Binary-Tree-Linked-List-implementation" class="headerlink" title="Traversing all nodes of Binary Tree(Linked List implementation)"></a>Traversing all nodes of Binary Tree(Linked List implementation)</h3><p><strong>Depth first search</strong></p><ol><li>PreOrder Traversal</li><li>InOrder Traversal</li><li>PostOrder Traversal</li></ol><p><strong>Breadth first search</strong></p><ol><li>LevelOrder Traversal</li></ol><br><h3 id="PreOrder-Traversal-Using-Stack"><a href="#PreOrder-Traversal-Using-Stack" class="headerlink" title="* PreOrder Traversal(Using Stack)"></a>* PreOrder Traversal(Using Stack)</h3><ul><li>Root</li><li>Left Subtree</li><li>Right Subtree</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    print root</span><br><span class="line">    preorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    preorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)  : Recursive call로 많은 노드가 스택에 push, pull 되기 때문에</li></ul><br><h3 id="In-Order-Traversal-Using-Stack"><a href="#In-Order-Traversal-Using-Stack" class="headerlink" title="* In-Order Traversal(Using Stack)"></a>* In-Order Traversal(Using Stack)</h3><ul><li>Left Subtree</li><li>Root</li><li>Right Subtree</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    inorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    print root</span><br><span class="line">    inorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)</li></ul><br><h3 id="Post-Order-Traversal-Using-Stack"><a href="#Post-Order-Traversal-Using-Stack" class="headerlink" title="* Post-Order Traversal(Using Stack)"></a>* Post-Order Traversal(Using Stack)</h3><ul><li>Left Subtree</li><li>Right Subtree</li><li>Root</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    postorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    postorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">    print root</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)</li></ul><br><h3 id="Level-Order-Traversal-Using-Queue"><a href="#Level-Order-Traversal-Using-Queue" class="headerlink" title="* Level-Order Traversal(Using Queue)"></a>* Level-Order Traversal(Using Queue)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">levelOrderTraversal(root)&#123;</span><br><span class="line">  create a Queue(Q)</span><br><span class="line">  enqueue(root)</span><br><span class="line">  while(Queue is not empty)&#123;</span><br><span class="line">    enqueue() the child of the first element</span><br><span class="line">    dequeue() and print</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<p><br><br></p><h3 id="Searching-a-node-Using-Level-order-Traversal"><a href="#Searching-a-node-Using-Level-order-Traversal" class="headerlink" title="* Searching a node(Using Level-order Traversal)"></a>* Searching a node(Using Level-order Traversal)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">searchForGivenValue(value)&#123;</span><br><span class="line">  if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    do a level order traversal</span><br><span class="line">      if value found</span><br><span class="line">        return success message</span><br><span class="line">    return unsuccessful message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<br><h3 id="Insertion-of-node-Using-Level-order-Traversal"><a href="#Insertion-of-node-Using-Level-order-Traversal" class="headerlink" title="* Insertion of node(Using Level-order Traversal)"></a>* Insertion of node(Using Level-order Traversal)</h3><ul><li>Insertion<ul><li>When the root is blank</li><li>Insert at first vacant child</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insertNodeInBinaryTree()&#123;</span><br><span class="line">  if(root is blank)&#123;</span><br><span class="line">    insert new node at root</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    do a level order traversal and find the first blank space</span><br><span class="line">    insert in that blank place</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<br><h3 id="Deletion-of-node-Using-Level-order-Traversal"><a href="#Deletion-of-node-Using-Level-order-Traversal" class="headerlink" title="* Deletion of node(Using Level-order Traversal)"></a>* Deletion of node(Using Level-order Traversal)</h3><ul><li>Insertion<ul><li>When the value to be deleted is not existing in the tree</li><li>When the value to be deleted exists in the tree</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeFromBinaryTree()</span><br><span class="line">  search for the node to be deleted</span><br><span class="line">  find deepest node in the tree(using level order traversal)</span><br><span class="line">  copy deepest node&#39;s data in current node</span><br><span class="line">  delete deepest node</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Traverse Binary Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-binary-tree/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-binary-tree/</id>
    <published>2020-02-06T07:30:25.000Z</published>
    <updated>2020-02-06T14:12:54.625Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree</p><a id="more"></a><p><strong>What is Binary Tree</strong></p><ul><li>A tree is called as binary tree if each node has zero, one or two child.</li><li>It is a family of Data Structure(BST, Heap tree, AVL, Red-Black, Syntax tree, Huffman Coding tree, etc.)</li></ul><p><br><br></p><p><strong>Why should we learn Binary tree</strong></p><ul><li>Prerequisite for more advanced trees</li><li>Is used in solving specific problems like:<ul><li>Huffman Coding</li><li>Heap(Priority Queue)</li><li>Expression parsing</li></ul></li></ul><p><br><Br></p><p><strong>Types of Binary Tree</strong></p><ul><li>Strict Binary Tree : if each node has either 2 children or none.</li><li>Full Binary Tree : if each non leaf node has 2 children and all lead nodes are at same level</li><li>Complete Binary Tree : if all levels are completely filled except possibly the last level and the last level has all keys as left as possible</li></ul><p><br><Br></p><p><strong>Tree Representation</strong></p><ul><li>Using Linked List</li><li>Using Array</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Tree</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-tree/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-tree/</id>
    <published>2020-02-06T06:30:25.000Z</published>
    <updated>2020-02-06T13:59:34.402Z</updated>
    
    <content type="html"><![CDATA[<p>Tree Data Structure</p><a id="more"></a><p><strong>Properties of Tree</strong></p><ul><li>Used to represent data in hierarchical form</li><li>Every Node(ideally) has 2 components(Data &amp; Reference)</li><li>It has a Root node and 2 disjoint binary tree called left subtree and right subtree</li></ul><p><br><br></p><p><strong>Why we learn Tree?</strong></p><ul><li>Linked List is better in space efficiency over Array. However, Linked List does not have that good time efficiency on Insertion, Deletion and Searching which is O(n). </li><li>Tree data structure overcomes the problem of linked list.</li></ul><p><br><br></p><p><strong>Tree Terminologies</strong></p><ul><li>Root : Node with no parent</li><li>Edge : Link from parent to child</li><li>Leaf : Node with no children</li><li>Sibling : Children of same parent</li><li>Ancestor : means parent, grand-parent, great grand parent, and so on for a given node</li><li>Depth of node : Length of the path from root to node</li><li>Height of node : Length of the path from that node to the deepest node</li><li>Height of tree : Same as height of Root node</li><li>Predecessor : Predecessor of a node is the immediate previous node in Inorder traversal of the Binary Tree.</li><li>Successor : Successor of a node is the immediate next node in Inorder traversal of the Binary Tree.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tree Data Structure&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Circular Queue(Array) / Linear Queue(Linked List)</title>
    <link href="http://jbj828.github.io/2020/02/05/Al-CircularQueue/"/>
    <id>http://jbj828.github.io/2020/02/05/Al-CircularQueue/</id>
    <published>2020-02-05T03:30:25.000Z</published>
    <updated>2020-02-06T13:59:57.474Z</updated>
    
    <content type="html"><![CDATA[<p>Queue</p><a id="more"></a><p><strong>Why learn Circular Queue?</strong></p><ul><li>dequeue operation causes blank cells Linear Queue(Array Implementation). </li><li>삭제하고 남은 자리를 뒤에서부터 차례대로 채워넣으면 되지만 time complexity가 O(n)이 되어버린다. 우리의 목표는 항상 O(1)이다.</li></ul><p><br><br></p><p><strong>time / space complexity</strong></p><ul><li>Array는 만들 때 space complexity가 O(n) 나머지 메서드는 모두 O(1)</li><li>Linked List는 모든 메서드 O(1)<br>그러므로 Queue를 사용하고자 한다면 Linked List가 Space Complexity에서 낫기 때문에 Linked List사용하도록 한다</li></ul><p><br><br></p><p><strong>When to Use / Avoid Queue</strong></p><ul><li><p>When to Use</p><ul><li>Helps manage the data in particular way(FIFO)</li><li>Not easily corrupted(No one can easily insert data in middle)<br></li></ul></li><li><p>When to Avoid</p><ul><li>Random access not possible - if we have done some mistake, it is costly to rectify</li></ul></li></ul><p><br><br></p><p><strong>Circular Queue Coding</strong></p><p>CircularQueueByArray.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">public class CircularQueueByArray&#123;</span><br><span class="line"></span><br><span class="line">int[] arr;</span><br><span class="line">int topOfQueue;</span><br><span class="line">int size;</span><br><span class="line">int start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public CircularQueueByArray(int size) &#123;</span><br><span class="line">this.arr &#x3D; new int[size];</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">this.topOfQueue &#x3D; -1;</span><br><span class="line">start &#x3D; -1;</span><br><span class="line">System.out.println(&quot;Successfully created an empty queue of size: &quot;+size);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void enQueue(int value) &#123;</span><br><span class="line">if(arr&#x3D;&#x3D;null) &#123;</span><br><span class="line">System.out.println(&quot;Array is not yet created. Please create one first.&quot;);</span><br><span class="line">&#125;else if (isQueueFull()) &#123;</span><br><span class="line">System.out.println(&quot;\nQueue overflow error!!&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">initializeStartOfArray();</span><br><span class="line">if (topOfQueue+1 &#x3D;&#x3D; size) &#123; &#x2F;&#x2F;if top is already at last cell of array, then reset it to first cell</span><br><span class="line">topOfQueue&#x3D;0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">topOfQueue++;</span><br><span class="line">&#125;</span><br><span class="line">arr[topOfQueue] &#x3D; value;</span><br><span class="line">System.out.println(&quot;\nSuccessfully inserted &quot;+value+&quot; in the queue&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void initializeStartOfArray() &#123;</span><br><span class="line">if (start &#x3D;&#x3D; -1) &#123; </span><br><span class="line">start &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deQueue() &#123;</span><br><span class="line">if (isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Queue underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;\n---------------------------------------------&quot;);</span><br><span class="line">System.out.println(&quot;Before Dequeue..&quot;);printArray();</span><br><span class="line">System.out.println(&quot;\nDequeing value from Queue...&quot;);</span><br><span class="line">System.out.println(&quot;Dequeued: &quot;+arr[start]+&quot; from queue&quot;);</span><br><span class="line">arr[start] &#x3D; 0; &#x2F;&#x2F;initialize the unused cell to 0</span><br><span class="line">if (start &#x3D;&#x3D; topOfQueue) &#123; &#x2F;&#x2F;if there is only 1 element in Queue</span><br><span class="line">start &#x3D; topOfQueue &#x3D; -1;</span><br><span class="line">&#125;else if (start+1 &#x3D;&#x3D; size) &#123; &#x2F;&#x2F;if start has reached end of array, then start again from 0</span><br><span class="line">start&#x3D;0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;After Dequeue..&quot;);printArray();</span><br><span class="line">System.out.println(&quot;---------------------------------------------&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueEmpty() &#123;</span><br><span class="line">if (topOfQueue &#x3D;&#x3D; -1)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueFull() &#123;</span><br><span class="line">if (topOfQueue+1 &#x3D;&#x3D; start) &#123; &#x2F;&#x2F;If we have completed a circle, then we can say that Queue is full</span><br><span class="line">return true;</span><br><span class="line">&#125;else if ((start&#x3D;&#x3D;0) &amp;&amp; (topOfQueue+1 &#x3D;&#x3D; size)) &#123; &#x2F;&#x2F;Trivial case of Queue being full</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void peekOperation() &#123;</span><br><span class="line">&#x2F;&#x2F;if stack is not empty, return the value on top of stack</span><br><span class="line">if (!isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;\nPeeking value from queue...&quot;);</span><br><span class="line">System.out.println(arr[start]); </span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;The queue is empty!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteStack() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting the entire Queue...&quot;);</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Queue is successfully deleted !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Print entire array</span><br><span class="line">public void printArray() &#123;</span><br><span class="line">System.out.println(&quot;Array now...&quot;);</span><br><span class="line">for(int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">System.out.print(arr[i]+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\nStart &#x3D; &quot; + start);</span><br><span class="line">System.out.println(&quot;End &#x3D; &quot;+ topOfQueue);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><p><br><br></p><p>QueueByLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import linkedList.SingleLinkedList;</span><br><span class="line"></span><br><span class="line">public class QueueByLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    SingleLinkedList list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;constructor</span><br><span class="line">    public QueueByLinkedList() &#123;</span><br><span class="line">        list &#x3D; new SingleLinkedList();</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void enQueue(int value) &#123;</span><br><span class="line">        if (list.getHead() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            list.createSingleLinkedList(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; push a value on last of queue, update list tail too</span><br><span class="line">            list.insertInLinkedList(value, list.getSize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int deQueue() &#123;</span><br><span class="line">        int value &#x3D; -1;</span><br><span class="line">        if (isQueueEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;Queue underflow error!!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            value &#x3D; list.getHead().getValue();</span><br><span class="line">            list.deletionOfNode(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        if (!isQueueEmpty())</span><br><span class="line">            return list.getHead().getValue();</span><br><span class="line">        else &#123;</span><br><span class="line">            System.out.println(&quot;The queue is empty!!&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean isQueueEmpty() &#123;</span><br><span class="line">        if (list.getHead() &#x3D;&#x3D; null)</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void deleteStack() &#123;</span><br><span class="line">        list.setHead(null);</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Queue&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Queue</title>
    <link href="http://jbj828.github.io/2020/02/05/Al-Queue/"/>
    <id>http://jbj828.github.io/2020/02/05/Al-Queue/</id>
    <published>2020-02-05T01:30:25.000Z</published>
    <updated>2020-02-06T14:17:15.456Z</updated>
    
    <content type="html"><![CDATA[<p>Queue</p><a id="more"></a><p><strong>What is a Queue?</strong></p><ul><li><p>Property of Queue</p><ul><li>follows FIFO(First In First Out) method</li></ul></li><li><p>Reason why learning</p><ul><li>When we need to create an application which utilizes “first incoming data first”.</li></ul></li></ul><p><br><br></p><p><strong>Implementation options of Queue</strong></p><ul><li>Array<ul><li>Linear Queue</li><li>Circular Queue</li></ul></li></ul><br><ul><li>Linked list<ul><li>Linear Queue</li></ul></li></ul><p><br><br></p><p><strong>Linear Queue by Array</strong><br><br></p><p>QueueByArray.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">public class QueueByArray&#123;</span><br><span class="line"></span><br><span class="line">int[] arr;</span><br><span class="line">int topOfQueue;</span><br><span class="line">int beginningOfQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public QueueByArray(int size) &#123;</span><br><span class="line">this.arr &#x3D; new int[size];</span><br><span class="line">this.topOfQueue &#x3D; -1;</span><br><span class="line">this.beginningOfQueue &#x3D; -1;</span><br><span class="line">System.out.println(&quot;Successfully created an empty queue of size: &quot;+size);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void enQueue(int value) &#123;</span><br><span class="line">if (isQueueFull()) &#123;</span><br><span class="line">System.out.println(&quot;Queue overflow error!!&quot;);</span><br><span class="line">&#125;else if (isQueueEmpty()) &#123; &#x2F;&#x2F;If the queue is empty then we need to initialize beginning index </span><br><span class="line">beginningOfQueue&#x3D;0;</span><br><span class="line">topOfQueue++;</span><br><span class="line">arr[topOfQueue] &#x3D; value;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot;+value+&quot; in the queue&quot;);</span><br><span class="line">&#125;else &#123; &#x2F;&#x2F;if the queue already has some elements in it then no need to initialize beginning index</span><br><span class="line">topOfQueue++;</span><br><span class="line">arr[topOfQueue] &#x3D; value;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot;+value+&quot; in the queue&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printQueue();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void printQueue() &#123;</span><br><span class="line">if(!isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Queue now ...&quot;);</span><br><span class="line">for(int i&#x3D;beginningOfQueue; i&lt;&#x3D;topOfQueue; i++) &#123;</span><br><span class="line">System.out.println(arr[i] + &quot;   &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Queue is empty !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void deQueue() &#123;</span><br><span class="line">if (isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Queue underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Dequeing value from Queue...&quot;);</span><br><span class="line">System.out.println(&quot;Dequeued: &quot;+arr[beginningOfQueue]+&quot; from queue&quot;);</span><br><span class="line">beginningOfQueue++;</span><br><span class="line">if(beginningOfQueue &gt; topOfQueue) &#123; &#x2F;&#x2F;If last element in the Queue is Dequeued</span><br><span class="line">beginningOfQueue &#x3D; topOfQueue &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printQueue();</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueEmpty() &#123;</span><br><span class="line">if ((beginningOfQueue &#x3D;&#x3D; -1) || (beginningOfQueue &#x3D;&#x3D; arr.length))</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueFull() &#123;</span><br><span class="line">if (topOfQueue &#x3D;&#x3D; arr.length-1) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void peekOperation() &#123;</span><br><span class="line">if (!isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(arr[beginningOfQueue]); </span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;The queue is empty!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteQueue() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Queue is successfully deleted !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Queue&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Stack</title>
    <link href="http://jbj828.github.io/2020/02/04/Stack/"/>
    <id>http://jbj828.github.io/2020/02/04/Stack/</id>
    <published>2020-02-04T02:30:25.000Z</published>
    <updated>2020-02-06T13:59:45.266Z</updated>
    
    <content type="html"><![CDATA[<p>Stack data structure</p><a id="more"></a><p><strong>Implementation options of Stack</strong></p><ul><li>Array<ul><li>pros : Easy to implement</li><li>cons : Fixed size</li></ul></li></ul><br><ul><li>Linked List<ul><li>pros : Variable size</li><li>cons : Moderate in implementation</li></ul></li></ul><br><br><p><strong>When to use / avoid Stack</strong><br><br></p><ul><li>When to use<ul><li>Helps manage the data in particular way(LIFO)</li><li>Cannnot be easily corrupted(No one can insert data in middle)<br></li></ul></li><li>When to avoid<ul><li>Random access not possible - if we have done some mistake, its costly to rectify.</li></ul></li></ul><p><br><br></p><p><strong>Stack By Array</strong></p><ul><li>StackByArray.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class StackByArray &#123;</span><br><span class="line"></span><br><span class="line">int[] arr;</span><br><span class="line">int topOfStack;&#x2F;&#x2F;keeps track of the cell which is last occupied in Array, this will help in insertion&#x2F;deletion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public StackByArray(int size) &#123;</span><br><span class="line">this.arr &#x3D; new int[size];</span><br><span class="line">this.topOfStack &#x3D; -1;</span><br><span class="line">System.out.println(&quot;Successfully created an empty Stack of Size: &quot;+size);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void push(int value) &#123;</span><br><span class="line">&#x2F;&#x2F;if array is full, show stack overflow error</span><br><span class="line">if (isFullStack()) &#123;</span><br><span class="line">System.out.println(&quot;Stack overflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">arr[topOfStack+1] &#x3D; value;</span><br><span class="line">topOfStack++;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + value + &quot; in the stack&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void pop() &#123;</span><br><span class="line">&#x2F;&#x2F;if array is empty, show stack underflow error</span><br><span class="line">if (isEmptyStack()) &#123;</span><br><span class="line">System.out.println(&quot;Stack underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Poping value from Stack: &quot; + arr[topOfStack] + &quot;...&quot;);</span><br><span class="line">topOfStack--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isEmptyStack() &#123;</span><br><span class="line">&#x2F;&#x2F;if top pointer is zero, the stack is empty</span><br><span class="line">if (topOfStack &#x3D;&#x3D; -1)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isFullStack() &#123;</span><br><span class="line">if (topOfStack &#x3D;&#x3D; arr.length-1) &#123;</span><br><span class="line">System.out.println(&quot;Stack is full !&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void peekOperation() &#123;</span><br><span class="line">if (!isEmptyStack())</span><br><span class="line">System.out.println(&quot;Top of Stack: &quot; + arr[topOfStack]);</span><br><span class="line">else &#123;</span><br><span class="line">System.out.println(&quot;The stack is empty!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();System.out.println();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteStack() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Stack is successfully deleted&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure></li></ul><p><br><br></p><p><strong>Stack By Linked List</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">import linkedList.SingleLinkedList;</span><br><span class="line"></span><br><span class="line">public class StackByLinkedList &#123;</span><br><span class="line"></span><br><span class="line">SingleLinkedList list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;constructor</span><br><span class="line">public  StackByLinkedList() &#123;</span><br><span class="line">list &#x3D; new SingleLinkedList();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void push(int value) &#123;</span><br><span class="line">if(list.getHead()&#x3D;&#x3D; null) &#123;</span><br><span class="line">list.createSingleLinkedList(value);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">list.insertInLinkedList(value, 0);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Inserted &quot; + value + &quot; in Stack !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int pop() &#123;</span><br><span class="line">int value &#x3D; -1;</span><br><span class="line">if (isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Stack underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">value &#x3D; list.getHead().getValue();</span><br><span class="line">list.deletionOfNode(0);</span><br><span class="line">&#125;</span><br><span class="line">return value;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">if (list.getHead() &#x3D;&#x3D; null)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int peek() &#123;</span><br><span class="line">if (!isEmpty())</span><br><span class="line">return list.getHead().getValue();</span><br><span class="line">else &#123;</span><br><span class="line">System.out.println(&quot;The stack is empty!!&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteStack() &#123;</span><br><span class="line">list.setHead(null);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Stack data structure&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
