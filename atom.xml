<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Developer Javit</title>
  
  <subtitle>Slowly and Steadily</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jbj828.github.io/"/>
  <updated>2020-03-03T15:03:56.127Z</updated>
  <id>http://jbj828.github.io/</id>
  
  <author>
    <name>Jay Chung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Install Docker on AWS EC2 and run the web server through Dockerfile</title>
    <link href="http://jbj828.github.io/2020/03/03/Docker-installDockerOnAWSec2/"/>
    <id>http://jbj828.github.io/2020/03/03/Docker-installDockerOnAWSec2/</id>
    <published>2020-03-03T13:46:25.000Z</published>
    <updated>2020-03-03T15:03:56.127Z</updated>
    
    <content type="html"><![CDATA[<p>Docker Tutorial 2</p><a id="more"></a><p><strong>주피터에 도커 설치하기</strong></p><br><ul><li><code>df -h</code>  : 메모리가 어느정도 남았는지 체크</li><li><code>sudo apt update</code> : 설치는 apt를 이용해서 하기 때문에 먼저 apt 업데이트 명령 수행</li><li><code>sudo apt install apt-transport-https</code>  : 유틸 설치</li><li><code>sudo apt install ca-certificates</code>  : 유틸 설치</li><li><code>sudo apt install curl</code> : 유틸설치, 특정한 웹사이트에서 어떠한 데이터를 다운로드 받을 때 쓰는 것</li><li><code>sudo apt install software-properties-common</code></li></ul><br><ul><li><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code>  : curl을 이용해서 실제로 도커를 설치하기 위해 gpg내용을 다운로드 받고 그 내용을 apt기능을 위한 리스트에 추가할 수 있도록 함.</li></ul><br><ul><li><code>sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;</code>  : 도커는 레포지터리에서 다운로드 가능, 우분투 18.04버전에 맞는 도커를 다운로드 해야함.</li><li><code>sudo apt update</code></li></ul><p><strong>이것으로 apt-list에 docker를 다운로드 받기 위한 경로가 추가되었다</strong></p><br><p><strong>이제 실제로 도커를 다운로드 받는다</strong></p><ul><li><code>apt-cache policy docker-ce</code></li><li><code>sudo apt install docker-ce</code>  : 도커는 설치하게 되면 시스템 서비스로 등록되기 때문에 언제 어디서든 이용가능</li></ul><br><ul><li><code>sudo systemctl status docker</code>  : 도커 서비스 상태 확인</li><li><code>q</code> : 눌러서 원래로 돌아옴</li><li><code>docker pull hello-world</code>  : docker의 <em>pull</em> 명령은 특정한 서버파일 자체를 이미지 형태로 다운로드 받을 수 있게 해줌</li><li><code>docker images</code> : 이미지 확인</li></ul><br><p><strong>다운로드 받은 이미지를 실제 컨테이너로 만들기</strong></p><ul><li><code>docker run hello-world</code>  : hello-world 컨테이너를 띄움. 즉 이 명령을 내리자마자 우리의 서버 위에 하나의 서버가 별도로 더 생성되어 서버가 동작하고 작업이 종료된 것.</li><li><code>docker ps -a</code> : 어떤 컨테이너가 동작했는지 확인가능</li></ul><br><p><strong>컨테이너 삭제</strong></p><ul><li><code>docker rm 컨테이너아이디</code>  : docker ps -a로 아이디 확인 가능</li><li><code>docker images</code> : 삭제를 하더라도 이미지 파일은 남아있음</li></ul><br><h3 id="Docker-파일을-직접-작성해서-하나의-서버-이미지를-직접-만들기"><a href="#Docker-파일을-직접-작성해서-하나의-서버-이미지를-직접-만들기" class="headerlink" title="Docker 파일을 직접 작성해서 하나의 서버 이미지를 직접 만들기"></a>Docker 파일을 직접 작성해서 하나의 서버 이미지를 직접 만들기</h3><ul><li><code>ls</code>  : 현재 디렉토리의 파일에 대한 리스트를 보여줌</li><li><code>cd /home/ubuntu</code></li><li><code>ls</code></li><li><code>mkdir example</code></li><li><code>cd example</code></li><li><code>ls</code></li><li><code>sudo vi Dockerfile</code></li></ul><br><p><strong>도커파일 작성</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">MAINTAINER ByungJae Chung &lt;jbj828@naver.com&gt;</span><br><span class="line"></span><br><span class="line">RUN apt-get update &#x2F;&#x2F;해당 서버가 웹 서버를 구동할 수 있도록 설정</span><br><span class="line">RUN apt-get install -y apache2 # Install Apache web server (Only &#39;yes&#39;) &#x2F;&#x2F; y옵션 넣는 이유는 설치할 때 용량 크면 설치 할 것인지 물어본다. docker이미지 만들 때는 행동예측이 어렵기에 무조건 설치한다는 뜻</span><br><span class="line"></span><br><span class="line">EXPOSE 80 # Open HTTP Port  &#x2F;&#x2F; 아파치 웹서버의 기본 포트인 80번 포트를 열 수 있도록 만들어준 것</span><br><span class="line"></span><br><span class="line">CMD [&quot;apachectl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;] &#x2F;&#x2F;특정한 컨테이너는 작업 수행하자마자 바로 종료되기 때문에 아파치가 항상 구동중인 상태로 만들기 위해 명시</span><br></pre></td></tr></table></figure><p><code>:wq!</code></p><br><p><strong>Build Docker File</strong></p><p>도커 이미지를 만드는 것</p><ul><li><code>ls</code></li><li><code>docker build -t example .</code></li><li><code>docker images</code> : 확인<ul><li>만약 error가 났다면 error message 보고 docker file 들어가서 수정하고 다시 build하기</li></ul></li></ul><br><p><strong>만든 이미지를 활용해 실제 웹서버 컨테이너 구동</strong></p><ul><li><code>docker run -p 80:80 example</code> : 왼쪽은 현재 우리 서버의 포트를 넣고 오른쪽엔 컨테이너의 포트 넣기 - 호스트의 80번 포트와 컨테이너의 80번 포트가 연결됨, 실제로 호스트 서버의 80번 포트에 접속했을 때 사용자는 컨테이너의 80번 포트에 접속할 수 있게 됨</li></ul><Br><ul><li>이후 AWS -&gt; 보안그룹/launch-wizard-1 -&gt; 편집 -&gt;<br>규칙추가 -&gt; 유형:HTTP</li><li>서버의 80번 포트로 검색해봄 (주소창에서 주소명만 복사해서 <code>:80</code> 붙임) </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker Tutorial 2&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://jbj828.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://jbj828.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Install AWS EC2 Instance and Jupyter Notebook(환경설정)</title>
    <link href="http://jbj828.github.io/2020/03/03/Docker-tutorial1/"/>
    <id>http://jbj828.github.io/2020/03/03/Docker-tutorial1/</id>
    <published>2020-03-03T05:46:25.000Z</published>
    <updated>2020-03-03T11:16:29.138Z</updated>
    
    <content type="html"><![CDATA[<p>Docker Tutorial 1</p><a id="more"></a><h3 id="AWS-EC2-인스턴스-생성-및-접속"><a href="#AWS-EC2-인스턴스-생성-및-접속" class="headerlink" title="AWS EC2 인스턴스 생성 및 접속"></a>AWS EC2 인스턴스 생성 및 접속</h3><Br><ol><li>AWS에서 ubuntu 18버전으로 먼저 인스턴스 생성</li><li>key pair는 관리자만 실행가능하도록 환경설정<ul><li>오른쪽마우스 -&gt; 속성 -&gt; 보안 -&gt; 고급 -&gt; 상속사용</li><li>key pair는 무조건 C드라이브 안에 넣기</li></ul></li><li>명령프롬프트 관리자 권한으로 실행<ul><li>cd 키페어 위치</li><li>aws 홈페이지 가서 연결버튼 누름</li><li>ssh 링크 복사해서 cmd에 복사</li><li>연결완료 되면 pwd 입력 -&gt; <code>현재 서버위치</code></li></ul></li></ol><br><h3 id="Jupyter-Notebook-설치-HTTPS-적용-시스템-서비스-설정하기"><a href="#Jupyter-Notebook-설치-HTTPS-적용-시스템-서비스-설정하기" class="headerlink" title="Jupyter Notebook 설치, HTTPS 적용, 시스템 서비스 설정하기"></a>Jupyter Notebook 설치, HTTPS 적용, 시스템 서비스 설정하기</h3><br><ul><li><p><strong>Jypyter Notebook</strong> : 콘솔창이 아닌 웹브라우저 환경에서 해당 서버에 바로 접근해서 해당 서버를 관리할 수 있도록 해주는 유틸</p><ol><li>sudo apt-get update  :  apt-get명령의 업데이트</li><li>sudo apt-get install python3-pip<ul><li>ubuntu 18.04버전엔 pyhton3가 디폴트로 깔려있다. 그래서 python3는 깔 필요없고 파이썬 관련 패키지를 설치할 수 있도록 도와주는 python3-pip를 설치</li></ul></li><li>sudo pip3 install notebook  : jupyter notebook 설치</li></ol><br><p>만들어진 주피터를 통해서 서버의 외부에서 해당 서버에 웹브라우저를 이용해서 접속할 수 있도록 된 것. 이제 주피터 접속을 위한 비밀번호 설정을 해줘야 함.</p>  <br><ol><li>python3</li><li>from notebook.auth import passwd</li><li>passwd()   :  패스워드 함수 호출(비밀번호를 설정하겠다는 의미)</li><li>나온 hash값 복사해서 메모장 붙여넣기</li><li>exit()</li></ol><br><p>서버에서 주피터 노트북을 실행해서 외부에서 접속 했을 때 비밀번호를 입력해야 서버에 접속할 수 있도록 하기 위해 주피터 환경설정 진행</p><br><ol><li>jupyter notebook –generate-config    : 환경설정 파일 만듦</li><li>sudo vi 바로 윗줄 환경설정 위치값 붙여넣기<ul><li>ex)  sudo vi /home/ubuntu/.jupyter/jupyter_notebook_config.py         </li></ul></li><li>제일 밑으로 내려가서 ‘a’눌러서 수정모드로 변환</li><li>c = get_config()</li><li>c.NotebookApp.password = u’sha1 : 복사해둔 해시값’</li><li>c.NotebookApp.ip = ‘172.31.14.123’    이거는 화면 제목 창에 나온 주소 그대로 적으면 됨</li><li>c.NotebookApp.notebook_dir = ‘/‘</li><li>esc버튼 누르고</li><li>:wq!</li></ol><br><ol><li>sudo jupyter-notebook –allow-root   : 주피터 노트북을 루트권한을 가진 상태로 실행<ul><li>8888포트로 주피터 노트북이 열린 것 확인가능</li></ul></li></ol><br><ol><li>AWS 웹사이트 다시 돌아가서 </li><li>‘설명’란 안에 있는</li><li>‘보안그룹’ 의 ‘launch-wizard-1’ 클릭</li><li>‘인바운드’</li><li>‘편집’</li><li>‘규칙추가’</li><li>포트범위 : 8888</li><li>소스 : 0.0.0.0/0  (두 개 다)</li></ol><br><ol><li>인스턴스 화면으로 돌아옴</li><li>‘설명’란에 ‘IPv4 퍼블릭 IP’에 있는 주소 복사</li><li>주소창에 붙이고 ‘:8888’ 붙여서 엔터</li></ol><br><ul><li>더 이상 ssh가 필요하지 않고 바로 웹 브라우저에서 해당 서버에 접속할 수 있어서 매우 편리해졌다. 하지만 우린 주피터를 항상 실행할 수 있는 상태로 만들고 싶다</li></ul></li></ul><br><ol><li>다시 cmd로 돌아와서 ‘ctrl+z’로 해당 서버 종료 </li><li>bg   : background상태에서 돌아가게 함</li><li>disown -h   : 소유권 포기<ul><li>이제 주피터 노트북이 항상 실행 중인 상태가 됨<br></li></ul></li></ol><p>언제 어디서나 웹브라우저로 서버를 관리할 수 있게 됨<br>하지만 지금의 주피터 노트북은 ssl인증서가 적용되지 않은 상태라서 통신과정에서 상당히 위험.<br><br></p><p>그러므로 https를 적용해야됨</p><br><ol><li>sudo netstat -nap | grep 8888  : 현재 8888포트가 실행 중인 피아이디를 알 수 있다</li><li>sudo kill -9 ‘파이썬 옆 숫자’<ul><li>해당 주피터 노트북을 종료시킬 수 있음</li><li>웹브라우저에서 새로고침하면 적용 안 됨</li></ul></li></ol><br><h3 id="HTTPS-적용"><a href="#HTTPS-적용" class="headerlink" title="HTTPS 적용"></a>HTTPS 적용</h3><br><p><em>환경설정에 개인키와 공개키를 넣는 작업</em></p><br><ol><li>cd /home/ubuntu</li><li>pwd</li><li>mkdir ssl</li><li>cd ssl</li><li>sudo openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout “cert.key” -out “cert.pem” -batch     <em>개인키 공개키 생성</em></li><li>ls</li><li>sudo vi 바로 윗줄 환경설정 다시 열기<br>ex)  sudo vi /home/ubuntu/.jupyter/jupyter_notebook_config.py<br><em>방향키 위쪽 버튼 눌러서 찾기</em></li><li>‘a’눌러서 시작</li><li>c.NotebookApp.certfile = u’/home/ubuntu/ssl/cert.pem’</li><li>c.Notebop.keyfile = u’/home/ubuntu/ssl/cert.key’</li><li>esc버튼</li><li>:wq!</li></ol><Br><ol><li><p>sudo jupyter-notebook –allow-root   <em>주피터 노트북 실행</em></p><ul><li>https://주소:8888 넣으면 ssl이 적용이 된 상태로 서버에 접속가능</li><li>여기까지가 우리 주피터 노트북에 ssl(인증서)까지 적용한 것</li></ul></li></ol><br><h3 id="시스템-서비스-설정하기"><a href="#시스템-서비스-설정하기" class="headerlink" title="시스템 서비스 설정하기"></a>시스템 서비스 설정하기</h3><ul><li>서버가 재부팅되면 자동으로 주피터 노트북이 실행이 안됨. 그래서 주피터 노트북을 시스템 서비스로서 등록시켜서 재부팅해도 자동실행 가능하도록 함.</li></ul><br><ol><li><p>먼저 ctrl+c 눌러서 서버 구동 종료</p></li><li><p>which jupyter-notebook    <em>주피터 노트북 실행파일의 경로를 찾기 위한 명령</em></p></li><li><p>sudo vi /etc/systemd/system/jupyter.service    <em>시스템 서비스로 등록하기 위해 서비스 파일 작성</em></p></li><li><p><em>서비스 파일 작성</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Jupyter Notebook Server</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">User&#x3D;ubuntu  &#x2F;&#x2F;기본적으로 AWS ec2에 ssh명령을 이용해서 접속할 땐 ubuntu계정으로 접속하기 때문</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;sudo &#x2F;usr&#x2F;local&#x2F;bin&#x2F;jupyter-notebook --allow-root --config&#x3D;&#x2F;home&#x2F;ubuntu&#x2F;.jupyter&#x2F;jupyter_notebook_config.py</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>:wq!입력</p><br></li></ol><p>  <em>주피터 노트북을 구동시키도록 함</em></p><ol><li>sudo systemctl daemon-reload <em>데몬을 다시 로드할수 있도록</em></li><li>sudo systemctl enable jupyter <em>주피터서비스를 사용가능하도록 만듦</em> </li><li>sudo systemctl start jupyter  <em>항상 실행상태가 되도록 만듦</em></li></ol><br><ul><li><p>실행 중인 주피터 서비스를 확인</p><ol><li>sudo systemctl status jupyter</li><li>확인 후 ‘q’눌러서 상태확인 마침</li></ol><br></li><li><p>주피터 서비스를 다시 시작하고자 할 때</p><ol><li>sudo systemctl restart jupyter</li></ol></li></ul><br><p>이제 aws ec2를 재부팅하더라도 주피터 노트북 서비스가 자동으로 실행되어서 구동중인 상태가 될 수 있도록 처리한 것. 항상 주피터를 이용해서 해당 서버에 접속해 관리할 수 있도록 된 것.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker Tutorial 1&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://jbj828.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://jbj828.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>What is Docker?</title>
    <link href="http://jbj828.github.io/2020/03/03/Docker-theory/"/>
    <id>http://jbj828.github.io/2020/03/03/Docker-theory/</id>
    <published>2020-03-03T01:46:25.000Z</published>
    <updated>2020-03-02T16:47:18.314Z</updated>
    
    <content type="html"><![CDATA[<p>Primary theory of Docker</p><a id="more"></a><p>출처 : 공부목적으로 <a href="https://subicura.com/" target="_blank" rel="noopener">Subicura’s Blog</a>를 참조했습니다.</p><br><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li>컨테이너를 관리하는 플랫폼</li><li>컨테이너 기반의 오픈소스 가상화 플랫폼<ul><li>다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해줍니다. 백엔드 프로그램, 데이터베이스 서버, 메시지 큐등 어떤 프로그램도 컨테이너로 추상화할 수 있고 조립PC, AWS, Azure, Google cloud등 어디에서든 실행할 수 있습니다.</li><li>즉, 컨테이너는 격리된 공간에서 프로세스가 동작하는 기술입니다.</li></ul></li></ul><p><strong>Difference between VM and Docker</strong></p><br><img src="/2020/03/03/Docker-theory/docker1.png" class="" width="500" height="300" title="VM and Docker"><br><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>  ‘컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것’</p><ul><li>이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것으로 상태값을 가지지 않고 변하지 않습니다(Immutable). 컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됩니다. 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있습니다.</li><li>말그대로 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 더 이상 의존성 파일을 컴파일하고 이것저것 설치할 필요가 없습니다. 이제 새로운 서버가 추가되면 미리 만들어 놓은 이미지를 다운받고 컨테이너를 생성만 하면 됩니다. 한 서버에 여러개의 컨테이너를 실행할 수 있고, 수십, 수백, 수천대의 서버도 문제없습니다.</li><li>도커 이미지는 Docker hub에 등록하거나 Docker Registry 저장소를 직접 만들어 관리할 수 있습니다. 현재 공개된 도커 이미지는 50만개가 넘고 Docker hub의 이미지 다운로드 수는 80억회에 이릅니다. 누구나 쉽게 이미지를 만들고 배포할 수 있습니다.</li></ul><br><img src="/2020/03/03/Docker-theory/docker2.png" class="" width="500" height="300" title="Docker Image">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Primary theory of Docker&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://jbj828.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://jbj828.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Regular Expression</title>
    <link href="http://jbj828.github.io/2020/02/23/RegularExpression/"/>
    <id>http://jbj828.github.io/2020/02/23/RegularExpression/</id>
    <published>2020-02-23T06:46:25.000Z</published>
    <updated>2020-02-23T06:18:30.544Z</updated>
    
    <content type="html"><![CDATA[<p>regular expression</p><a id="more"></a><h3 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h3><ul><li>정규표현식(正規表現式, Regular Expression)은 문자열을 처리하는 방법 중의 하나로 특정한 조건의 문자를 ‘검색’하거나 ‘치환’하는 과정을 매우 간편하게 처리 할 수 있도록 하는 수단이다.</li></ul><br><p><strong>정규표현식의 특징</strong></p><ul><li>Case sensitive(대소문자 구분)<br>  <code>options : &quot;i&quot;</code> 하면 대소문자 구분 없이 검색 가능</li></ul><br><p><strong>정규표현식의 패턴</strong></p><ul><li>^ : Character ^ matches the beginning of the line.</li><li>$ : Dollar sign matches the end of the line</li><li>\ : Escaping the pattern to the normal text.<ul><li><code>\$</code> : this means normal text of “$”</li></ul></li><li>. : Point . mathces any character   </li><li>[] : Insid square brackets “[]” a list of characters can be provided. The expression matches if any of these characters is found. The order of character is insignificant.</li><li>[x-y] : A range of characters can be specified with [-] syntax. ex) [c-k] : c부터 k까지 모두 선택</li><li>[^ ] : If a character class starts with ^, then specified characters will not be selected.</li></ul><p><strong>서브 패턴</strong></p><ul><li>(on|ues|rida) : Alternating text can be enclosed in parentheses and alternatives separated with |</li></ul><br>출처 : 생활코딩]]></content>
    
    <summary type="html">
    
      &lt;p&gt;regular expression&lt;/p&gt;
    
    </summary>
    
    
      <category term="Language" scheme="http://jbj828.github.io/categories/Language/"/>
    
    
      <category term="language" scheme="http://jbj828.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>How to write ReadMe?</title>
    <link href="http://jbj828.github.io/2020/02/22/WritingReadMe/"/>
    <id>http://jbj828.github.io/2020/02/22/WritingReadMe/</id>
    <published>2020-02-22T04:30:25.000Z</published>
    <updated>2020-02-22T03:43:18.193Z</updated>
    
    <content type="html"><![CDATA[<p>Information about writing ReadME documentation.</p><a id="more"></a><h3 id="Anatomy-of-a-README"><a href="#Anatomy-of-a-README" class="headerlink" title="Anatomy of a README"></a>Anatomy of a README</h3><ol><li>What <strong>steps</strong> need to be taken?</li><li>What should the user already have <strong>installed</strong> or <strong>configured</strong>?</li><li>What might they have a hard time understading <strong>right away</strong>?</li></ol><br><h3 id="Basic-Structure"><a href="#Basic-Structure" class="headerlink" title="Basic Structure"></a>Basic Structure</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 프로젝트 제목</span><br><span class="line">프로젝트 설명 (with 프로젝트 Logo)</span><br><span class="line"></span><br><span class="line">## 설치 방법 (Installation)</span><br><span class="line">설치 방법 설명 (with 예시코드)</span><br><span class="line"></span><br><span class="line">## 사용 방법 (Usage)</span><br><span class="line">사용 방법 설명 (with 예시코드)</span><br></pre></td></tr></table></figure><ul><li>If it is Open Source Project<br></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 기여 방법 (Contributing)</span><br><span class="line">기여 방법 설명</span><br><span class="line"></span><br><span class="line">## 라이센스 (License)</span><br><span class="line">해당하는 License (choosealicense.com 참고)</span><br></pre></td></tr></table></figure><ul><li>Big project</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 버그들 (Known Bugs)</span><br><span class="line">## FAQ (Frequently Asked Qustions)</span><br><span class="line">## ToC (Table of Contents)</span><br></pre></td></tr></table></figure><p><Br><Br></p><p>ref : “Udacity - Writing READMEs”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Information about writing ReadME documentation.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Github" scheme="http://jbj828.github.io/categories/Github/"/>
    
    
      <category term="github" scheme="http://jbj828.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hashing - Direct Chaining Coding</title>
    <link href="http://jbj828.github.io/2020/02/19/Al-HashingDirectChaining/"/>
    <id>http://jbj828.github.io/2020/02/19/Al-HashingDirectChaining/</id>
    <published>2020-02-19T06:30:25.000Z</published>
    <updated>2020-02-23T05:42:56.281Z</updated>
    
    <content type="html"><![CDATA[<p>Direct Chaning Coding by Hashing </p><a id="more"></a><Br><p>DirectChaining.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class DirectChaining &#123;</span><br><span class="line">LinkedList&lt;String&gt;[] hashTable;</span><br><span class="line">int maximumChainSize &#x3D; 5;</span><br><span class="line"></span><br><span class="line">DirectChaining() &#123;</span><br><span class="line">hashTable &#x3D; new LinkedList[13];</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; HashFunction to be used on Keys</span><br><span class="line">public int simpleASCIIHashFunction(String x, int M) &#123;</span><br><span class="line">char ch[];</span><br><span class="line">ch &#x3D; x.toCharArray();</span><br><span class="line">int i, sum;</span><br><span class="line">for (sum &#x3D; 0, i &#x3D; 0; i &lt; x.length(); i++) &#123;</span><br><span class="line">sum &#x3D; sum + ch[i];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; System.out.println(&quot;Index from hashfunction: &quot; + sum % M);</span><br><span class="line">return sum % M;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Insert Key in HashTable</span><br><span class="line">public void insertKeyInHashTable(String value) &#123;</span><br><span class="line">int newIndex &#x3D; simpleASCIIHashFunction(value, hashTable.length); &#x2F;&#x2F;returns in which index we need to store this string</span><br><span class="line">if(hashTable[newIndex] &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;Index: &quot; + newIndex + &quot; is empty. Creating a new LinkedList there...&quot;);</span><br><span class="line">hashTable[newIndex] &#x3D; new LinkedList&lt;String&gt;(); </span><br><span class="line">hashTable[newIndex].add(value);</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + &quot;\&quot;&quot; + value + &quot;\&quot;&quot; + &quot; in location: &quot; + newIndex);</span><br><span class="line">System.out.println(&quot;-------------------------------------------\n&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\nIndex: &quot; + newIndex + &quot; is having sufficient space. Inserting there...&quot;);</span><br><span class="line">hashTable[newIndex].add(value);</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + &quot;\&quot;&quot; + value + &quot;\&quot;&quot; + &quot; in location: &quot; + newIndex);</span><br><span class="line">System.out.println(&quot;-------------------------------------------\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Search for a given key in hashTable</span><br><span class="line">public boolean searchKeyInHashTable(String stringToBeSearched) &#123;</span><br><span class="line">int newIndex &#x3D; simpleASCIIHashFunction(stringToBeSearched, hashTable.length);</span><br><span class="line">if (hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].contains(stringToBeSearched)) &#123;</span><br><span class="line">System.out.println(&quot;\n&quot; + &quot;\&quot;&quot; + stringToBeSearched + &quot;\&quot;&quot; + &quot; found in HashTable at location: &quot;+newIndex);</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\n&quot; + &quot;\&quot;&quot; + stringToBeSearched + &quot;\&quot;&quot; + &quot; not found in HashTable.&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete key from HashTable</span><br><span class="line">public void deleteKeyFromHashTable(String stringToBeDeleted) &#123;</span><br><span class="line">int newIndex &#x3D; simpleASCIIHashFunction(stringToBeDeleted, hashTable.length);</span><br><span class="line">if (hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].contains(stringToBeDeleted)) &#123;</span><br><span class="line">System.out.println(&quot;\n&quot; + &quot;\&quot;&quot; + stringToBeDeleted + &quot;\&quot;&quot; + &quot; has been found in HashTable.&quot; );</span><br><span class="line">hashTable[newIndex].remove(stringToBeDeleted);</span><br><span class="line">System.out.println(&quot;\&quot;&quot; + stringToBeDeleted + &quot;\&quot;&quot; + &quot; has been deleted from HashTable !&quot; );</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\nCould not find &quot; + &quot;\&quot;&quot; + stringToBeDeleted + &quot;\&quot;&quot; + &quot; in HashTable&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; display the hash table</span><br><span class="line">public void displayHashTable() &#123;</span><br><span class="line">if(hashTable &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;\nHashTable does not exits !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\n---------- HashTable ---------&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; hashTable.length; i++) &#123;</span><br><span class="line">System.out.println(&quot;Index: &quot; + i + &quot;, key: &quot; + hashTable[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; &#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deletes entire HashTable</span><br><span class="line">public void deleteHashTable() &#123;</span><br><span class="line">hashTable &#x3D; null;</span><br><span class="line">System.out.println(&quot;Successfully deleted HashTable !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><br><p>Main.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class DirectChainingMain &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Constructor</span><br><span class="line">DirectChaining directChaining &#x3D; new DirectChaining();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;The&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;quick&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;brown&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;over&quot;);</span><br><span class="line">directChaining.insertKeyInHashTable(&quot;lazy&quot;);</span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;); &#x2F;&#x2F; use for showing collision</span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">directChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line">directChaining.displayHashTable();</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * DirectChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.insertKeyInHashTable(&quot;fox&quot;); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.searchKeyInHashTable(&quot;jump&quot;);</span><br><span class="line"> * DirectChaining.searchKeyInHashTable(&quot;brown&quot;);</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.deleteKeyFromHashTable(&quot;jump&quot;);</span><br><span class="line"> * DirectChaining.deleteKeyFromHashTable(&quot;quick&quot;);</span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * DirectChaining.deleteHashTable(); </span><br><span class="line"> * DirectChaining.displayHashTable();</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure><br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Direct Chaning Coding by Hashing &lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hashing</title>
    <link href="http://jbj828.github.io/2020/02/18/Al-hasing/"/>
    <id>http://jbj828.github.io/2020/02/18/Al-hasing/</id>
    <published>2020-02-18T14:30:25.000Z</published>
    <updated>2020-02-19T00:59:23.048Z</updated>
    
    <content type="html"><![CDATA[<p>Hashing</p><a id="more"></a><br><p><strong>What is Hashing</strong></p><ul><li>Hashing is a method of sorting and indexing data. The idea behind hasing is to allow large amounts of data to be indexed using keys commonly created by formulas.</li><li>해시함수란 데이터의 효율적 관리를 목적으로 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 매핑 전 원래 데이터의 값을 키(key), 매핑 후 데이터의 값을 해시값(hash value), 매핑하는 과정 자체를 해싱(hashing) 이라고 한다.</li></ul><p><strong>Why we need Hashing</strong></p><ul><li>Time efficient<img src="/2020/02/18/Al-hasing/hasing1.png" class="" width="400" height="200" title="hashing time complexity"></li></ul><br><p><strong>Terminologies</strong></p><ul><li><p>Hash Function : A hash function is any function that can be used to map data of arbitrary size to data of fixed size.</p></li><li><p>Key : Input data given by user</p></li><li><p>Hash Value : The values returned by a hash function are called hash values, hash codes, digests, or simply hashes.</p></li><li><p>Hash Tables : It is a data structure which implements an associative array abstract data type, a structure that can map keys to values.</p></li><li><p>Collision : A collision occurs when two different key to a hash function produce the same output called hash values.</p><img src="/2020/02/18/Al-hasing/hashing2.png" class="" width="600" height="500" title="hashing structure"></li></ul><br><p><strong>Characteristics of good Hash function</strong></p><ul><li>It distributes hash values uniformly across the hash table.</li><li>The hash function uses all the input data.</li></ul><br><h4 id="Collision-Resolution-Techniques"><a href="#Collision-Resolution-Techniques" class="headerlink" title="Collision Resolution Techniques"></a>Collision Resolution Techniques</h4><img src="/2020/02/18/Al-hasing/hashing3.png" class="" width="400" height="300" title="hashing structure"><br><ul><li><p>Direct Chaining </p><ul><li>Implements the buckets as linked lists. Colliding elements are stored in these lists.<img src="/2020/02/18/Al-hasing/hashing4.png" class="" width="400" height="300" title="Direct Chaining"><br></li></ul></li><li><p>Open Addressing</p><ul><li>Colliding elements are stored in other vacant buckets. During storage and lookup, there are found through so called “probing”<br></li></ul><ul><li><p>Linear Probing :</p><ul><li>Linear probing is a strategy for resolving collisions by replacing the new key into the closest following empty cell.<img src="/2020/02/18/Al-hasing/hashing5.png" class="" width="400" height="300" title="Linear Probing"><br></li></ul></li><li><p>Quadratic Probing : </p><ul><li>Qudratic probing operates by taking the original hash index and adding successive values of an arbitrary quadratic polynomial until an open slot is found.<img src="/2020/02/18/Al-hasing/hashing6.png" class="" width="400" height="300" title="Quadratic Probing"><br></li></ul></li><li><p>Double Hashing :</p><ul><li>Interval between probes is computed by another hash function.<img src="/2020/02/18/Al-hasing/hashing7.png" class="" width="400" height="300" title="Double Hashing"></li></ul></li></ul></li></ul><br><p><strong>What happens when Hash Table is full?</strong></p><ul><li><p>Direct Chaining </p><ul><li>This situation will never arise.</li></ul></li><li><p>Open Addressing</p><ul><li>Need to create 2x size of current table and redo Hashing for existing keys.<img src="/2020/02/18/Al-hasing/hashing8.png" class="" width="400" height="300" title="resizeHashTable"></li></ul></li></ul><br><p><strong>Pros &amp; Cons of Collision Resolution Technique</strong></p><ul><li><p>Direct Chaining</p><ul><li>No fear of exhausting Hash Table buckets.</li><li>Fear of big Linked Lists(can effect performance big time).</li></ul></li><li><p>Open Addressing</p><ul><li>Easy implementation</li><li>Fear of exhasuting Hash Table buckets.</li></ul></li></ul><ol><li><p>If input size is known then always use “Open Addressing”, else can use any of the two.</p></li><li><p>If Deletion is very high, then we should always go for ‘Direct Chaining’. Because when we delet a lot on ‘Open Addressing’, there’s gonna have lots of Hole and it will make problem. We can do “restruction”, but it’s not that efficient way.</p></li></ol><br><p><strong>Practical Use of Hashing</strong></p><ul><li>Password Verification</li><li>File System : File path is mapped to physical location on disk.</li></ul><br><p><strong>Pros &amp; Cons of Hashing</strong></p><ul><li><p>Pros</p><ul><li>On an average Insertion/Deletion/Search operation takes O(1) time.</li></ul></li><li><p>Cons</p><ul><li>In the worst case Insertion/Deletion/Search might take O(n) time(when hash function is not good enough)</li></ul></li></ul><br>출처 : "Data Structures & Algorithms" by DS GUY]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hashing&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Trie Coding</title>
    <link href="http://jbj828.github.io/2020/02/18/Al-Trie-Coding/"/>
    <id>http://jbj828.github.io/2020/02/18/Al-Trie-Coding/</id>
    <published>2020-02-18T07:30:25.000Z</published>
    <updated>2020-02-18T09:14:30.541Z</updated>
    
    <content type="html"><![CDATA[<p>Trie coding</p><a id="more"></a><br><p>Trie.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">package trie;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Trie &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Private class</span><br><span class="line">private class TrieNode &#123;</span><br><span class="line">Map&lt;Character, TrieNode&gt; children;</span><br><span class="line">boolean endOfWord;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Constructor</span><br><span class="line">public TrieNode() &#123;</span><br><span class="line">children &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">endOfWord &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; End of inner class</span><br><span class="line"></span><br><span class="line">private final TrieNode root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Constructor</span><br><span class="line">public Trie() &#123;</span><br><span class="line">root &#x3D; new TrieNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Insert word into Trie</span><br><span class="line">public void insert(String word) &#123;</span><br><span class="line">TrieNode current &#x3D; root;</span><br><span class="line">for (int i &#x3D; 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">char ch &#x3D; word.charAt(i);</span><br><span class="line">TrieNode node &#x3D; current.children.get(ch);</span><br><span class="line">if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">node &#x3D; new TrieNode();</span><br><span class="line">current.children.put(ch, node);</span><br><span class="line">&#125;</span><br><span class="line">current &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line">current.endOfWord &#x3D; true;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + word + &quot; in Trie !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Search for a word in Trie</span><br><span class="line">public boolean search(String word) &#123;</span><br><span class="line">TrieNode currentNode &#x3D; root;</span><br><span class="line">for (int i &#x3D; 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">char ch &#x3D; word.charAt(i);</span><br><span class="line">TrieNode node &#x3D; currentNode.children.get(ch); </span><br><span class="line">if (node &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;CASE#1 -- if node does not exist for given char then return false</span><br><span class="line">System.out.println(&quot;Word: &quot; + word + &quot; does not exists in Trie !&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">currentNode &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line">if(currentNode.endOfWord &#x3D;&#x3D; true) &#123;</span><br><span class="line">System.out.println(&quot;Word: &quot; + word + &quot; exists in Trie !&quot;); &#x2F;&#x2F;CASE#2 -- Word exists in Trie</span><br><span class="line">&#125;else &#123;&#x2F;&#x2F;CASE#3 -- Current word is a prefix of another word. But this word does not exists</span><br><span class="line">System.out.println(&quot;Word: &quot; + word + &quot; does not exists in Trie ! But this is a Prefix of another Word !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return currentNode.endOfWord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Delete word from Trie</span><br><span class="line">public void delete(String word) &#123;</span><br><span class="line">if (search(word) &#x3D;&#x3D; true) &#123;</span><br><span class="line">delete(root, word, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Returns true if parent should delete the mapping</span><br><span class="line">private boolean delete(TrieNode parentNode, String word, int index) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; CASE#1 -- Some other word&#39;s prefix is same as Prefix of this word (BCDE, BCKG)</span><br><span class="line">&#x2F;&#x2F; CASE#2 -- We are at last character of this word and This word is a Prefix of some other word (BCDE, BCDEFG)</span><br><span class="line">&#x2F;&#x2F; CASE#3 -- Some other word is a Prefix of this word (BCDE, BC)</span><br><span class="line">&#x2F;&#x2F; CASE#4 -- No one is dependent on this Word (BCDE, BCDE)</span><br><span class="line"></span><br><span class="line">char ch &#x3D; word.charAt(index);</span><br><span class="line">TrieNode currentNode &#x3D; parentNode.children.get(ch);</span><br><span class="line"></span><br><span class="line">boolean canThisNodeBeDeleted;</span><br><span class="line"></span><br><span class="line">if (currentNode.children.size() &gt; 1) &#123;</span><br><span class="line">System.out.println(&quot;Entering Case#1&quot;);</span><br><span class="line">delete(currentNode, word, index + 1); &#x2F;&#x2F; CASE#1</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (index &#x3D;&#x3D; word.length() - 1) &#123; &#x2F;&#x2F; CASE#2</span><br><span class="line">System.out.println(&quot;Entering Case#2&quot;);</span><br><span class="line">if (currentNode.children.size() &gt;&#x3D; 1) &#123;</span><br><span class="line">currentNode.endOfWord &#x3D; false;&#x2F;&#x2F;updating endOfWord will signify that this word is not there in Trie</span><br><span class="line">return false;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Character &quot; + ch + &quot; has no dependency, hence deleting it from last&quot;);</span><br><span class="line">parentNode.children.remove(ch);</span><br><span class="line">return true;&#x2F;&#x2F; If this word is not a prefix of some other word, and since this is last</span><br><span class="line">&#x2F;&#x2F; character, we should</span><br><span class="line">&#x2F;&#x2F; return true, indicating we are ok to delete this node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (currentNode.endOfWord &#x3D;&#x3D; true) &#123; &#x2F;&#x2F; CASE#3</span><br><span class="line">System.out.println(&quot;Entering Case#3&quot;);</span><br><span class="line">delete(currentNode, word, index + 1); </span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Entering Case#1&quot;);</span><br><span class="line">canThisNodeBeDeleted &#x3D; delete(currentNode, word, index + 1); &#x2F;&#x2F; CASE#4</span><br><span class="line">if (canThisNodeBeDeleted &#x3D;&#x3D; true) &#123;</span><br><span class="line">System.out.println(&quot;Character &quot; + ch + &quot; has no dependency, hence deleting it&quot;);</span><br><span class="line">parentNode.children.remove(ch);</span><br><span class="line">return true; &#x2F;&#x2F; Current node can also be deleted</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false; &#x2F;&#x2F; Someone is dependent on this node, hence dont delete it</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; End of class</span><br></pre></td></tr></table></figure><br><p>Main.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package trie;</span><br><span class="line"></span><br><span class="line">public class TrieMain &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Trie t  &#x3D;new Trie();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;CASE#1</span><br><span class="line">t.insert(&quot;bcde&quot;);</span><br><span class="line">t.insert(&quot;bckg&quot;);</span><br><span class="line">t.delete(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bckg&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*&#x2F;&#x2F;CASE#2</span><br><span class="line">t.insert(&quot;bcde&quot;);</span><br><span class="line">t.insert(&quot;bcdefg&quot;);</span><br><span class="line">t.delete(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcdefg&quot;);*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*&#x2F;&#x2F;CASE#3</span><br><span class="line">t.insert(&quot;bcde&quot;);</span><br><span class="line">t.insert(&quot;bc&quot;);</span><br><span class="line">t.delete(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bc&quot;);</span><br><span class="line">t.search(&quot;b&quot;);*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*&#x2F;&#x2F;CASE#4</span><br><span class="line">t.insert(&quot;bcde&quot;);</span><br><span class="line">t.delete(&quot;bcde&quot;);</span><br><span class="line">t.search(&quot;bcde&quot;);*&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;End of Class</span><br></pre></td></tr></table></figure><Br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Trie coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://jbj828.github.io/2020/02/16/Al-Trie/"/>
    <id>http://jbj828.github.io/2020/02/16/Al-Trie/</id>
    <published>2020-02-16T06:30:25.000Z</published>
    <updated>2020-02-17T00:43:39.182Z</updated>
    
    <content type="html"><![CDATA[<p>trie</p><a id="more"></a><p><strong>What is Trie?</strong></p><ul><li>It is a search tree, which is typically used to store/search strings in space/time efficient way.</li><li>In it, any node can store non repetitive multiple characters.</li><li>Also, every node stores ‘link’ of next character of the string.</li><li>Also, every node keeps a track of ‘end of String’</li></ul><br><p><strong>Why learn Trie?</strong></p><ul><li>Used to solve many standard problems in efficient ways<ul><li>Spelling checker</li><li>Auto Complete string</li><li>Etc..</li></ul></li></ul><br><p><strong>Creating a Trie</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Trie()</span><br><span class="line">  create a blank node</span><br></pre></td></tr></table></figure><br><p><strong>Inserting a String in Trie</strong></p><ul><li>Case#1 - Trie is blank(air)</li><li>Case#2 - New String’s prefix is common with another String’s Prefix(aio)</li><li>Case#3 - New String’s prefix is already present as complete String(airk)</li><li>Case#4 - String to be inserted is already present in Trie</li></ul><br><p><strong>Searching a String in Trie</strong> </p><p>ex)abc</p><ul><li>Case#1 - String does not exist in Trie(ex) xyz)</li><li>Case#2 - String exists in Trie(ex) abc)</li><li>Case#3 - Current String is a prefix of another String. But this string does not exist in Trie.(ex) ab)</li></ul><br><p><strong>Deleting a String from Trie</strong></p><ul><li>Case#1 - Some other word’s prefix is same as Prefix of this word(BCDE, BCKG)</li><li>Case#2 - This word is a prefix of some other word(BCDE,BCDEF)</li><li>Case#3 - Some other word is a prefix of this word(BCDE,BC)</li><li>Case#4 - No one is dependent on this word(k)</li></ul><Br><p><strong>Trie-Practical use</strong></p><ul><li>Auto Complete</li><li>Spell Checkers</li></ul><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;trie&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Heap Coding</title>
    <link href="http://jbj828.github.io/2020/02/15/Al-BinaryHeapCoding/"/>
    <id>http://jbj828.github.io/2020/02/15/Al-BinaryHeapCoding/</id>
    <published>2020-02-15T13:30:25.000Z</published>
    <updated>2020-02-15T13:26:55.261Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Heap Coding</p><a id="more"></a><p>HeapByArray.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class HeapByArray &#123;</span><br><span class="line">int[] arr;</span><br><span class="line">int sizeOfTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor</span><br><span class="line">public HeapByArray(int size) &#123;</span><br><span class="line">&#x2F;&#x2F;We are adding 1 here so that first cell of the array can be left blank all the time. This is eliminate problem of array starting from index 0.</span><br><span class="line">arr &#x3D; new int[size+1];</span><br><span class="line">this.sizeOfTree &#x3D; 0;</span><br><span class="line">System.out.println(&quot;Empty Heap has been created !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int sizeOfArray() &#123;</span><br><span class="line">return arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int sizeOfTree() &#123;</span><br><span class="line">System.out.println(&quot;Size Of Tree: &quot; + sizeOfTree);</span><br><span class="line">return sizeOfTree;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isHeapEmpty() &#123;</span><br><span class="line">if (sizeOfTree &lt;&#x3D; 0) &#123;</span><br><span class="line">System.out.println(&quot;Tree is empty !&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Tree is not empty !&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteheap() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Heap has been deleted !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Insert a new value in Heap</span><br><span class="line">public void insertInHeap(int value) &#123;</span><br><span class="line">&#x2F;&#x2F;Doing +1 because sizeOfTree always points to the last occupied cell of the array </span><br><span class="line">System.out.println(&quot;Inserting &quot; + value + &quot; in Heap...&quot;);</span><br><span class="line">arr[sizeOfTree+1] &#x3D; value;</span><br><span class="line">sizeOfTree++;</span><br><span class="line">HeapifyBottomToTop(sizeOfTree);</span><br><span class="line">System.out.println(&quot;Inserted &quot; + value + &quot; successfully in Heap !&quot;);</span><br><span class="line">levelOrder();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Peek into Heap</span><br><span class="line">public void peek() &#123;</span><br><span class="line">if(sizeOfTree &#x3D;&#x3D; 0) &#123;</span><br><span class="line">System.out.println(&quot;Heap is empty !&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Head of the Heap is: &quot; + arr[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Extract Head of Heap</span><br><span class="line">public int extractHeadOfHeap() &#123;</span><br><span class="line">if(sizeOfTree &#x3D;&#x3D; 0) &#123;</span><br><span class="line">System.out.println(&quot;Heap is empty !&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Head of the Heap is: &quot; + arr[1]);</span><br><span class="line">System.out.println(&quot;Extracting it now...&quot;);</span><br><span class="line">int extractedValue &#x3D; arr[1];</span><br><span class="line">arr[1] &#x3D; arr[sizeOfTree];</span><br><span class="line">sizeOfTree--;</span><br><span class="line">HeapifyTopToBottom(1);</span><br><span class="line">System.out.println(&quot;Successfully extracted value from Heap.&quot;);</span><br><span class="line">levelOrder();</span><br><span class="line">return extractedValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void HeapifyBottomToTop(int index) &#123;</span><br><span class="line">int parent &#x3D; index &#x2F; 2;</span><br><span class="line">&#x2F;&#x2F; We are at root of the tree. Hence no more Heapifying is required.</span><br><span class="line">if (index &lt;&#x3D; 1) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; If Current value is smaller than its parent, then we need to swap</span><br><span class="line">if (arr[index] &lt; arr[parent]) &#123;</span><br><span class="line">int tmp &#x3D; arr[index];</span><br><span class="line">arr[index] &#x3D; arr[parent];</span><br><span class="line">arr[parent] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">HeapifyBottomToTop(parent);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void HeapifyTopToBottom(int index) &#123;</span><br><span class="line">int left  &#x3D; index*2;</span><br><span class="line">int right &#x3D; (index*2)+1;</span><br><span class="line">int smallestChild &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (sizeOfTree &lt; left) &#123; &#x2F;&#x2F;If there is no child of this node, then nothing to do. Just return.</span><br><span class="line">return; </span><br><span class="line">&#125;else if (sizeOfTree &#x3D;&#x3D; left) &#123; &#x2F;&#x2F;If there is only left child of this node, then do a comparison and return.</span><br><span class="line">if(arr[index] &gt; arr[left]) &#123;</span><br><span class="line">int tmp &#x3D; arr[index];</span><br><span class="line">arr[index] &#x3D; arr[left];</span><br><span class="line">arr[left] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123; &#x2F;&#x2F;If both children are there</span><br><span class="line">if(arr[left] &lt; arr[right]) &#123; &#x2F;&#x2F;Find out the smallest child</span><br><span class="line">smallestChild &#x3D; left;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">smallestChild &#x3D; right;</span><br><span class="line">&#125;</span><br><span class="line">if(arr[index] &gt; arr[smallestChild]) &#123; &#x2F;&#x2F;If Parent is greater than smallest child, then swap</span><br><span class="line">int tmp &#x3D; arr[index];</span><br><span class="line">arr[index] &#x3D; arr[smallestChild];</span><br><span class="line">arr[smallestChild] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HeapifyTopToBottom(smallestChild);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void levelOrder() &#123;</span><br><span class="line">System.out.println(&quot;Printing all the elements of this Heap...&quot;);&#x2F;&#x2F; Printing from 1 because 0th cell is dummy</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; sizeOfTree; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Heap Coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Heap</title>
    <link href="http://jbj828.github.io/2020/02/14/Al-BinaryHeap/"/>
    <id>http://jbj828.github.io/2020/02/14/Al-BinaryHeap/</id>
    <published>2020-02-14T13:16:25.000Z</published>
    <updated>2020-02-15T14:46:04.039Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Heap theory </p><a id="more"></a><br><p><strong>What is Binary Heap</strong></p><ul><li><p>Definition : Binary Heap is a Binary Tree with some special properties.</p><br><ol><li><p>Heap property</p><ul><li>Value of any given node must be &lt;= value of its children(Min-Heap)</li><li>Value of any given node must be &gt;= value of its children(Max-Heap)<br></li></ul></li><li><p>Complete tree</p><ul><li>All levels are completely filled except possibly the last level and the last level has all keys as left as possible.</li><li>This makes Binary Heap ideal candidate for Array Implementation.</li></ul></li></ol></li></ul><Br><p><strong>Why should we learn Binary Heap?</strong></p><p>There are cases when we want to find ‘min/max’ number among set of numbers in log(n) time. Also, we want to make sure that Inserting additional numbers does not take more than O(log n) time.</p><br><ul><li><p>Possible Solutions:</p><ol><li>Store the numbers in sorted Array &lt;- Take O(n) time complexity</li><li>Store the numbers in Linked List in sorted manner &lt;- Take O(n) time complexity</li></ol></li></ul><br>Binary Heap will solve this problem with O(log n).<br><p><strong>Types of Binary Heap</strong></p><ol><li>Min-Heap : If the value of each node is less than or equal to value of both of its children.</li><li>Max-Heap : If the value of each node is more than or equal to value of both of its children.</li></ol><br><p><strong>Practical Use</strong></p><ol><li>Prim’s Algorithm</li><li>Heap Sort</li><li>Priority Queue</li></ol><p><br><br></p><h4 id="Binary-Heap-Array-Representaion"><a href="#Binary-Heap-Array-Representaion" class="headerlink" title="Binary Heap - Array Representaion"></a>Binary Heap - Array Representaion</h4><ul><li>Implementation options<ul><li>Array based Implementation</li><li>Reference/Pointer based Implementation</li></ul></li></ul><br><p><strong>Insertion in Heap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insertValueInHeap(value)</span><br><span class="line">  if tree does not exists</span><br><span class="line">    return error message</span><br><span class="line">  else</span><br><span class="line">    insert &#39;value&#39; in first unused cell of Array</span><br><span class="line">    sizeOfHeap++</span><br><span class="line">    heapifyBottomToTop(sizeOfHeap)  ----- O(log n) : this means the height of the tree, the recursive call will step every node until it reaches the number which is smaller(Min-Heap) than its children</span><br></pre></td></tr></table></figure><Br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>ExtractMin from Heap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extractMin()</span><br><span class="line">  if tree does not exist</span><br><span class="line">    return error message</span><br><span class="line">  else</span><br><span class="line">    extract 1st cell of Array</span><br><span class="line">    promote last element to first</span><br><span class="line">    sizeOfHeap--</span><br><span class="line">    heapifyTopToBottom(1)</span><br></pre></td></tr></table></figure><Br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>Delete Heap</strong></p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteHeap()</span><br><span class="line">  set array to null</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1) </li></ul><br><p><strong>Reason why we don’t use Reference implementation(linked list) on Binary Heap</strong></p><ul><li>When we try to extract min/max number from the tree using reference, we need to loop all over the tree to find the value. This procedure takes O(n) time complexity. Inefficient!!</li></ul><p><Br><Br></p><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Heap theory &lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>AVL Tree Coding</title>
    <link href="http://jbj828.github.io/2020/02/14/AVL-code/"/>
    <id>http://jbj828.github.io/2020/02/14/AVL-code/</id>
    <published>2020-02-14T05:16:25.000Z</published>
    <updated>2020-02-14T05:17:03.311Z</updated>
    
    <content type="html"><![CDATA[<p>AVL Tree Coding</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">import node.*;</span><br><span class="line"></span><br><span class="line">public class AVLTree &#123;</span><br><span class="line">    BinaryNode root;</span><br><span class="line">    public BinaryNode getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor</span><br><span class="line">    AVLTree() &#123;</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert values in AVL Tree</span><br><span class="line">    void insert(int value) &#123;</span><br><span class="line">        root &#x3D; insert(root, value);</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    BinaryNode insert(BinaryNode currentNode, int value) &#123;</span><br><span class="line">        &#x2F;&#x2F; THIS ELSE_IF BLOCK IS BST CONDITION</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Successfully inserted &quot; + value + &quot; in AVL Tree&quot;);</span><br><span class="line">            return createNewNode(value);</span><br><span class="line">        &#125; else if (value &lt;&#x3D; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setLeft(insert(currentNode.getLeft(), value));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.setRight(insert(currentNode.getRight(), value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; THIS IS WHERE WE WILL DO AVL SPECIFIC WORK</span><br><span class="line">        int balance &#x3D; checkBalance(currentNode.getLeft(), currentNode.getRight());</span><br><span class="line">        if (balance &gt; 1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getLeft().getLeft(), currentNode.getLeft().getRight()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);&#x2F;&#x2F; LL Condition</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setLeft(leftRotate(currentNode.getLeft())); &#x2F;&#x2F; LR Condition</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (balance &lt; -1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getRight().getRight(), currentNode.getRight().getLeft()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);&#x2F;&#x2F; RR Condition</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setRight(rightRotate(currentNode.getRight()));&#x2F;&#x2F; RL Condition</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getLeft().setHeight(calculateHeight(currentNode.getLeft()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentNode.getRight() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getRight().setHeight(calculateHeight(currentNode.getRight()));</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        return currentNode;</span><br><span class="line"></span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    private BinaryNode leftRotate(BinaryNode currentNode) &#123;</span><br><span class="line">        BinaryNode newRoot &#x3D; currentNode.getRight();</span><br><span class="line">        currentNode.setRight(currentNode.getRight().getLeft());</span><br><span class="line">        newRoot.setLeft(currentNode);</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        newRoot.setHeight(calculateHeight(newRoot));</span><br><span class="line">        return newRoot;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    private BinaryNode rightRotate(BinaryNode currentNode) &#123;</span><br><span class="line">        BinaryNode newRoot &#x3D; currentNode.getLeft();</span><br><span class="line">        currentNode.setLeft(currentNode.getLeft().getRight());</span><br><span class="line">        newRoot.setRight(currentNode);</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        newRoot.setHeight(calculateHeight(newRoot));</span><br><span class="line">        return newRoot;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    private int checkBalance(BinaryNode rootLeft, BinaryNode rootRight) &#123;</span><br><span class="line">        if((rootLeft &#x3D;&#x3D; null) &amp;&amp; (rootRight &#x3D;&#x3D; null)) &#123; &#x2F;&#x2F;if current node is a leaf node then no need to check balance of its children</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if (rootLeft &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return -1 * (rootRight.getHeight() + 1); &#x2F;&#x2F; if left node node is not there then simply return right node&#39;s</span><br><span class="line">            &#x2F;&#x2F; height + 1</span><br><span class="line">            &#x2F;&#x2F; we need to make it -1 because blank height is considered</span><br><span class="line">            &#x2F;&#x2F; having height as &#39;-1&#39;</span><br><span class="line">        &#125; else if (rootRight &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return rootLeft.getHeight() + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return rootLeft.getHeight() - rootRight.getHeight(); &#x2F;&#x2F; +1 is not required, as both right and left child</span><br><span class="line">            &#x2F;&#x2F; exits and 1 gets nullified</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Calculate height of Node</span><br><span class="line">    private int calculateHeight(BinaryNode currentNode) &#123;</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1 + Math.max((currentNode.getLeft() !&#x3D; null ? currentNode.getLeft().getHeight() : -1),</span><br><span class="line">                (currentNode.getRight() !&#x3D; null ? currentNode.getRight().getHeight() : -1));</span><br><span class="line"></span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; creates a new blank new node</span><br><span class="line">    public BinaryNode createNewNode(int value) &#123;</span><br><span class="line">        BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">        node.setValue(value);</span><br><span class="line">        node.setHeight(0);&#x2F;&#x2F; Since this is a leaf node, its height is 0</span><br><span class="line">        return node;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Level order traversal of BST</span><br><span class="line">    void levelOrderTraversal() &#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        System.out.println(&quot;Printing Level order traversal of AVL Tree...&quot;);</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists !&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">            System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">            if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getLeft());</span><br><span class="line">            if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deleting a node from BST</span><br><span class="line">    public void deleteNodeOfBST(int value) &#123;</span><br><span class="line">        System.out.println(&quot;Deleting &quot; + value + &quot; from AVL Tree ...&quot;);</span><br><span class="line">        root &#x3D; deleteNodeOfBST(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method for delete</span><br><span class="line">    public BinaryNode deleteNodeOfBST(BinaryNode currentNode, int value) &#123;</span><br><span class="line">        &#x2F;&#x2F; THIS ELSE_IF BLOCK IS BST CONDITION</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        if (value &lt; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setLeft(deleteNodeOfBST(currentNode.getLeft(), value));</span><br><span class="line">        &#125; else if (value &gt; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setRight(deleteNodeOfBST(currentNode.getRight(), value));</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; If currentNode is the node to be deleted</span><br><span class="line">            &#x2F;&#x2F;System.out.println(&quot;currentNode is the node to be deleted&quot;);</span><br><span class="line">            if (currentNode.getLeft() !&#x3D; null &amp;&amp; currentNode.getRight() !&#x3D; null) &#123; &#x2F;&#x2F; if nodeToBeDeleted have both children</span><br><span class="line">                BinaryNode temp &#x3D; currentNode;</span><br><span class="line">                BinaryNode minNodeForRight &#x3D; minimumElement(temp.getRight());&#x2F;&#x2F; Finding minimum element from right subtree</span><br><span class="line">                currentNode.setValue(minNodeForRight.getValue()); &#x2F;&#x2F; Replacing current node with minimum node from right subtree</span><br><span class="line">                deleteNodeOfBST(currentNode.getRight(), minNodeForRight.getValue());&#x2F;&#x2F; Deleting minimum node from right now</span><br><span class="line">            &#125; else if (currentNode.getLeft() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only left child</span><br><span class="line">                currentNode &#x3D; currentNode.getLeft();</span><br><span class="line">            &#125; else if (currentNode.getRight() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only right child</span><br><span class="line">                currentNode &#x3D; currentNode.getRight();</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; if nodeToBeDeleted do not have child (Leaf node)</span><br><span class="line">                &#x2F;&#x2F;System.out.println(&quot;This node is leaf node&quot;);</span><br><span class="line">                currentNode &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            return currentNode;&#x2F;&#x2F; if it is a leaf node,then no need to do balancing for this node, do only for its ancestors</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; THIS IS WHERE WE WILL DO AVL SPECIFIC WORK</span><br><span class="line">        int balance &#x3D; checkBalance(currentNode.getLeft(), currentNode.getRight());</span><br><span class="line">        if (balance &gt; 1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getLeft().getLeft(), currentNode.getLeft().getRight()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);&#x2F;&#x2F; LL Condition</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setLeft(leftRotate(currentNode.getLeft())); &#x2F;&#x2F; LR Condition</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (balance &lt; -1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getRight().getRight(), currentNode.getRight().getLeft()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);&#x2F;&#x2F; RR Condition</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setRight(rightRotate(currentNode.getRight()));&#x2F;&#x2F; RL Condition</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getLeft().setHeight(calculateHeight(currentNode.getLeft()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentNode.getRight() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getRight().setHeight(calculateHeight(currentNode.getRight()));</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        return currentNode;</span><br><span class="line"></span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Get minimum element in binary search tree</span><br><span class="line">    public static BinaryNode minimumElement(BinaryNode root) &#123;</span><br><span class="line">        if (root.getLeft() &#x3D;&#x3D; null)</span><br><span class="line">            return root;</span><br><span class="line">        else &#123;</span><br><span class="line">            return minimumElement(root.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void printTreeGraphically() &#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; level &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        int CurrentLevel &#x3D; 1;</span><br><span class="line">        boolean previousLevelWasAllNull &#x3D; false;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        level.add(1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\nPrinting Level order traversal of Tree...&quot;);</span><br><span class="line">        if(root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists !&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            if(CurrentLevel &#x3D;&#x3D; level.peek()) &#123; &#x2F;&#x2F;if we are in the same level</span><br><span class="line">                if(queue.peek()&#x3D;&#x3D;null) &#123;</span><br><span class="line">                    queue.add(null);level.add(CurrentLevel+1);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    queue.add(queue.peek().getLeft());level.add(CurrentLevel+1);</span><br><span class="line">                    queue.add(queue.peek().getRight());level.add(CurrentLevel+1);</span><br><span class="line">                    previousLevelWasAllNull &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(queue.remove() + &quot;  &quot;);level.remove();</span><br><span class="line">            &#125;else &#123; &#x2F;&#x2F;level has changed</span><br><span class="line">                System.out.println(&quot;\n&quot;);</span><br><span class="line">                CurrentLevel++;</span><br><span class="line">                if(previousLevelWasAllNull &#x3D;&#x3D; true) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                previousLevelWasAllNull &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#x2F;&#x2F;end of loop</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AVL Tree Coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>AVL Tree</title>
    <link href="http://jbj828.github.io/2020/02/12/Al-AVL-Tree/"/>
    <id>http://jbj828.github.io/2020/02/12/Al-AVL-Tree/</id>
    <published>2020-02-12T06:30:25.000Z</published>
    <updated>2020-02-12T14:47:49.330Z</updated>
    
    <content type="html"><![CDATA[<p>AVL Tree</p><a id="more"></a><p><strong>Why AVL Tree?</strong></p><ul><li>Depending on Incoming data, A Binary Search tree can get skewed and hence its performance starts going down. Instead of O(log n) for insertion/searching/deleting it can go up to O(n)</li><li>AVL tree attempts to solve this problem of ‘skewing’ by introducing concept called ‘Rotation’.</li></ul><p><strong>What is AVL Tree?</strong></p><ul><li>An AVL tree is a balanced ‘Binary Search Tree’ where the height of immediate subtrees of any node differs by at most one(also called balance factor).</li><li>If at any time heights differ by more than one, rebalancing is done to restore this property(called rotation).</li><li>Empty height is always considered -1.</li></ul><br><h3 id="Algorithm-of-AVL-Tree"><a href="#Algorithm-of-AVL-Tree" class="headerlink" title="Algorithm of AVL Tree"></a>Algorithm of AVL Tree</h3><ul><li>create, search, traverse Algorithm is totally same as the BST.</li></ul><h4 id="Insertion-of-node-in-AVL-Tree"><a href="#Insertion-of-node-in-AVL-Tree" class="headerlink" title="Insertion of node in AVL Tree"></a>Insertion of node in AVL Tree</h4><ul><li>Case#1 - Whene ‘rotation’ is not required.<ul><li>The algorithm is same as the BST Insertion.</li></ul></li><li>Case#2 - When ‘rotation is required(LL, LR, RR, RL).</li></ul><p><strong>Left-Left Condition</strong></p><ul><li>What is Left-Left condition?<ul><li>Left-Left Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Right Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rightRotate(currentDisbalancedNode)</span><br><span class="line">  newRoot &#x3D; currentDisbalancedNode.left</span><br><span class="line">  currentDisbalancedNode.left &#x3D; currentDisbalancedNode.left.right</span><br><span class="line">  newRoot.right &#x3D; currentDisbalancedNode</span><br><span class="line">  currentDisabledNode.height &#x3D; calculateHeight(currentDisbalancedNode)</span><br><span class="line">  newRoot.height &#x3D; calculateHeight(newRoot)</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Left-Right Condition</strong></p><ul><li>What is Left-Right condition?<ul><li>Left-Right Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Left Rotation followed by Right Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">leftRotate(currentDisbalancedNode&#39;sLeftChild)</span><br><span class="line">  newRoot &#x3D; currentDisbalancedNode&#39;sLeftChild.right</span><br><span class="line">  currentDisbalancedNode&#39;sLeftChild.right &#x3D; currentDisbalancedNode&#39;sLeftChild.right.left</span><br><span class="line">  newRoot.left &#x3D; currentDisbalancedNode&#39;sLeftChild</span><br><span class="line">  currentDisbalancedNode&#39;sLeftChild.Height &#x3D; calculateHeight(currentDisbalancedNode&#39;sLeftChild)</span><br><span class="line">  newRoot.Height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  rightRotate(currentDisbalancedNode)  ------ left-left Condition이랑 같음</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Right-Right Condition</strong></p><ul><li>What is Right-Right condition?<ul><li>Right-Right Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Left Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftRotate(currentDisbalancedNode)</span><br><span class="line">  newRoot &#x3D; currentDisbalancedNode.right</span><br><span class="line">  currentDisbalancedNode.right &#x3D; currentDisbalancedNode.right.left</span><br><span class="line">  newRoot.left &#x3D; currentDisbalancedNode</span><br><span class="line">  currentDisbalancedNode.Height &#x3D; calculateHeight(currentDisbalancedNode)</span><br><span class="line">  newRoot.Height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Right-left Condition</strong></p><ul><li>What is Right-left condition?<ul><li>Right-left Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Right Rotation followed by Left Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rightRotate(currentDisableNode&#39;sRight)</span><br><span class="line">  newRoot &#x3D; currentDisableNode&#39;sRight.left</span><br><span class="line">  currentDisableNode&#39;sRight.left.right &#x3D; currentDisableNode&#39;sRight</span><br><span class="line">  currentDisableNode&#39;sRight.height &#x3D; calculateHeight(currentDisableNode&#39;sRight)</span><br><span class="line">  newRoot.height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot;</span><br><span class="line"></span><br><span class="line">leftRotate(currentDisabledNode)</span><br><span class="line">  newRoot &#x3D; currentDisabledNode.right</span><br><span class="line">  currentDisabledNode.right &#x3D; currentDisabledNode.right.left</span><br><span class="line">  newRoot.left &#x3D; currentDisabledNode</span><br><span class="line">  currentDisabledNode.height &#x3D; calculateHeight(currentDisabledNode)</span><br><span class="line">  newRoot.height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Insertion Algorithm in AVL Tree</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Node Insert(Node root, int data)</span><br><span class="line">  if(root &#x3D;&#x3D; null) return new Node(data)</span><br><span class="line">  else if(data &lt;&#x3D; root.data) root.left &#x3D; insert(root.left, data)</span><br><span class="line">  else root.right &#x3D; insert(root.right, data)</span><br><span class="line">  </span><br><span class="line">  int balance &#x3D; height(root.left) - height(root.right)</span><br><span class="line">  if(balance &gt; 1)</span><br><span class="line">    if height(root.left.left) &gt;&#x3D; height(root.left.right)</span><br><span class="line">      RightRotation(root) &#x2F;&#x2F;LL condition</span><br><span class="line">    else</span><br><span class="line">      LeftRotation(root.left)</span><br><span class="line">      RightRotation(root)  &#x2F;&#x2F; LR condition</span><br><span class="line"></span><br><span class="line">  else if(balance &lt; -1)  &#x2F;&#x2F; if right subtree is overloaded</span><br><span class="line">    if height(root.right.right) &gt;&#x3D; height(root.right.left)</span><br><span class="line">      LeftRotation(root)  &#x2F;&#x2F; RR condition</span><br><span class="line">    else</span><br><span class="line">      RightRotation(root.right)</span><br><span class="line">      LeftRotation(root)  &#x2F;&#x2F; RL condition</span><br><span class="line">  </span><br><span class="line">  root.height &#x3D; max(root.left, root.right) + 1</span><br><span class="line">  return root</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n)</li></ul><br><h4 id="Deletion-of-Node-from-AVL-Tree"><a href="#Deletion-of-Node-from-AVL-Tree" class="headerlink" title="Deletion of Node from AVL Tree"></a>Deletion of Node from AVL Tree</h4><ul><li>Deletion of a node<ul><li>Case#1 - When tree does not exists</li><li>Case#2 - When ‘rotation’ is not required(BST Conditions)<ul><li>Node to be deleted is leaf node</li><li>Node to be deleted is having 1 child</li><li>Node to be deleted has 2 children</li></ul></li><li>Case#3 - When ‘rotation’ is required(LL, LR, RR, RL)</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeOfAVL(currentNode, valueToBeDeleted)</span><br><span class="line">  if(currentNode &#x3D;&#x3D; null) return null;</span><br><span class="line"></span><br><span class="line">  if(valueToBeDeleted &lt; currentNode.value)</span><br><span class="line">    then currentNode.left &#x3D; deleteNodeOfAVL(currentNode.left, valueToBeDeleted)</span><br><span class="line">  else if(valueToBeDeleted &gt; currentNode.value)</span><br><span class="line">    then currentNode.right &#x3D; deleteNodeOfAVL(currentNode.right, valueToBeDeleted)</span><br><span class="line">  else  &#x2F;&#x2F;if the currentNode is the node to be deleted</span><br><span class="line">      if currentNode have both children, then find minimum element from right subtree(Case#3)</span><br><span class="line">          replace current node with minimum node from right subtree and delete minimum node from right</span><br><span class="line"></span><br><span class="line">      else if nodeToBeDeleted has only left child(Case#2)</span><br><span class="line">            then currentNode &#x3D; currentNode.left</span><br><span class="line">      else if nodeToBeDeleted has only right child</span><br><span class="line">      (Case#2)</span><br><span class="line">            then currentNode &#x3D; currentNode.right</span><br><span class="line">      </span><br><span class="line">      else &#x2F;&#x2F;if nodeToBeDeleted do not have child(Case#1)</span><br><span class="line">            currentNode &#x3D; null;</span><br><span class="line"></span><br><span class="line">  int balance &#x3D; checkBalance(currentNode.left, currentNode.right);</span><br><span class="line"></span><br><span class="line">  if(balance &gt; 1)</span><br><span class="line">      if(checkBalance(currentNode.left().left(), currentNode.left().right()) &gt; 0)</span><br><span class="line">          currentNode &#x3D; rightRotate(currentNode); &#x2F;&#x2F;LL Condition</span><br><span class="line">      </span><br><span class="line">      else </span><br><span class="line">          currentNode.left &#x3D; leftRotate(currentNode.left);</span><br><span class="line">          currentNode &#x3D; rightRotate  &#x2F;&#x2F;LR condition</span><br><span class="line">    </span><br><span class="line">    else if(balance &lt; -1)</span><br><span class="line">      if(checkBalance(currentNode.right().right(), currentNode.right().left()) &gt; 0)</span><br><span class="line">          currentNode &#x3D; leftRotate(currentNode); &#x2F;&#x2F;RR Condition</span><br><span class="line"></span><br><span class="line">      else </span><br><span class="line">          currentNode.right &#x3D; rightRotate(currentNode.right); &#x2F;&#x2F;RL condition</span><br><span class="line">          currentNode &#x3D; leftRotate(currentNode);</span><br><span class="line"></span><br><span class="line">  if(currentNode.left() !&#x3D; null) then currentNode.left().setHeight(calculateHeight(currentNode.left));</span><br><span class="line">  if(currentNode.right() !&#x3D; null) then currentNode.right().setHeight(calculateHeight(currentNode.right());</span><br><span class="line">  currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line"></span><br><span class="line">  return currentNode;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n)</li></ul><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AVL Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree Coding</title>
    <link href="http://jbj828.github.io/2020/02/11/Al-BST-code/"/>
    <id>http://jbj828.github.io/2020/02/11/Al-BST-code/</id>
    <published>2020-02-11T09:30:25.000Z</published>
    <updated>2020-02-11T10:25:35.382Z</updated>
    
    <content type="html"><![CDATA[<p>BST Coding</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import node.BinaryNode;</span><br><span class="line"></span><br><span class="line">public class BinarySearchTreeByLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    BinaryNode root;</span><br><span class="line"></span><br><span class="line">    public BinaryNode getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor</span><br><span class="line">    BinarySearchTreeByLinkedList() &#123;</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert values in BST</span><br><span class="line">    void insert(int value) &#123;</span><br><span class="line">        root &#x3D; insert(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    BinaryNode insert(BinaryNode currentNode, int value) &#123;</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; if root node is blank then insert new node there</span><br><span class="line">            System.out.println(&quot;Successfully inserted &quot; + value + &quot; in BST&quot;);</span><br><span class="line">            return createNewNode(value);</span><br><span class="line">        &#125; else if (value &lt;&#x3D; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setLeft(insert(currentNode.getLeft(), value));</span><br><span class="line">            return currentNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.setRight(insert(currentNode.getRight(), value));</span><br><span class="line">            return currentNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; creates a new blank new node</span><br><span class="line">    public BinaryNode createNewNode(int value) &#123;</span><br><span class="line">        BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">        node.setValue(value);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deleting a node from BST</span><br><span class="line">    public void deleteNodeOfBST(int value) &#123;</span><br><span class="line">        System.out.println(&quot;\n\nDeleting &quot; + value + &quot; from BST...&quot;);</span><br><span class="line">        deleteNodeOfBST(root,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method for delete</span><br><span class="line">    public BinaryNode deleteNodeOfBST(BinaryNode root, int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Value not found in BST&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (value &lt; root.getValue()) &#123;</span><br><span class="line">            root.setLeft(deleteNodeOfBST(root.getLeft(), value));</span><br><span class="line">        &#125; else if (value &gt; root.getValue()) &#123;</span><br><span class="line">            root.setRight(deleteNodeOfBST(root.getRight(), value));</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; If currentNode is the node to be deleted</span><br><span class="line"></span><br><span class="line">            if (root.getLeft() !&#x3D; null &amp;&amp; root.getRight() !&#x3D; null) &#123; &#x2F;&#x2F; if nodeToBeDeleted have both children</span><br><span class="line">                BinaryNode temp &#x3D; root;</span><br><span class="line">                BinaryNode minNodeForRight &#x3D; minimumElement(temp.getRight());&#x2F;&#x2F; Finding minimum element from right subtree</span><br><span class="line">                root.setValue(minNodeForRight.getValue()); &#x2F;&#x2F; Replacing current node with minimum node from right subtree</span><br><span class="line">                root.setRight(deleteNodeOfBST(root.getRight(), minNodeForRight.getValue()));  &#x2F;&#x2F; Deleting minimum node from right now</span><br><span class="line">            &#125; else if (root.getLeft() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only left child</span><br><span class="line">                root &#x3D; root.getLeft();</span><br><span class="line">            &#125; else if (root.getRight() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only right child</span><br><span class="line">                root &#x3D; root.getRight();</span><br><span class="line">            &#125; else &#x2F;&#x2F; if nodeToBeDeleted do not have child (Leaf node)</span><br><span class="line">                root &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Get minimum element in binary search tree</span><br><span class="line">    public static BinaryNode minimumElement(BinaryNode root) &#123;</span><br><span class="line">        if (root.getLeft() &#x3D;&#x3D; null)</span><br><span class="line">            return root;</span><br><span class="line">        else &#123;</span><br><span class="line">            return minimumElement(root.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search a node in BST</span><br><span class="line">    void searchForValue(int value) &#123;</span><br><span class="line">        searchForValue(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search a node in BST</span><br><span class="line">    BinaryNode searchForValue(BinaryNode node, int value) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Value: &quot; + value + &quot; not found in BST.&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else if (node.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">            System.out.println(&quot;Value: &quot; + value + &quot; found in BST.&quot;);</span><br><span class="line">            return node;</span><br><span class="line">        &#125; else if (value &lt; node.getValue()) &#123;</span><br><span class="line">            return searchForValue(node.getLeft(), value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return searchForValue(node.getRight(), value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Level order traversal of BST</span><br><span class="line">    void levelOrderTraversal() &#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        System.out.println(&quot;\nPrinting Level order traversal of Tree...&quot;);</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists !&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">            System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">            if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getLeft());</span><br><span class="line">            if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete entire BST</span><br><span class="line">    public void deleteTree() &#123;</span><br><span class="line">        System.out.println(&quot;Deleting entire Tree...&quot;);</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">        System.out.println(&quot;Tree deleted successfully !&quot;);</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void printTreeGraphically()&#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; level &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        int CurrentLevel &#x3D; 1;</span><br><span class="line">        boolean previousLevelWasAllNull &#x3D; false;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        level.add(1);</span><br><span class="line"></span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            if(CurrentLevel &#x3D;&#x3D; level.peek())&#123;</span><br><span class="line">                if(queue.peek() &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    queue.add(null);</span><br><span class="line">                    level.add(CurrentLevel +1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    queue.add(queue.peek().getLeft());</span><br><span class="line">                    level.add(CurrentLevel + 1);</span><br><span class="line">                    queue.add(queue.peek().getRight());</span><br><span class="line">                    level.add(CurrentLevel + 1);</span><br><span class="line">                    previousLevelWasAllNull &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(queue.remove() + &quot; &quot;);</span><br><span class="line">                level.remove();</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;\n&quot;);</span><br><span class="line">                CurrentLevel++;</span><br><span class="line">                if(previousLevelWasAllNull &#x3D;&#x3D; true)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                previousLevelWasAllNull &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BST Coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree</title>
    <link href="http://jbj828.github.io/2020/02/10/Al-BST/"/>
    <id>http://jbj828.github.io/2020/02/10/Al-BST/</id>
    <published>2020-02-10T14:30:25.000Z</published>
    <updated>2020-02-11T02:55:18.265Z</updated>
    
    <content type="html"><![CDATA[<p>The theory of BST</p><a id="more"></a><p><strong>What is BST?</strong></p><ul><li>Binary Search Tree(BST) is a Binary Tree which all the nodes follows the below mentioned properties<ul><li>The left sub-tree of a node has a key less than or equal to its parent node’s key.</li><li>The right sub tree of a node has a key greater than to its parent node’s key.</li></ul></li></ul><br><p><strong>Why should we learn BST?</strong></p><ul><li>Binary tree implemented by linked list has good space efficient compared to the BT implemented by Array. However, it is not good on Insertion, deletion, searching, traversing which has time complexity of O(n). BST will improve the time complexity of binary tree by O(log n).</li></ul><p><br><br></p><p><strong>Algorithm - Creation of blank BST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createBST()</span><br><span class="line">  Initialize Root with null</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Algorithm - Searching a node in BST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BST_Search(root, value)  ------------T(n)</span><br><span class="line">  if(root is null)</span><br><span class="line">    return null</span><br><span class="line">  else if(root &#x3D;&#x3D; value)</span><br><span class="line">    return root</span><br><span class="line">  else if(value &lt; root)</span><br><span class="line">    BST_Search(root.left, value)  ----T(n&#x2F;2)</span><br><span class="line">  else if(value &gt; root)</span><br><span class="line">    BST_Search(root.right, value) ----T(n&#x2F;2)</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) —-beacuse of recursive call</li></ul><br><p><strong>Algorithm - Traverse in BST</strong></p><ul><li>Totally same as traversing Binary Tree</li></ul><br><p><strong>Algorithm - Inserting a node in BST</strong></p><ul><li>Cases<ul><li>BST is  blank</li><li>BST is non-blank</li></ul></li></ul><p>Using Stack on the behind of the scene.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BST_Insert(currentNode, valueToInsert)</span><br><span class="line">  if(currentNode is null)</span><br><span class="line">    create a node, insert &#39;valueToInsert&#39; in it</span><br><span class="line">  else if(valueToInsert &lt;&#x3D; currentNode&#39;s value)</span><br><span class="line">    currentNode.left &#x3D; BST_Insert(currentNode.left, valueToInsert)</span><br><span class="line">  else</span><br><span class="line">    currentNode.right &#x3D; BST_Insert(currentNode.right, valueToInsert)</span><br><span class="line">  return currentNode</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>Algorithm - Deleting a node in BST</strong></p><ul><li>Cases<ul><li>Node to be deleted is leaf node</li><li>Node to be deleted is having 1 child</li><li>Node to be deleted has 2 child</li></ul></li></ul><p>Using Stack on the behind of the scene.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeOfBST(root, valueToBeDeleted)  --------------------------------------T(n)</span><br><span class="line">  if(root &#x3D;&#x3D; null) return null;</span><br><span class="line">  if(valueToBeDeleted &lt; root.value)</span><br><span class="line">    then root.left &#x3D; deleteNodeOfBST(root.left, valueToBeDeleted)   ---------------T(n&#x2F;2)</span><br><span class="line">  else if(valueToBeDeleted &gt; root.value)</span><br><span class="line">    then root.right &#x3D; deleteNodeOfBST(root.right, valueToBeDeleted)  ---------------T(n&#x2F;2)</span><br><span class="line">  else &#x2F;&#x2F; if cuurentNode is the node to be deleted</span><br><span class="line">      if root have both children, then find minimum element from right subtree(Case#3)  -------------O(log n)</span><br><span class="line">          replace current node with minimum node from right subtree and delete minimum node from right</span><br><span class="line">      else if node ToBeDeleted has only left child(Case#2)</span><br><span class="line">            then root &#x3D; root.left();</span><br><span class="line">      else &#x2F;&#x2F; if node ToBeDeleted do not have child(Case#1)</span><br><span class="line">            root &#x3D; null;</span><br><span class="line">  return root;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>Algorithm - Deleting entire tree in BST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeleteBST()</span><br><span class="line">  root &#x3D; null;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1) </li></ul><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The theory of BST&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Code(Array Implementation)</title>
    <link href="http://jbj828.github.io/2020/02/10/Al-BT-arrayCode/"/>
    <id>http://jbj828.github.io/2020/02/10/Al-BT-arrayCode/</id>
    <published>2020-02-10T13:30:25.000Z</published>
    <updated>2020-02-10T13:57:29.861Z</updated>
    
    <content type="html"><![CDATA[<p>Array Implementation code</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeByArray &#123;</span><br><span class="line">int [] arr;</span><br><span class="line">int lastUsedIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor for blank Tree</span><br><span class="line">public BinaryTreeByArray(int size) &#123;</span><br><span class="line">arr &#x3D; new int[size+1];</span><br><span class="line">this.lastUsedIndex &#x3D; 0; </span><br><span class="line">System.out.println(&quot;Blank Tree of size &quot; +size+ &quot; has been created !\n&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Check if array is full</span><br><span class="line">boolean isTreeFull()&#123;</span><br><span class="line">if(arr.length-1 &#x3D;&#x3D; lastUsedIndex) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; New node should be inserted at the first empty place in the array</span><br><span class="line">void insert(int value) &#123;</span><br><span class="line">if(!isTreeFull()) &#123;</span><br><span class="line">arr[lastUsedIndex+1] &#x3D; value;</span><br><span class="line">lastUsedIndex++;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot;+value+ &quot; in the tree!&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Could not insert value in the Tree as it is full !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;level-Order traversal of binary tree</span><br><span class="line">public void levelOrder() &#123;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;lastUsedIndex;i++ ) &#123;</span><br><span class="line">System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Pre-Order traversal of binary tree</span><br><span class="line">public void preOrder(int index) &#123;</span><br><span class="line">if (index &gt; lastUsedIndex) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(arr[index] + &quot; &quot;);</span><br><span class="line">preOrder(index * 2);</span><br><span class="line">preOrder(index * 2 + 1);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Post-Order Traversal of binary tree</span><br><span class="line">void postOrder(int index) &#123;</span><br><span class="line">if (index &gt; lastUsedIndex) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">postOrder(index * 2);</span><br><span class="line">postOrder(index * 2 + 1);</span><br><span class="line">System.out.print(arr[index] + &quot; &quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; In-Order Traversal of binary tree</span><br><span class="line">void inOrder(int index) &#123;</span><br><span class="line">if (index &gt; lastUsedIndex) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">inOrder(index * 2);</span><br><span class="line">System.out.print(arr[index] + &quot; &quot;);</span><br><span class="line">inOrder(index * 2 + 1);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Do a linear search on the array </span><br><span class="line">public int search(int value) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; lastUsedIndex; i++) &#123;</span><br><span class="line">if (arr[i] &#x3D;&#x3D; value) &#123;</span><br><span class="line">System.out.print(value +&quot; exists in the Tree! &quot;);</span><br><span class="line">System.out.println(&quot;It is at the location: &quot; + i);</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(value + &quot; does not exists in Tree !&quot;);</span><br><span class="line">System.out.println();</span><br><span class="line">return -1;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; delete operation of binary tree</span><br><span class="line">public void delete(int value) &#123;</span><br><span class="line">int location &#x3D; search(value);</span><br><span class="line">&#x2F;&#x2F;If Value does not exists in Array</span><br><span class="line">if (location &#x3D;&#x3D; -1) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;insert last element of the Tree into current location</span><br><span class="line">arr[location] &#x3D; arr[lastUsedIndex];</span><br><span class="line">lastUsedIndex--;</span><br><span class="line">System.out.println(&quot;Successfully deleted &quot; + value + &quot; from the Tree !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteTree()&#123;</span><br><span class="line">try &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Tree has been deleted successfully !&quot;);</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">System.out.println(&quot;There was an error deleting the tree.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Array Implementation code&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree - Array Implementation</title>
    <link href="http://jbj828.github.io/2020/02/09/Al-BT-array/"/>
    <id>http://jbj828.github.io/2020/02/09/Al-BT-array/</id>
    <published>2020-02-09T13:30:25.000Z</published>
    <updated>2020-02-10T05:59:33.729Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree implemented by Array</p><a id="more"></a><p><strong>How does tree looks when implemented via Array?</strong></p><ul><li>Left Child - cell[2x]</li><li>Right Child - cell[2x+1]</li><li>cell[0] = null </li></ul><br><p><strong>Creation of Binary tree</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createBinaryTree()</span><br><span class="line">  create a blank array of &#39;size&#39;</span><br><span class="line">  update lastUsedIndex to 0</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(1)</li><li>Space Complextiy : O(n)</li></ul><br><p><strong>Insertion of node</strong></p><ul><li>Insertion<ul><li>If array is full, return error message</li><li>Insert at first vacant cell in Array</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insertValueInBinaryTree()</span><br><span class="line">  if Tree is full</span><br><span class="line">    return error message</span><br><span class="line">  else</span><br><span class="line">    insert value in first unused cell of array</span><br><span class="line">    update lastUsedIndex</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(1)</li><li>Space Complextiy : O(1)</li></ul><br><p><strong>Search a node</strong></p><ul><li>Search<ul><li>When the value to be searched does not exists in the tree</li><li>When the value to be searched exists in the tree</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">searchValueInBinaryTree()</span><br><span class="line">  traverse the entire array from 1 to lastUsedIndex</span><br><span class="line">  if value is found</span><br><span class="line">    return success message</span><br><span class="line">  return error message</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(1)</li></ul><br><p><strong>In-Order Traversal</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InorderTraversal(index)</span><br><span class="line">  if index &gt; lastUsedIndex</span><br><span class="line">      return</span><br><span class="line">  else</span><br><span class="line">    InorderTraversal(index*2)</span><br><span class="line">    print current index.value</span><br><span class="line">    InorderTraversal(index*2 + 1)</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(n) —- stack에 쌓이기 때문에</li></ul><br><p><strong>Levle-Order Traversal</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">levelOrderTraversal()</span><br><span class="line">  loop: 1 to lastUsedIndex</span><br><span class="line">    print current index.value</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(1) </li></ul><br><p><strong>Deletion of Node</strong></p><ul><li>Deletion<ul><li>When the value to be deleted is not existing in the tree</li><li>When the value to be deleted is exists in the tree</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeFromBinaryTree()</span><br><span class="line">  search for desired value in array</span><br><span class="line">    if value found</span><br><span class="line">      replace this cell&#39;s value with last cell and update lastUsedIndex</span><br><span class="line">  return error message</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(1) </li></ul><br><p><strong>Delete Binary Tree</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteBinaryTree()</span><br><span class="line">  set array as null</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(1)</li><li>Space Complextiy : O(1) </li></ul><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree implemented by Array&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Code(Linked list)</title>
    <link href="http://jbj828.github.io/2020/02/08/Al-BT-linkedlist-code/"/>
    <id>http://jbj828.github.io/2020/02/08/Al-BT-linkedlist-code/</id>
    <published>2020-02-08T13:30:25.000Z</published>
    <updated>2020-02-08T12:10:30.642Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree code by linked list</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">import node.BinaryNode;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeByLinkedList &#123;</span><br><span class="line">BinaryNode root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor for creating a blank Binary Tree</span><br><span class="line">BinaryTreeByLinkedList()&#123;</span><br><span class="line">this.root &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; inserts a new node at deepest place in Tree</span><br><span class="line">void insert(int value) &#123;</span><br><span class="line">BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">node.setValue(value);</span><br><span class="line">if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">root &#x3D; node;</span><br><span class="line">System.out.println(&quot;Successfully inserted new node at Root !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">presentNode.setLeft(node);</span><br><span class="line">System.out.println(&quot;Successfully inserted new node !&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;else if (presentNode.getRight() &#x3D;&#x3D; null) &#123;</span><br><span class="line">presentNode.setRight(node);</span><br><span class="line">System.out.println(&quot;Successfully inserted new node !&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of else-if</span><br><span class="line">&#125;&#x2F;&#x2F;end of loop</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Search for a given value in binary tree</span><br><span class="line">void search(int value) &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">System.out.println(&quot;Value-&quot;+value+&quot; is found in Tree !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if (presentNode.getLeft()!&#x3D;null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight()!&#x3D;null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of loop</span><br><span class="line">System.out.println(&quot;Value-&quot;+value+&quot; is not found in Tree !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; delete node from binary tree</span><br><span class="line">void deleteNodeOfBinaryTree(int value) &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">&#x2F;&#x2F; if node is found then copy deepest node here and delete deepest node.</span><br><span class="line">if (presentNode.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">presentNode.setValue(getDeepestNode().getValue());</span><br><span class="line">DeleteDeepestNode();</span><br><span class="line">System.out.println(&quot;Deleted the node !!&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of while loop</span><br><span class="line">System.out.println(&quot;Did not find the node!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete deepest node</span><br><span class="line">public void DeleteDeepestNode() &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">BinaryNode previousNode, presentNode &#x3D; null;</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">previousNode &#x3D; presentNode;</span><br><span class="line">presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">previousNode.setRight(null);</span><br><span class="line">return;</span><br><span class="line">&#125;else if ((presentNode.getRight() &#x3D;&#x3D; null)) &#123;</span><br><span class="line">presentNode.setLeft(null);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of while loop</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; get last node of last level of binary tree</span><br><span class="line">public BinaryNode getDeepestNode() &#123;</span><br><span class="line">&#x2F;&#x2F; make an empty queue. Queue is Interface and LinkedList is class</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">BinaryNode presentNode &#x3D; null;</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">return presentNode;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pre-order traversal of binary tree</span><br><span class="line">void preOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">preOrder(node.getLeft());</span><br><span class="line">preOrder(node.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; post-order traversal of binary tree</span><br><span class="line">void postOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">postOrder(node.getLeft());</span><br><span class="line">postOrder(node.getRight());</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; in-order traversal of binary tree</span><br><span class="line">void inOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">inOrder(node.getLeft());</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">inOrder(node.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; level order traversal of binary tree</span><br><span class="line">void levelOrder() &#123;</span><br><span class="line">&#x2F;&#x2F; make a queue for level order. Queue is Interface and LinkedList is class</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">&#125;</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Delete Tree</span><br><span class="line">void deleteTree() &#123;</span><br><span class="line">root &#x3D; null;</span><br><span class="line">System.out.println(&quot;Binary Tree has been deleted successfully&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree code by linked list&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree - Traverse, Search, Insertion,(Linked List Implementation)</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-binaryTreeTraverse/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-binaryTreeTraverse/</id>
    <published>2020-02-06T14:30:25.000Z</published>
    <updated>2020-02-09T12:45:04.868Z</updated>
    
    <content type="html"><![CDATA[<p>Traverse Binary Tree</p><a id="more"></a><h3 id="Traversing-all-nodes-of-Binary-Tree-Linked-List-implementation"><a href="#Traversing-all-nodes-of-Binary-Tree-Linked-List-implementation" class="headerlink" title="Traversing all nodes of Binary Tree(Linked List implementation)"></a>Traversing all nodes of Binary Tree(Linked List implementation)</h3><p><strong>Depth first search</strong></p><ol><li>PreOrder Traversal</li><li>InOrder Traversal</li><li>PostOrder Traversal</li></ol><p><strong>Breadth first search</strong></p><ol><li>LevelOrder Traversal</li></ol><br><h3 id="PreOrder-Traversal-Using-Stack"><a href="#PreOrder-Traversal-Using-Stack" class="headerlink" title="* PreOrder Traversal(Using Stack)"></a>* PreOrder Traversal(Using Stack)</h3><ul><li>Root</li><li>Left Subtree</li><li>Right Subtree</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    print root</span><br><span class="line">    preorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    preorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)  : Recursive call로 많은 노드가 스택에 push, pull 되기 때문에</li></ul><br><h3 id="In-Order-Traversal-Using-Stack"><a href="#In-Order-Traversal-Using-Stack" class="headerlink" title="* In-Order Traversal(Using Stack)"></a>* In-Order Traversal(Using Stack)</h3><ul><li>Left Subtree</li><li>Root</li><li>Right Subtree</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    inorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    print root</span><br><span class="line">    inorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)</li></ul><br><h3 id="Post-Order-Traversal-Using-Stack"><a href="#Post-Order-Traversal-Using-Stack" class="headerlink" title="* Post-Order Traversal(Using Stack)"></a>* Post-Order Traversal(Using Stack)</h3><ul><li>Left Subtree</li><li>Right Subtree</li><li>Root</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    postorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    postorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">    print root</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)</li></ul><br><h3 id="Level-Order-Traversal-Using-Queue"><a href="#Level-Order-Traversal-Using-Queue" class="headerlink" title="* Level-Order Traversal(Using Queue)"></a>* Level-Order Traversal(Using Queue)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">levelOrderTraversal(root)&#123;</span><br><span class="line">  create a Queue(Q)</span><br><span class="line">  enqueue(root)</span><br><span class="line">  while(Queue is not empty)&#123;</span><br><span class="line">    enqueue() the child of the first element</span><br><span class="line">    dequeue() and print</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<p><br><br></p><h3 id="Searching-a-node-Using-Level-order-Traversal"><a href="#Searching-a-node-Using-Level-order-Traversal" class="headerlink" title="* Searching a node(Using Level-order Traversal)"></a>* Searching a node(Using Level-order Traversal)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">searchForGivenValue(value)&#123;</span><br><span class="line">  if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    do a level order traversal</span><br><span class="line">      if value found</span><br><span class="line">        return success message</span><br><span class="line">    return unsuccessful message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<br><h3 id="Insertion-of-node-Using-Level-order-Traversal"><a href="#Insertion-of-node-Using-Level-order-Traversal" class="headerlink" title="* Insertion of node(Using Level-order Traversal)"></a>* Insertion of node(Using Level-order Traversal)</h3><ul><li>Insertion<ul><li>When the root is blank</li><li>Insert at first vacant child</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insertNodeInBinaryTree()&#123;</span><br><span class="line">  if(root is blank)&#123;</span><br><span class="line">    insert new node at root</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    do a level order traversal and find the first blank space</span><br><span class="line">    insert in that blank place</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<br><h3 id="Deletion-of-node-Using-Level-order-Traversal"><a href="#Deletion-of-node-Using-Level-order-Traversal" class="headerlink" title="* Deletion of node(Using Level-order Traversal)"></a>* Deletion of node(Using Level-order Traversal)</h3><ul><li>Insertion<ul><li>When the value to be deleted is not existing in the tree</li><li>When the value to be deleted exists in the tree</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeFromBinaryTree()</span><br><span class="line">  search for the node to be deleted</span><br><span class="line">  find deepest node in the tree(using level order traversal)</span><br><span class="line">  copy deepest node&#39;s data in current node</span><br><span class="line">  delete deepest node</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Traverse Binary Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-binary-tree/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-binary-tree/</id>
    <published>2020-02-06T07:30:25.000Z</published>
    <updated>2020-02-06T14:12:54.625Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree</p><a id="more"></a><p><strong>What is Binary Tree</strong></p><ul><li>A tree is called as binary tree if each node has zero, one or two child.</li><li>It is a family of Data Structure(BST, Heap tree, AVL, Red-Black, Syntax tree, Huffman Coding tree, etc.)</li></ul><p><br><br></p><p><strong>Why should we learn Binary tree</strong></p><ul><li>Prerequisite for more advanced trees</li><li>Is used in solving specific problems like:<ul><li>Huffman Coding</li><li>Heap(Priority Queue)</li><li>Expression parsing</li></ul></li></ul><p><br><Br></p><p><strong>Types of Binary Tree</strong></p><ul><li>Strict Binary Tree : if each node has either 2 children or none.</li><li>Full Binary Tree : if each non leaf node has 2 children and all lead nodes are at same level</li><li>Complete Binary Tree : if all levels are completely filled except possibly the last level and the last level has all keys as left as possible</li></ul><p><br><Br></p><p><strong>Tree Representation</strong></p><ul><li>Using Linked List</li><li>Using Array</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
