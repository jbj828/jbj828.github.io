<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Developer Javit</title>
  
  <subtitle>Slowly and Steadily</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jbj828.github.io/"/>
  <updated>2020-02-08T12:10:30.642Z</updated>
  <id>http://jbj828.github.io/</id>
  
  <author>
    <name>Jay Chung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Binary Tree Code(Linked list)</title>
    <link href="http://jbj828.github.io/2020/02/08/Al-BT-linkedlist-code/"/>
    <id>http://jbj828.github.io/2020/02/08/Al-BT-linkedlist-code/</id>
    <published>2020-02-08T13:30:25.000Z</published>
    <updated>2020-02-08T12:10:30.642Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree code by linked list</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">import node.BinaryNode;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeByLinkedList &#123;</span><br><span class="line">BinaryNode root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor for creating a blank Binary Tree</span><br><span class="line">BinaryTreeByLinkedList()&#123;</span><br><span class="line">this.root &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; inserts a new node at deepest place in Tree</span><br><span class="line">void insert(int value) &#123;</span><br><span class="line">BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">node.setValue(value);</span><br><span class="line">if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">root &#x3D; node;</span><br><span class="line">System.out.println(&quot;Successfully inserted new node at Root !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">presentNode.setLeft(node);</span><br><span class="line">System.out.println(&quot;Successfully inserted new node !&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;else if (presentNode.getRight() &#x3D;&#x3D; null) &#123;</span><br><span class="line">presentNode.setRight(node);</span><br><span class="line">System.out.println(&quot;Successfully inserted new node !&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of else-if</span><br><span class="line">&#125;&#x2F;&#x2F;end of loop</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Search for a given value in binary tree</span><br><span class="line">void search(int value) &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">System.out.println(&quot;Value-&quot;+value+&quot; is found in Tree !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if (presentNode.getLeft()!&#x3D;null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight()!&#x3D;null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of loop</span><br><span class="line">System.out.println(&quot;Value-&quot;+value+&quot; is not found in Tree !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; delete node from binary tree</span><br><span class="line">void deleteNodeOfBinaryTree(int value) &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">&#x2F;&#x2F; if node is found then copy deepest node here and delete deepest node.</span><br><span class="line">if (presentNode.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">presentNode.setValue(getDeepestNode().getValue());</span><br><span class="line">DeleteDeepestNode();</span><br><span class="line">System.out.println(&quot;Deleted the node !!&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of while loop</span><br><span class="line">System.out.println(&quot;Did not find the node!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete deepest node</span><br><span class="line">public void DeleteDeepestNode() &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">BinaryNode previousNode, presentNode &#x3D; null;</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">previousNode &#x3D; presentNode;</span><br><span class="line">presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">previousNode.setRight(null);</span><br><span class="line">return;</span><br><span class="line">&#125;else if ((presentNode.getRight() &#x3D;&#x3D; null)) &#123;</span><br><span class="line">presentNode.setLeft(null);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of while loop</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; get last node of last level of binary tree</span><br><span class="line">public BinaryNode getDeepestNode() &#123;</span><br><span class="line">&#x2F;&#x2F; make an empty queue. Queue is Interface and LinkedList is class</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">BinaryNode presentNode &#x3D; null;</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">return presentNode;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pre-order traversal of binary tree</span><br><span class="line">void preOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">preOrder(node.getLeft());</span><br><span class="line">preOrder(node.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; post-order traversal of binary tree</span><br><span class="line">void postOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">postOrder(node.getLeft());</span><br><span class="line">postOrder(node.getRight());</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; in-order traversal of binary tree</span><br><span class="line">void inOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">inOrder(node.getLeft());</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">inOrder(node.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; level order traversal of binary tree</span><br><span class="line">void levelOrder() &#123;</span><br><span class="line">&#x2F;&#x2F; make a queue for level order. Queue is Interface and LinkedList is class</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">&#125;</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Delete Tree</span><br><span class="line">void deleteTree() &#123;</span><br><span class="line">root &#x3D; null;</span><br><span class="line">System.out.println(&quot;Binary Tree has been deleted successfully&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree code by linked list&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree - Traverse, Search, Insertion,(Linked List Implementation)</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-binaryTreeTraverse/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-binaryTreeTraverse/</id>
    <published>2020-02-06T14:30:25.000Z</published>
    <updated>2020-02-07T03:18:34.663Z</updated>
    
    <content type="html"><![CDATA[<p>Traverse Binary Tree</p><a id="more"></a><h3 id="Traversing-all-nodes-of-Binary-Tree-Linked-List-implementation"><a href="#Traversing-all-nodes-of-Binary-Tree-Linked-List-implementation" class="headerlink" title="Traversing all nodes of Binary Tree(Linked List implementation)"></a>Traversing all nodes of Binary Tree(Linked List implementation)</h3><p><strong>Depth first search</strong></p><ol><li>PreOrder Traversal</li><li>InOrder Traversal</li><li>PostOrder Traversal</li></ol><p><strong>Breadth first search</strong></p><ol><li>LevelOrder Traversal</li></ol><br><h3 id="PreOrder-Traversal-Using-Stack"><a href="#PreOrder-Traversal-Using-Stack" class="headerlink" title="* PreOrder Traversal(Using Stack)"></a>* PreOrder Traversal(Using Stack)</h3><ul><li>Root</li><li>Left Subtree</li><li>Right Subtree</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    print root</span><br><span class="line">    preorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    preorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)  : Recursive call로 많은 노드가 스택에 push, pull 되기 때문에</li></ul><br><h3 id="In-Order-Traversal-Using-Stack"><a href="#In-Order-Traversal-Using-Stack" class="headerlink" title="* In-Order Traversal(Using Stack)"></a>* In-Order Traversal(Using Stack)</h3><ul><li>Left Subtree</li><li>Root</li><li>Right Subtree</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    inorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    print root</span><br><span class="line">    inorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)</li></ul><br><h3 id="Post-Order-Traversal-Using-Stack"><a href="#Post-Order-Traversal-Using-Stack" class="headerlink" title="* Post-Order Traversal(Using Stack)"></a>* Post-Order Traversal(Using Stack)</h3><ul><li>Left Subtree</li><li>Right Subtree</li><li>Root</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    postorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    postorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">    print root</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)</li></ul><br><h3 id="Level-Order-Traversal-Using-Queue"><a href="#Level-Order-Traversal-Using-Queue" class="headerlink" title="* Level-Order Traversal(Using Queue)"></a>* Level-Order Traversal(Using Queue)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">levelOrderTraversal(root)&#123;</span><br><span class="line">  create a Queue(Q)</span><br><span class="line">  enqueue(root)</span><br><span class="line">  while(Queue is not empty)&#123;</span><br><span class="line">    enqueue() the child of the first element</span><br><span class="line">    dequeue() and print</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<p><br><br></p><h3 id="Searching-a-node-Using-Level-order-Traversal"><a href="#Searching-a-node-Using-Level-order-Traversal" class="headerlink" title="* Searching a node(Using Level-order Traversal)"></a>* Searching a node(Using Level-order Traversal)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">searchForGivenValue(value)&#123;</span><br><span class="line">  if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    do a level order traversal</span><br><span class="line">      if value found</span><br><span class="line">        return success message</span><br><span class="line">    return unsuccessful message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<br><h3 id="Insertion-of-node-Using-Level-order-Traversal"><a href="#Insertion-of-node-Using-Level-order-Traversal" class="headerlink" title="* Insertion of node(Using Level-order Traversal)"></a>* Insertion of node(Using Level-order Traversal)</h3><ul><li>Insertion<ul><li>When the root is blank</li><li>Insert at first vacant child</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insertNodeInBinaryTree()&#123;</span><br><span class="line">  if(root is blank)&#123;</span><br><span class="line">    insert new node at root</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    do a level order traversal and find the first blank space</span><br><span class="line">    insert in that blank place</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<br><h3 id="Deletion-of-node-Using-Level-order-Traversal"><a href="#Deletion-of-node-Using-Level-order-Traversal" class="headerlink" title="* Deletion of node(Using Level-order Traversal)"></a>* Deletion of node(Using Level-order Traversal)</h3><ul><li>Insertion<ul><li>When the value to be deleted is not existing in the tree</li><li>When the value to be deleted exists in the tree</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeFromBinaryTree()</span><br><span class="line">  search for the node to be deleted</span><br><span class="line">  find deepest node in the tree(using level order traversal)</span><br><span class="line">  copy deepest node&#39;s data in current node</span><br><span class="line">  delete deepest node</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Traverse Binary Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-binary-tree/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-binary-tree/</id>
    <published>2020-02-06T07:30:25.000Z</published>
    <updated>2020-02-06T14:12:54.625Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree</p><a id="more"></a><p><strong>What is Binary Tree</strong></p><ul><li>A tree is called as binary tree if each node has zero, one or two child.</li><li>It is a family of Data Structure(BST, Heap tree, AVL, Red-Black, Syntax tree, Huffman Coding tree, etc.)</li></ul><p><br><br></p><p><strong>Why should we learn Binary tree</strong></p><ul><li>Prerequisite for more advanced trees</li><li>Is used in solving specific problems like:<ul><li>Huffman Coding</li><li>Heap(Priority Queue)</li><li>Expression parsing</li></ul></li></ul><p><br><Br></p><p><strong>Types of Binary Tree</strong></p><ul><li>Strict Binary Tree : if each node has either 2 children or none.</li><li>Full Binary Tree : if each non leaf node has 2 children and all lead nodes are at same level</li><li>Complete Binary Tree : if all levels are completely filled except possibly the last level and the last level has all keys as left as possible</li></ul><p><br><Br></p><p><strong>Tree Representation</strong></p><ul><li>Using Linked List</li><li>Using Array</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Tree</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-tree/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-tree/</id>
    <published>2020-02-06T06:30:25.000Z</published>
    <updated>2020-02-06T13:59:34.402Z</updated>
    
    <content type="html"><![CDATA[<p>Tree Data Structure</p><a id="more"></a><p><strong>Properties of Tree</strong></p><ul><li>Used to represent data in hierarchical form</li><li>Every Node(ideally) has 2 components(Data &amp; Reference)</li><li>It has a Root node and 2 disjoint binary tree called left subtree and right subtree</li></ul><p><br><br></p><p><strong>Why we learn Tree?</strong></p><ul><li>Linked List is better in space efficiency over Array. However, Linked List does not have that good time efficiency on Insertion, Deletion and Searching which is O(n). </li><li>Tree data structure overcomes the problem of linked list.</li></ul><p><br><br></p><p><strong>Tree Terminologies</strong></p><ul><li>Root : Node with no parent</li><li>Edge : Link from parent to child</li><li>Leaf : Node with no children</li><li>Sibling : Children of same parent</li><li>Ancestor : means parent, grand-parent, great grand parent, and so on for a given node</li><li>Depth of node : Length of the path from root to node</li><li>Height of node : Length of the path from that node to the deepest node</li><li>Height of tree : Same as height of Root node</li><li>Predecessor : Predecessor of a node is the immediate previous node in Inorder traversal of the Binary Tree.</li><li>Successor : Successor of a node is the immediate next node in Inorder traversal of the Binary Tree.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tree Data Structure&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Circular Queue(Array) / Linear Queue(Linked List)</title>
    <link href="http://jbj828.github.io/2020/02/05/Al-CircularQueue/"/>
    <id>http://jbj828.github.io/2020/02/05/Al-CircularQueue/</id>
    <published>2020-02-05T03:30:25.000Z</published>
    <updated>2020-02-06T13:59:57.474Z</updated>
    
    <content type="html"><![CDATA[<p>Queue</p><a id="more"></a><p><strong>Why learn Circular Queue?</strong></p><ul><li>dequeue operation causes blank cells Linear Queue(Array Implementation). </li><li>삭제하고 남은 자리를 뒤에서부터 차례대로 채워넣으면 되지만 time complexity가 O(n)이 되어버린다. 우리의 목표는 항상 O(1)이다.</li></ul><p><br><br></p><p><strong>time / space complexity</strong></p><ul><li>Array는 만들 때 space complexity가 O(n) 나머지 메서드는 모두 O(1)</li><li>Linked List는 모든 메서드 O(1)<br>그러므로 Queue를 사용하고자 한다면 Linked List가 Space Complexity에서 낫기 때문에 Linked List사용하도록 한다</li></ul><p><br><br></p><p><strong>When to Use / Avoid Queue</strong></p><ul><li><p>When to Use</p><ul><li>Helps manage the data in particular way(FIFO)</li><li>Not easily corrupted(No one can easily insert data in middle)<br></li></ul></li><li><p>When to Avoid</p><ul><li>Random access not possible - if we have done some mistake, it is costly to rectify</li></ul></li></ul><p><br><br></p><p><strong>Circular Queue Coding</strong></p><p>CircularQueueByArray.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">public class CircularQueueByArray&#123;</span><br><span class="line"></span><br><span class="line">int[] arr;</span><br><span class="line">int topOfQueue;</span><br><span class="line">int size;</span><br><span class="line">int start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public CircularQueueByArray(int size) &#123;</span><br><span class="line">this.arr &#x3D; new int[size];</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">this.topOfQueue &#x3D; -1;</span><br><span class="line">start &#x3D; -1;</span><br><span class="line">System.out.println(&quot;Successfully created an empty queue of size: &quot;+size);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void enQueue(int value) &#123;</span><br><span class="line">if(arr&#x3D;&#x3D;null) &#123;</span><br><span class="line">System.out.println(&quot;Array is not yet created. Please create one first.&quot;);</span><br><span class="line">&#125;else if (isQueueFull()) &#123;</span><br><span class="line">System.out.println(&quot;\nQueue overflow error!!&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">initializeStartOfArray();</span><br><span class="line">if (topOfQueue+1 &#x3D;&#x3D; size) &#123; &#x2F;&#x2F;if top is already at last cell of array, then reset it to first cell</span><br><span class="line">topOfQueue&#x3D;0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">topOfQueue++;</span><br><span class="line">&#125;</span><br><span class="line">arr[topOfQueue] &#x3D; value;</span><br><span class="line">System.out.println(&quot;\nSuccessfully inserted &quot;+value+&quot; in the queue&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void initializeStartOfArray() &#123;</span><br><span class="line">if (start &#x3D;&#x3D; -1) &#123; </span><br><span class="line">start &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deQueue() &#123;</span><br><span class="line">if (isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Queue underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;\n---------------------------------------------&quot;);</span><br><span class="line">System.out.println(&quot;Before Dequeue..&quot;);printArray();</span><br><span class="line">System.out.println(&quot;\nDequeing value from Queue...&quot;);</span><br><span class="line">System.out.println(&quot;Dequeued: &quot;+arr[start]+&quot; from queue&quot;);</span><br><span class="line">arr[start] &#x3D; 0; &#x2F;&#x2F;initialize the unused cell to 0</span><br><span class="line">if (start &#x3D;&#x3D; topOfQueue) &#123; &#x2F;&#x2F;if there is only 1 element in Queue</span><br><span class="line">start &#x3D; topOfQueue &#x3D; -1;</span><br><span class="line">&#125;else if (start+1 &#x3D;&#x3D; size) &#123; &#x2F;&#x2F;if start has reached end of array, then start again from 0</span><br><span class="line">start&#x3D;0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;After Dequeue..&quot;);printArray();</span><br><span class="line">System.out.println(&quot;---------------------------------------------&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueEmpty() &#123;</span><br><span class="line">if (topOfQueue &#x3D;&#x3D; -1)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueFull() &#123;</span><br><span class="line">if (topOfQueue+1 &#x3D;&#x3D; start) &#123; &#x2F;&#x2F;If we have completed a circle, then we can say that Queue is full</span><br><span class="line">return true;</span><br><span class="line">&#125;else if ((start&#x3D;&#x3D;0) &amp;&amp; (topOfQueue+1 &#x3D;&#x3D; size)) &#123; &#x2F;&#x2F;Trivial case of Queue being full</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void peekOperation() &#123;</span><br><span class="line">&#x2F;&#x2F;if stack is not empty, return the value on top of stack</span><br><span class="line">if (!isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;\nPeeking value from queue...&quot;);</span><br><span class="line">System.out.println(arr[start]); </span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;The queue is empty!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteStack() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting the entire Queue...&quot;);</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Queue is successfully deleted !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Print entire array</span><br><span class="line">public void printArray() &#123;</span><br><span class="line">System.out.println(&quot;Array now...&quot;);</span><br><span class="line">for(int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">System.out.print(arr[i]+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\nStart &#x3D; &quot; + start);</span><br><span class="line">System.out.println(&quot;End &#x3D; &quot;+ topOfQueue);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><p><br><br></p><p>QueueByLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import linkedList.SingleLinkedList;</span><br><span class="line"></span><br><span class="line">public class QueueByLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    SingleLinkedList list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;constructor</span><br><span class="line">    public QueueByLinkedList() &#123;</span><br><span class="line">        list &#x3D; new SingleLinkedList();</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void enQueue(int value) &#123;</span><br><span class="line">        if (list.getHead() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            list.createSingleLinkedList(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; push a value on last of queue, update list tail too</span><br><span class="line">            list.insertInLinkedList(value, list.getSize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int deQueue() &#123;</span><br><span class="line">        int value &#x3D; -1;</span><br><span class="line">        if (isQueueEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;Queue underflow error!!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            value &#x3D; list.getHead().getValue();</span><br><span class="line">            list.deletionOfNode(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        if (!isQueueEmpty())</span><br><span class="line">            return list.getHead().getValue();</span><br><span class="line">        else &#123;</span><br><span class="line">            System.out.println(&quot;The queue is empty!!&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean isQueueEmpty() &#123;</span><br><span class="line">        if (list.getHead() &#x3D;&#x3D; null)</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void deleteStack() &#123;</span><br><span class="line">        list.setHead(null);</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Queue&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Queue</title>
    <link href="http://jbj828.github.io/2020/02/05/Al-Queue/"/>
    <id>http://jbj828.github.io/2020/02/05/Al-Queue/</id>
    <published>2020-02-05T01:30:25.000Z</published>
    <updated>2020-02-06T14:17:15.456Z</updated>
    
    <content type="html"><![CDATA[<p>Queue</p><a id="more"></a><p><strong>What is a Queue?</strong></p><ul><li><p>Property of Queue</p><ul><li>follows FIFO(First In First Out) method</li></ul></li><li><p>Reason why learning</p><ul><li>When we need to create an application which utilizes “first incoming data first”.</li></ul></li></ul><p><br><br></p><p><strong>Implementation options of Queue</strong></p><ul><li>Array<ul><li>Linear Queue</li><li>Circular Queue</li></ul></li></ul><br><ul><li>Linked list<ul><li>Linear Queue</li></ul></li></ul><p><br><br></p><p><strong>Linear Queue by Array</strong><br><br></p><p>QueueByArray.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">public class QueueByArray&#123;</span><br><span class="line"></span><br><span class="line">int[] arr;</span><br><span class="line">int topOfQueue;</span><br><span class="line">int beginningOfQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public QueueByArray(int size) &#123;</span><br><span class="line">this.arr &#x3D; new int[size];</span><br><span class="line">this.topOfQueue &#x3D; -1;</span><br><span class="line">this.beginningOfQueue &#x3D; -1;</span><br><span class="line">System.out.println(&quot;Successfully created an empty queue of size: &quot;+size);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void enQueue(int value) &#123;</span><br><span class="line">if (isQueueFull()) &#123;</span><br><span class="line">System.out.println(&quot;Queue overflow error!!&quot;);</span><br><span class="line">&#125;else if (isQueueEmpty()) &#123; &#x2F;&#x2F;If the queue is empty then we need to initialize beginning index </span><br><span class="line">beginningOfQueue&#x3D;0;</span><br><span class="line">topOfQueue++;</span><br><span class="line">arr[topOfQueue] &#x3D; value;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot;+value+&quot; in the queue&quot;);</span><br><span class="line">&#125;else &#123; &#x2F;&#x2F;if the queue already has some elements in it then no need to initialize beginning index</span><br><span class="line">topOfQueue++;</span><br><span class="line">arr[topOfQueue] &#x3D; value;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot;+value+&quot; in the queue&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printQueue();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void printQueue() &#123;</span><br><span class="line">if(!isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Queue now ...&quot;);</span><br><span class="line">for(int i&#x3D;beginningOfQueue; i&lt;&#x3D;topOfQueue; i++) &#123;</span><br><span class="line">System.out.println(arr[i] + &quot;   &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Queue is empty !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void deQueue() &#123;</span><br><span class="line">if (isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Queue underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Dequeing value from Queue...&quot;);</span><br><span class="line">System.out.println(&quot;Dequeued: &quot;+arr[beginningOfQueue]+&quot; from queue&quot;);</span><br><span class="line">beginningOfQueue++;</span><br><span class="line">if(beginningOfQueue &gt; topOfQueue) &#123; &#x2F;&#x2F;If last element in the Queue is Dequeued</span><br><span class="line">beginningOfQueue &#x3D; topOfQueue &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printQueue();</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueEmpty() &#123;</span><br><span class="line">if ((beginningOfQueue &#x3D;&#x3D; -1) || (beginningOfQueue &#x3D;&#x3D; arr.length))</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueFull() &#123;</span><br><span class="line">if (topOfQueue &#x3D;&#x3D; arr.length-1) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void peekOperation() &#123;</span><br><span class="line">if (!isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(arr[beginningOfQueue]); </span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;The queue is empty!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteQueue() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Queue is successfully deleted !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Queue&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Stack</title>
    <link href="http://jbj828.github.io/2020/02/04/Stack/"/>
    <id>http://jbj828.github.io/2020/02/04/Stack/</id>
    <published>2020-02-04T02:30:25.000Z</published>
    <updated>2020-02-06T13:59:45.266Z</updated>
    
    <content type="html"><![CDATA[<p>Stack data structure</p><a id="more"></a><p><strong>Implementation options of Stack</strong></p><ul><li>Array<ul><li>pros : Easy to implement</li><li>cons : Fixed size</li></ul></li></ul><br><ul><li>Linked List<ul><li>pros : Variable size</li><li>cons : Moderate in implementation</li></ul></li></ul><br><br><p><strong>When to use / avoid Stack</strong><br><br></p><ul><li>When to use<ul><li>Helps manage the data in particular way(LIFO)</li><li>Cannnot be easily corrupted(No one can insert data in middle)<br></li></ul></li><li>When to avoid<ul><li>Random access not possible - if we have done some mistake, its costly to rectify.</li></ul></li></ul><p><br><br></p><p><strong>Stack By Array</strong></p><ul><li>StackByArray.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class StackByArray &#123;</span><br><span class="line"></span><br><span class="line">int[] arr;</span><br><span class="line">int topOfStack;&#x2F;&#x2F;keeps track of the cell which is last occupied in Array, this will help in insertion&#x2F;deletion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public StackByArray(int size) &#123;</span><br><span class="line">this.arr &#x3D; new int[size];</span><br><span class="line">this.topOfStack &#x3D; -1;</span><br><span class="line">System.out.println(&quot;Successfully created an empty Stack of Size: &quot;+size);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void push(int value) &#123;</span><br><span class="line">&#x2F;&#x2F;if array is full, show stack overflow error</span><br><span class="line">if (isFullStack()) &#123;</span><br><span class="line">System.out.println(&quot;Stack overflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">arr[topOfStack+1] &#x3D; value;</span><br><span class="line">topOfStack++;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + value + &quot; in the stack&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void pop() &#123;</span><br><span class="line">&#x2F;&#x2F;if array is empty, show stack underflow error</span><br><span class="line">if (isEmptyStack()) &#123;</span><br><span class="line">System.out.println(&quot;Stack underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Poping value from Stack: &quot; + arr[topOfStack] + &quot;...&quot;);</span><br><span class="line">topOfStack--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isEmptyStack() &#123;</span><br><span class="line">&#x2F;&#x2F;if top pointer is zero, the stack is empty</span><br><span class="line">if (topOfStack &#x3D;&#x3D; -1)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isFullStack() &#123;</span><br><span class="line">if (topOfStack &#x3D;&#x3D; arr.length-1) &#123;</span><br><span class="line">System.out.println(&quot;Stack is full !&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void peekOperation() &#123;</span><br><span class="line">if (!isEmptyStack())</span><br><span class="line">System.out.println(&quot;Top of Stack: &quot; + arr[topOfStack]);</span><br><span class="line">else &#123;</span><br><span class="line">System.out.println(&quot;The stack is empty!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();System.out.println();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteStack() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Stack is successfully deleted&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure></li></ul><p><br><br></p><p><strong>Stack By Linked List</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">import linkedList.SingleLinkedList;</span><br><span class="line"></span><br><span class="line">public class StackByLinkedList &#123;</span><br><span class="line"></span><br><span class="line">SingleLinkedList list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;constructor</span><br><span class="line">public  StackByLinkedList() &#123;</span><br><span class="line">list &#x3D; new SingleLinkedList();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void push(int value) &#123;</span><br><span class="line">if(list.getHead()&#x3D;&#x3D; null) &#123;</span><br><span class="line">list.createSingleLinkedList(value);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">list.insertInLinkedList(value, 0);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Inserted &quot; + value + &quot; in Stack !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int pop() &#123;</span><br><span class="line">int value &#x3D; -1;</span><br><span class="line">if (isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Stack underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">value &#x3D; list.getHead().getValue();</span><br><span class="line">list.deletionOfNode(0);</span><br><span class="line">&#125;</span><br><span class="line">return value;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">if (list.getHead() &#x3D;&#x3D; null)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int peek() &#123;</span><br><span class="line">if (!isEmpty())</span><br><span class="line">return list.getHead().getValue();</span><br><span class="line">else &#123;</span><br><span class="line">System.out.println(&quot;The stack is empty!!&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteStack() &#123;</span><br><span class="line">list.setHead(null);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Stack data structure&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Circular Double Linked List</title>
    <link href="http://jbj828.github.io/2020/02/03/Al-circularDoubleLinkedList/"/>
    <id>http://jbj828.github.io/2020/02/03/Al-circularDoubleLinkedList/</id>
    <published>2020-02-03T02:30:25.000Z</published>
    <updated>2020-02-03T02:19:49.566Z</updated>
    
    <content type="html"><![CDATA[<p>The method which could be applied to Circular Double Linked List</p><a id="more"></a><p>DoubleCircularLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">package com.chung</span><br><span class="line"></span><br><span class="line">public class DoubleCircularLinkedList &#123;</span><br><span class="line">private DoubleNode head;</span><br><span class="line">private DoubleNode tail;</span><br><span class="line">private int size;&#x2F;&#x2F; denotes size of list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSize(int size) &#123;</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DoubleNode createDoubleLinkedList(int nodeValue) &#123;</span><br><span class="line">head &#x3D; new DoubleNode();</span><br><span class="line">DoubleNode node &#x3D; new DoubleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">node.setNext(node);</span><br><span class="line">node.setPrev(node);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">tail &#x3D; node;</span><br><span class="line">size &#x3D; 1;&#x2F;&#x2F; size &#x3D;1</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DoubleNode getHead() &#123;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHead(DoubleNode head) &#123;</span><br><span class="line">this.head &#x3D; head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DoubleNode getTail() &#123;</span><br><span class="line">return tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTail(DoubleNode tail) &#123;</span><br><span class="line">this.tail &#x3D; tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getLast() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLast(int last) &#123;</span><br><span class="line">this.size &#x3D; last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertInLinkedList(int nodeValue, int location) &#123;</span><br><span class="line">DoubleNode node &#x3D; new DoubleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);</span><br><span class="line">return; &#x2F;&#x2F; Linked List does not exists</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; insert at first position</span><br><span class="line">node.setNext(head);</span><br><span class="line">node.setPrev(tail);</span><br><span class="line">head.setPrev(node);</span><br><span class="line">tail.setNext(node);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">&#125; else if (location &gt;&#x3D; size) &#123; &#x2F;&#x2F; insert at last position</span><br><span class="line">node.setNext(head);</span><br><span class="line">node.setPrev(tail);</span><br><span class="line">head.setPrev(node);</span><br><span class="line">tail.setNext(node);</span><br><span class="line">tail &#x3D; node; &#x2F;&#x2F; to keep track of last node</span><br><span class="line">&#125; else &#123;&#x2F;&#x2F; insert at specified location</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">while (index &lt; location - 1) &#123;&#x2F;&#x2F; loop till we reach specified node</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">node.setPrev(tempNode);</span><br><span class="line">node.setNext(tempNode.getNext());</span><br><span class="line">tempNode.setNext(node);</span><br><span class="line">node.getNext().setPrev(node);</span><br><span class="line">&#125;</span><br><span class="line">size++;&#x2F;&#x2F; one node added so size increments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean existsLinkedList() &#123;</span><br><span class="line">&#x2F;&#x2F; if head is not null retrun true otherwise return false</span><br><span class="line">return head !&#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Traverse Linked List</span><br><span class="line">void traverseLinkedList() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if (i !&#x3D; size - 1) &#123;</span><br><span class="line">System.out.print(&quot; -&gt; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse Linked List reverse order</span><br><span class="line">void traverseLinkedListInReverseOrder() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode &#x3D; tail;</span><br><span class="line">System.out.println(&quot;\nPrinting Linked list in reverse order...&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if (i !&#x3D; size-1) &#123;</span><br><span class="line">System.out.print(&quot; &lt;- &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getPrev();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse Linked List</span><br><span class="line">void printHeadUsingTail() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;\n\nPrinting Tail...&quot;);</span><br><span class="line">System.out.println(tail.getValue());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nPrinting Head using Head reference...&quot;);</span><br><span class="line">System.out.println(head.getValue());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nPrinting Head using Tail reference...&quot;);</span><br><span class="line">System.out.println(tail.getNext().getValue());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Deletion of linked list</span><br><span class="line">void deleteLinkedList() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting Linked List...&quot;);</span><br><span class="line">if (tail &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;Linked List is already deleted, nothing to delete anymore !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">head.setPrev(null);</span><br><span class="line">tail.setNext(null);</span><br><span class="line">head &#x3D; null;</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">System.out.println(&quot;Linked List deleted successfully !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Searching a specified value in linked list</span><br><span class="line">boolean searchNode(int nodeValue) &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">traverseLinkedList();</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">if (tempNode.getValue() &#x3D;&#x3D; nodeValue) &#123;</span><br><span class="line">System.out.print(&quot;Found the node at location: &quot; + i);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;Node not found!! &quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deletes a node having a given value</span><br><span class="line">public void deletionOfNode(int location) &#123;</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);&#x2F;&#x2F; Linked List does not exists</span><br><span class="line">return;</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; we want to delete first element</span><br><span class="line">if (getSize() &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; if this is the only node in this list</span><br><span class="line">head.setNext(null);</span><br><span class="line">head.setPrev(null);</span><br><span class="line">head &#x3D; tail &#x3D; null;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">head &#x3D; head.getNext();</span><br><span class="line">head.setPrev(null);</span><br><span class="line">tail.setNext(head);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (location &gt;&#x3D; getSize()) &#123; &#x2F;&#x2F; If location is not in range or equal, then delete last node</span><br><span class="line">if (getSize() &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; if this is the only element in the list</span><br><span class="line">head.setNext(null);</span><br><span class="line">head.setPrev(null);</span><br><span class="line">tail &#x3D; head &#x3D; null;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">tail &#x3D; tail.getPrev();</span><br><span class="line">tail.setNext(head);</span><br><span class="line">head.setPrev(tail);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F; if any inside node is to be deleted</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; location - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F; we need to traverse till we find the location</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(tempNode.getNext().getNext()); &#x2F;&#x2F; delete the required node</span><br><span class="line">tempNode.getNext().setPrev(tempNode);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125; &#x2F;&#x2F; end of else</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><p>DoubleNode.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class DoubleNode &#123;</span><br><span class="line"></span><br><span class="line">    private int value;</span><br><span class="line">    private DoubleNode prev;</span><br><span class="line">    private DoubleNode next;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DoubleNode getPrev() &#123;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrev(DoubleNode prev) &#123;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DoubleNode getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(DoubleNode next) &#123;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return value + &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The method which could be applied to Circular Double Linked List&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Double Linked List</title>
    <link href="http://jbj828.github.io/2020/02/02/DoubleLinkedList/"/>
    <id>http://jbj828.github.io/2020/02/02/DoubleLinkedList/</id>
    <published>2020-02-02T14:46:25.000Z</published>
    <updated>2020-02-02T14:39:12.132Z</updated>
    
    <content type="html"><![CDATA[<p>The method which could be applied to Double Linked List</p><a id="more"></a><p>DoubleLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedList &#123;</span><br><span class="line">DoubleNode head;</span><br><span class="line">DoubleNode tail;</span><br><span class="line">int size;&#x2F;&#x2F;denotes size of list</span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSize(int size) &#123;</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DoubleNode createDoubleLinkedList(int nodeValue) &#123;</span><br><span class="line">head &#x3D; new DoubleNode();</span><br><span class="line">DoubleNode node &#x3D; new DoubleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">node.setNext(null);</span><br><span class="line">node.setPrev(null);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">tail &#x3D; node;</span><br><span class="line">size&#x3D;1;&#x2F;&#x2F; size &#x3D;1</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void insertInLinkedList(int nodeValue, int location) &#123;</span><br><span class="line">DoubleNode node &#x3D; new DoubleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);</span><br><span class="line">return; &#x2F;&#x2F; Linked List does not exists</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; insert at first position</span><br><span class="line">node.setNext(head);</span><br><span class="line">node.setPrev(null);</span><br><span class="line">head.setPrev(node);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">&#125; else if (location &gt;&#x3D; size) &#123;&#x2F;&#x2F; insert at last position</span><br><span class="line">node.setNext(null);</span><br><span class="line">tail.setNext(node);</span><br><span class="line">node.setPrev(tail);</span><br><span class="line">tail &#x3D; node; &#x2F;&#x2F; to keep track of last node</span><br><span class="line">&#125; else &#123;&#x2F;&#x2F; insert at specified location</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">while (index &lt; location - 1) &#123;&#x2F;&#x2F; loop till we reach specified node</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">node.setPrev(tempNode);</span><br><span class="line">node.setNext(tempNode.getNext());</span><br><span class="line">tempNode.setNext(node);</span><br><span class="line">node.getNext().setPrev(node);</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean existsLinkedList() &#123;</span><br><span class="line">&#x2F;&#x2F;if head is not null retrun true otherwise return false</span><br><span class="line">return head!&#x3D;null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Traverse the linked list from head to last</span><br><span class="line">void traverseLinkedList() &#123;</span><br><span class="line">if(existsLinkedList()) &#123;</span><br><span class="line">&#x2F;&#x2F;System.out.println(&quot;Linked List now: &quot;);</span><br><span class="line">DoubleNode tempNode&#x3D;head;</span><br><span class="line">for(int i &#x3D;0; i&lt;size;i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if(i!&#x3D;size-1) &#123;</span><br><span class="line">System.out.print(&quot; -&gt; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode&#x3D;tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse the linked list from head to last</span><br><span class="line">void traverseLinkedListInReverseOrder() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode &#x3D; tail;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if (i !&#x3D; size-1) &#123;</span><br><span class="line">System.out.print(&quot; &lt;- &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getPrev();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;delete whole linked list</span><br><span class="line">void deleteLinkedList() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting Linked List...&quot;);</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">tempNode.setPrev(null);</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head &#x3D; null;</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">System.out.println(&quot;Linked List deleted successfully !&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Search for a node in linked list </span><br><span class="line">boolean searchNode(int nodeValue) &#123;</span><br><span class="line">if(existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode&#x3D;head;</span><br><span class="line">for(int i &#x3D;0; i&lt;size;i++) &#123;</span><br><span class="line">if(tempNode.getValue()&#x3D;&#x3D;nodeValue) &#123;</span><br><span class="line">System.out.print(&quot;Found the node at locaiton: &quot; + i);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">tempNode&#x3D;tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;Node not found!! &quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deletes a node having a given value</span><br><span class="line">public void deletionOfNode(int location) &#123;</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);&#x2F;&#x2F; Linked List does not exists</span><br><span class="line">return;</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; we want to delete first element</span><br><span class="line">if (getSize() &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; if this is the only node in this list</span><br><span class="line">head &#x3D; tail &#x3D; null;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">head &#x3D; head.getNext();</span><br><span class="line">head.setPrev(null);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (location &gt;&#x3D; getSize()) &#123; &#x2F;&#x2F; If location is not in range or equal, then delete last node</span><br><span class="line">DoubleNode tempNode &#x3D; tail.getPrev(); &#x2F;&#x2F; temp node points to 2nd last node</span><br><span class="line">if (tempNode &#x3D;&#x3D; head) &#123; &#x2F;&#x2F; if this is the only element in the list</span><br><span class="line">tail &#x3D; head &#x3D; null;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(null);</span><br><span class="line">tail &#x3D; tempNode;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line"></span><br><span class="line">&#125; else &#123; &#x2F;&#x2F; if any inside node is to be deleted</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; location - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F; we need to traverse till we find the location</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(tempNode.getNext().getNext()); &#x2F;&#x2F; delete the required node</span><br><span class="line">tempNode.getNext().setPrev(tempNode);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125; &#x2F;&#x2F; end of else</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><p>DoubleNode.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class DoubleNode &#123;</span><br><span class="line"></span><br><span class="line">    private int value;</span><br><span class="line">    private DoubleNode prev;</span><br><span class="line">    private DoubleNode next;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DoubleNode getPrev() &#123;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrev(DoubleNode prev) &#123;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DoubleNode getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(DoubleNode next) &#123;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return value + &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The method which could be applied to Double Linked List&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Circular Single Linked List</title>
    <link href="http://jbj828.github.io/2020/02/02/CircularSingleLinkedList/"/>
    <id>http://jbj828.github.io/2020/02/02/CircularSingleLinkedList/</id>
    <published>2020-02-02T06:46:25.000Z</published>
    <updated>2020-02-02T06:42:52.699Z</updated>
    
    <content type="html"><![CDATA[<p>The method which could be applied to Circular Single Linked List</p><a id="more"></a><p>SingleCircularLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class SingleCircularLinkedList &#123;</span><br><span class="line">private SingleNode head;</span><br><span class="line">private SingleNode tail;</span><br><span class="line">private int size;&#x2F;&#x2F; denotes size of list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SingleNode createSingleLinkedList(int nodeValue) &#123;</span><br><span class="line">head &#x3D; new SingleNode();</span><br><span class="line">SingleNode node &#x3D; new SingleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">node.setNext(node);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">tail &#x3D; node;</span><br><span class="line">size &#x3D; 1;&#x2F;&#x2F; size &#x3D;1</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SingleNode getHead() &#123;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHead(SingleNode head) &#123;</span><br><span class="line">this.head &#x3D; head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SingleNode getTail() &#123;</span><br><span class="line">return tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTail(SingleNode tail) &#123;</span><br><span class="line">this.tail &#x3D; tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSize(int size) &#123;</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertInLinkedList(int nodeValue, int location) &#123;</span><br><span class="line">SingleNode node &#x3D; new SingleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">System.out.println(&quot;Inserting new node at location: &quot; + location);</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);</span><br><span class="line">return; &#x2F;&#x2F; Linked List does not exists</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; insert at first position</span><br><span class="line">node.setNext(head);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">tail.setNext(node); &#x2F;&#x2F; update tail</span><br><span class="line">&#125; else if (location &gt;&#x3D; size) &#123;&#x2F;&#x2F; insert at last position</span><br><span class="line">tail.setNext(node);</span><br><span class="line">tail &#x3D; node; &#x2F;&#x2F; to keep track of last node</span><br><span class="line">tail.setNext(head); &#x2F;&#x2F; update tail to circularly point head</span><br><span class="line">&#125; else &#x2F;&#x2F; insert at specified location</span><br><span class="line">&#123;</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">while (index &lt; location - 1) &#123;&#x2F;&#x2F; loop till we reach specified node</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">index++;</span><br><span class="line">&#125;&#x2F;&#x2F; insert new node after tempNode</span><br><span class="line">node.setNext(tempNode.getNext());</span><br><span class="line">tempNode.setNext(node);</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean existsLinkedList() &#123;</span><br><span class="line">&#x2F;&#x2F; if head is not null retrun true otherwise return false</span><br><span class="line">return head !&#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse Linked List</span><br><span class="line">void traverseLinkedList() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if (i !&#x3D; size - 1) &#123;</span><br><span class="line">System.out.print(&quot; -&gt; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\nLinked List does not exists !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse Linked List</span><br><span class="line">void printHeadUsingTail() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;Printing Tail...&quot;);</span><br><span class="line">System.out.println(tail.getValue());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Printing Head using Head reference...&quot;);</span><br><span class="line">System.out.println(head.getValue());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Printing Head using Tail reference...&quot;);</span><br><span class="line">System.out.println(tail.getNext().getValue());</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete linked list</span><br><span class="line">void deleteLinkedList() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting Linked List...&quot;);</span><br><span class="line">head &#x3D; null;</span><br><span class="line">if(tail &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;Linked List is already deleted, nothing to delete !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tail.setNext(null);</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">System.out.println(&quot;Linked List deleted successfully !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Search given value in Linked List</span><br><span class="line">boolean searchNode(int nodeValue) &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; System.out.print(tempNode.value);</span><br><span class="line">if (tempNode.getValue() &#x3D;&#x3D; nodeValue) &#123;</span><br><span class="line">System.out.print(&quot;Found the node at location: &quot;+i);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;Node not found!! &quot;);</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void deletionOfNode(int location) &#123;</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);&#x2F;&#x2F; Linked List does not exists</span><br><span class="line">return;</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; we want to delete first element</span><br><span class="line">head &#x3D; head.getNext();</span><br><span class="line">tail.setNext(head);</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line">if(getSize() &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; if there are no more nodes in this list</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if (location &gt;&#x3D; getSize())&#123; &#x2F;&#x2F;If location is not in range or equal, then delete last node</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F;temp node points to 2nd last node</span><br><span class="line">&#125;</span><br><span class="line">if (tempNode &#x3D;&#x3D; head) &#123; &#x2F;&#x2F;if this is the only element in the list</span><br><span class="line">tail &#x3D; head &#x3D; null;</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(head); </span><br><span class="line">tail&#x3D; tempNode;</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line"></span><br><span class="line">&#125;else &#123; &#x2F;&#x2F;if any inside node is to be deleted</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; location - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F; we need to traverse till we find the location</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(tempNode.getNext().getNext()); &#x2F;&#x2F; delete the required node</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line">&#125;&#x2F;&#x2F;end of else</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><p>SingleNode.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public  class SingleNode &#123;</span><br><span class="line">private int value;</span><br><span class="line">private SingleNode next;</span><br><span class="line"></span><br><span class="line">public int getValue() &#123;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setValue(int value) &#123;</span><br><span class="line">this.value &#x3D; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SingleNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(SingleNode next) &#123;</span><br><span class="line">this.next &#x3D; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return  value + &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The method which could be applied to Circular Single Linked List&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Single Linked List</title>
    <link href="http://jbj828.github.io/2020/02/01/SingleLinkedList/"/>
    <id>http://jbj828.github.io/2020/02/01/SingleLinkedList/</id>
    <published>2020-02-01T06:23:25.000Z</published>
    <updated>2020-02-02T14:42:18.754Z</updated>
    
    <content type="html"><![CDATA[<p>The method which could be applied on the Single linked list</p><a id="more"></a><p>SingleNode.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class SingleNode &#123;</span><br><span class="line"></span><br><span class="line">    private int value;</span><br><span class="line">    private SingleNode next;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SingleNode getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(SingleNode next) &#123;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return value + &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SingleLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">private SingleNode head;</span><br><span class="line">private SingleNode tail;</span><br><span class="line">private int size;&#x2F;&#x2F; denotes size of list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public SingleNode getHead() &#123;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHead(SingleNode head) &#123;</span><br><span class="line">this.head &#x3D; head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SingleNode getTail() &#123;</span><br><span class="line">return tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTail(SingleNode tail) &#123;</span><br><span class="line">this.tail &#x3D; tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSize(int size) &#123;</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SingleNode createSingleLinkedList(int nodeValue) &#123;</span><br><span class="line">head &#x3D; new SingleNode();</span><br><span class="line">SingleNode node &#x3D; new SingleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">node.setNext(null);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">tail &#x3D; node;</span><br><span class="line">size &#x3D; 1;&#x2F;&#x2F; size &#x3D;1</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void insertInLinkedList(int nodeValue, int location) &#123;</span><br><span class="line">SingleNode node &#x3D; new SingleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">if (!existsLinkedList()) &#123; &#x2F;&#x2F; Linked List does not exists</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);</span><br><span class="line">return; </span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; insert at first position</span><br><span class="line">node.setNext(head);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">&#125; else if (location &gt;&#x3D; size) &#123;&#x2F;&#x2F; insert at last position</span><br><span class="line">node.setNext(null);</span><br><span class="line">tail.setNext(node);</span><br><span class="line">tail &#x3D; node; </span><br><span class="line">&#125; else &#123;&#x2F;&#x2F; insert at specified location</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">while (index &lt; location - 1) &#123;&#x2F;&#x2F; loop till we reach specified node</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">index++;</span><br><span class="line">&#125;&#x2F;&#x2F;tempNode currently references to node after which we should insert new node</span><br><span class="line">SingleNode nextNode &#x3D; tempNode.getNext(); &#x2F;&#x2F;this is the immediate next node after new node</span><br><span class="line">tempNode.setNext(node);&#x2F;&#x2F;update reference of tempNode to reference to new node</span><br><span class="line">node.setNext(nextNode);&#x2F;&#x2F;update newly added nodes&#39; next.</span><br><span class="line">&#125;</span><br><span class="line">setSize(getSize()+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean existsLinkedList() &#123;</span><br><span class="line">&#x2F;&#x2F; if head is not null retrun true otherwise return false</span><br><span class="line">return head !&#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Traverses Linked List</span><br><span class="line">void traverseLinkedList() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; getSize(); i++) &#123;</span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if (i !&#x3D; getSize() - 1) &#123;</span><br><span class="line">System.out.print(&quot; -&gt; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Deletes entire Linked List</span><br><span class="line">void deleteLinkedList() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting Linked List...&quot;);</span><br><span class="line">head &#x3D; null;</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">System.out.println(&quot;Linked List deleted successfully !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Searches a node with given value</span><br><span class="line">boolean searchNode(int nodeValue) &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; getSize(); i++) &#123;</span><br><span class="line">if (tempNode.getValue() &#x3D;&#x3D; nodeValue) &#123;</span><br><span class="line">System.out.print(&quot;Found the node at location: &quot;+i+&quot;\n&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;Node not found!! \n&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Deletes a node having a given value</span><br><span class="line">public void deletionOfNode(int location) &#123;</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);&#x2F;&#x2F; Linked List does not exists</span><br><span class="line">return;</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; we want to delete first element</span><br><span class="line">head &#x3D; head.getNext();</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line">if(getSize() &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; if there are no more nodes in this list</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if (location &gt;&#x3D; getSize())&#123; &#x2F;&#x2F;If location is not in range or equal, then delete last node</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F;temp node points to 2nd last node</span><br><span class="line">&#125;</span><br><span class="line">if (tempNode &#x3D;&#x3D; head) &#123; &#x2F;&#x2F;if this is the only element in the list</span><br><span class="line">tail &#x3D; head &#x3D; null;</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(null); </span><br><span class="line">tail&#x3D; tempNode;</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line"></span><br><span class="line">&#125;else &#123; &#x2F;&#x2F;if any inside node is to be deleted</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; location - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F; we need to traverse till we find the location</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(tempNode.getNext().getNext()); &#x2F;&#x2F; delete the required node</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line">&#125;&#x2F;&#x2F;end of else</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The method which could be applied on the Single linked list&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Linked List</title>
    <link href="http://jbj828.github.io/2020/01/30/LinkedList/"/>
    <id>http://jbj828.github.io/2020/01/30/LinkedList/</id>
    <published>2020-01-30T09:46:25.000Z</published>
    <updated>2020-02-02T14:42:07.438Z</updated>
    
    <content type="html"><![CDATA[<ul><li>What is linked list?<a id="more"></a><ul><li>A linked list is a linear data structure where is element is a separate object. Each element(node) of a list comprises of two items - the date and a reference to the next code. The most powerful feature of Linked list is that it is of variable size.</li></ul></li></ul><p><em>picture ref : data Structure and algorithms by DS GUY</em></p><br><p> <strong>Linked List VS Array</strong></p><pre><code>1. Seperate Object : The node of Linked list is could be separated from the list. However, the cells of Array can&apos;t be separated. The Array itself is separated from other Array.2. Variable Size : You can add, delete the node from Linked list. However, Array can&apos;t.3. Random Access : You can access the each cell of Array by using index. But on the linked list, you have to loop over all the node to get the data you want.</code></pre><p><strong>Components of Linked List</strong>   </p><pre><code>1. Node : Contains Data &amp; Reference to the next Node.2. Head : Reference to first node in the list.3. Tail : Reference to last node of the list.  </code></pre><h4 id="Types-of-Linked-List"><a href="#Types-of-Linked-List" class="headerlink" title="Types of Linked List"></a>Types of Linked List</h4><ul><li><strong>Single Linked List</strong><ul><li>In a singly linked list each node in the list stores the data of the node and a reference to the next node int the list. It does not store any reference to the previous node.<img src="/2020/01/30/LinkedList/linkedlist.PNG" class="" title="linked list"><br></li></ul></li><li><strong>Circular Linked List</strong><ul><li>In the case of a circular doubly linked list, the only change thata occurs is that the end of the given list is linked to the front<img src="/2020/01/30/LinkedList/circularSingle.PNG" class="" title="circular linked list"><br></li></ul></li><li><strong>Double Linked List</strong><ul><li>In double linked list each node contains two reference, that references to the previous and next node<img src="/2020/01/30/LinkedList/doublelinkedlist.PNG" class="" title="double linked list"><br></li></ul></li><li><strong>Circular Double Linked List</strong><ul><li>The only change that occurs is that the end of the given list is linked back to the front of the list and vice versa.<img src="/2020/01/30/LinkedList/circularDouble.PNG" class="" title="circular double linked list"></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;What is linked list?
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Two Dimension Array</title>
    <link href="http://jbj828.github.io/2020/01/29/MultipleDimensionArray/"/>
    <id>http://jbj828.github.io/2020/01/29/MultipleDimensionArray/</id>
    <published>2020-01-29T06:46:25.000Z</published>
    <updated>2020-02-02T14:43:37.186Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Declaring, instanciating, initializing a 2D Array</li></ul><a id="more"></a><ul><li><p>Declare               ————————- O(1)</p><ul><li>dataType[][] arr</li><li>ex: int[][] arr</li></ul></li><li><p>Instanciation of Array ————————-O(1)</p><ul><li>arrayRefVar = new datatype[row][col];</li><li>ex: arr = new int[2][3];</li></ul></li><li><p>Initialization        ————————–O(mn)</p><ul><li>a[0][0]=10;</li><li>a[0][1]=20;</li><li>a[0][2]=30;</li><li>a[1][0]=40;<br>….</li></ul></li></ul><ul><li>Declaring, instanciating, initializing ———–O(1)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* int[][] arr &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>When to Use/Avoid Array</p><ul><li><p>When to use</p><ul><li>When there is a need to store multiple similar type of data</li><li>When random access is regular affair(접근할 때 바로 인덱스 넣으면 접근가능하기에 time complexity가 O(1)이다)</li></ul></li><li><p>When to avoid</p><ul><li>Data to be stored are non-homogenous(데이터 종류가 같지 않을 경우)</li><li>When number of data to be stored is not known in advance.</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Declaring, instanciating, initializing a 2D Array&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Basic Array Theory and Single Dimension Array</title>
    <link href="http://jbj828.github.io/2020/01/29/Array/"/>
    <id>http://jbj828.github.io/2020/01/29/Array/</id>
    <published>2020-01-29T04:46:25.000Z</published>
    <updated>2020-02-02T14:44:13.022Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Types of Array</li></ul><a id="more"></a><ul><li>One Dimensional   (Array[i])</li><li>Multi Dimensional <ul><li>two Dimensioanl  (Array[row][col])</li><li>three  ‘’        (Array[depth][row][col])</li><li>four   ‘’</li><li>.. n   Dimensional</li></ul></li></ul><p>주로 one, two dimensional 사용함</p><ul><li>How is an Array represented in Memory?<ul><li>2d 3d 관계없이 memory에는 1행에 순서대로 저장된다. 1d Array 랑 같은 방식이라고 보면 된다.</li></ul></li></ul><ul><li>Create an Array<ul><li>Declare : Creates a reference to Array</li><li>Instanciation of an Array : Creates a Array</li><li>Initialization : Assigns values to cells in Array</li></ul></li></ul><ul><li>Single Dimension Array<ul><li>Array has a index. So when we consider the time complexity, we don’t need to loop all the array to get the value. We can just use the index to get the value.</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class SingleDimensionArray &#123;</span><br><span class="line">int arr[] &#x3D; null;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;Constructor</span><br><span class="line">public SingleDimensionArray(int sizeOfArray) &#123;</span><br><span class="line">arr &#x3D; new int[sizeOfArray];</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] &#x3D; Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Print the array</span><br><span class="line">public void traverseArray() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">System.out.println(&quot;Array no longer exists !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;Insert value in the Array</span><br><span class="line">public void insert(int location, int valueToBeInserted) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (arr[location] &#x3D;&#x3D; Integer.MIN_VALUE) &#123;</span><br><span class="line">arr[location] &#x3D; valueToBeInserted;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + valueToBeInserted + &quot; at location: &quot; + location);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;This cell is already occupied by another value.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">System.out.println(&quot;Invalid index to access array !&quot;);</span><br><span class="line">&#x2F;&#x2F; e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Access a particular element of an array</span><br><span class="line">public void accessingCell(int cellNumber) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">System.out.println(arr[cellNumber]);</span><br><span class="line"></span><br><span class="line">&#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">System.out.println(&quot;Invalid index to access array !&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Search for an element in the given Array</span><br><span class="line">public void searchInAnArray(int valueToSearch) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">if (arr[i] &#x3D;&#x3D; valueToSearch) &#123;</span><br><span class="line">System.out.println(&quot;Value found !&quot;);</span><br><span class="line">System.out.println(&quot;Index of &quot; + valueToSearch + &quot; is: &quot; + i);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(valueToSearch + &quot; is not found!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete value from given Array</span><br><span class="line">public void deleteValueFromArray(int deleteValueFromThisCell) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">arr[deleteValueFromThisCell] &#x3D; Integer.MIN_VALUE;</span><br><span class="line">&#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(&quot;Cant delete the value as cell# provided is not in the range of array !&quot;);</span><br><span class="line">&#x2F;&#x2F; e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete the entire Array</span><br><span class="line">public void deleteThisArray() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Array has been succefully deleted&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Types of Array&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Reucursive</title>
    <link href="http://jbj828.github.io/2020/01/28/recursion/"/>
    <id>http://jbj828.github.io/2020/01/28/recursion/</id>
    <published>2020-01-28T13:46:25.000Z</published>
    <updated>2020-02-02T14:43:08.430Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Properties of Recursion<ul><li>Some operation is performed multiple times with different inputs</li><li>In every step we try to make the problem smaller</li><li>We have to have a base condition which tells a system when to stop the recursion.</li></ul></li></ul><a id="more"></a><ul><li>Format of a ‘Recursive Function’<ul><li>Recursive Case : Case where the function recur</li><li>Base Case : Case where the function does not recur</li></ul></li></ul><p>Factorial example</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Factorial(n):</span><br><span class="line">  if(n equals 0)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (n * factorial(n-1))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Fibonacci series</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fib(n)</span><br><span class="line">  if(n is less than 1)&#123;</span><br><span class="line">      return error message</span><br><span class="line">  &#125; else if(n is equal to 1 or 2)&#123;</span><br><span class="line">      return n-1;</span><br><span class="line">  &#125; else&#123;</span><br><span class="line">      return fib(n-1) + fin(n-2);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>Time Complexity of Recursive Algo</p><ul><li><p>Problem statement : Given a sorted array of 11 numbers, find number 110<br>  10 20 30 40 50 … 90 100 110</p></li><li><p>Solution</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BinarySearch(int findNumber, int arr[], start, end):  ----- T(n)</span><br><span class="line">  if(start equals end)&#123;</span><br><span class="line">    if(arr[start] equals findNumber)&#123;</span><br><span class="line">        return findNumber</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        return error message that number does not exist in the array</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  mid &#x3D; findMid(arr[], start, end)  </span><br><span class="line">    if(mid &gt; findNumber)&#123;</span><br><span class="line">      BianarySearch(int Number, int arr[], start, mid);  -------- T(n&#x2F;2)</span><br><span class="line">    &#125;else if( mid &lt; findNumber)&#123;</span><br><span class="line">      BinarySearch(int Number, int arr[], mid, end);  ----------- T(n&#x2F;2)</span><br><span class="line">    &#125;else if(mid &#x3D; findNumber)&#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>Time Complexity:<br>T(n) = O(1) + T(n/2)</p></li><li><p>Back Substitution : </p><ul><li>T(n) = T(n/2) + 1 ——- Equation #1</li><li>T(1) = 1         ——– Base Condition</li><li>T(n/2) = T(n/4) + 1 ——Equation #2</li><li>T(n/4) = T(n/8) + 1 ——Equation #3</li></ul></li></ul><p>  T(n) = T(n/2) + 1<br>       = (T(n/4) + 1) + 1<br>       =  T(n/4) + 2<br>       = (T(n/8) + 1) + 2<br>       = T(n/8) + 3<br>       = T(n/2^k) + k </p><pre><code>n/2^k = 1    n = 2^k    k = log n= T(1) + log n= 1 + log n= log n</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Properties of Recursion&lt;ul&gt;
&lt;li&gt;Some operation is performed multiple times with different inputs&lt;/li&gt;
&lt;li&gt;In every step we try to make the problem smaller&lt;/li&gt;
&lt;li&gt;We have to have a base condition which tells a system when to stop the recursion.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Model 2 - Expression language</title>
    <link href="http://jbj828.github.io/2020/01/27/jsp-model2-theory/"/>
    <id>http://jbj828.github.io/2020/01/27/jsp-model2-theory/</id>
    <published>2020-01-27T04:10:25.000Z</published>
    <updated>2020-01-27T14:21:43.547Z</updated>
    
    <content type="html"><![CDATA[<ul><li>EL(Expression Language)<ul><li>표현식으로 attribute나 parameter 등을 JSP파일에서 출력할 용도로 사용하는 언어</li><li>attribute 를 출력할 때는 ${애트리뷰트 이름} 으로 출력</li><li>파라미터는 ${param.이름} 또는 ${paramValue.이름[idx]} 의 형태로 출력</li></ul></li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;EL(Expression Language)&lt;ul&gt;
&lt;li&gt;표현식으로 attribute나 parameter 등을 JSP파일에서 출력할 용도로 사용하는 언어&lt;/li&gt;
&lt;li&gt;attribute 를 출력할 때는 ${애트리뷰트 이름} 으로 출력&lt;/li&gt;
&lt;li&gt;파라미터는 ${param.이름} 또는 ${paramValue.이름[idx]} 의 형태로 출력&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JSP" scheme="http://jbj828.github.io/categories/JSP/"/>
    
    
      <category term="jsp" scheme="http://jbj828.github.io/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>TIL</title>
    <link href="http://jbj828.github.io/2020/01/25/jsp-model1/"/>
    <id>http://jbj828.github.io/2020/01/25/jsp-model1/</id>
    <published>2020-01-25T13:46:25.000Z</published>
    <updated>2020-01-25T13:47:03.723Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Connection Pool을 사용하지 않고 게시판을 만들어 보았다.</p><p>이전에 공부했던 connection pool사용한 회원가입-로그인 프로젝트는 별도로 server에 환경설정해야 하는 것과 달리 pool을 사용하지 않으면 DBO 클래스에서 데이터베이스에 연결만 시킬 뿐 환경설정은 필요하지 않다.</p><p>하지만 역시 connection pool을 사용하는게 재정비 및 다수의 사용자를 받아들이기엔 이상적이다.</p><p>오늘부터 정보처리산업기사 공부를 시작한다. 일주일에 한 챕터씩 끝내는 것을 목표로 나아가자!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;Connection Pool을 사용하지 않고 게시판을 만들어 보았다.&lt;/p&gt;
&lt;p&gt;이전에 공부했던 connection pool사용한 회원가입-로그인 프로젝트는 별도로 server에 환경설정해야 하는 것과 달리 p
      
    
    </summary>
    
    
      <category term="JSP" scheme="http://jbj828.github.io/categories/JSP/"/>
    
    
      <category term="jsp" scheme="http://jbj828.github.io/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>Session Login Form</title>
    <link href="http://jbj828.github.io/2020/01/22/SessionLogin/"/>
    <id>http://jbj828.github.io/2020/01/22/SessionLogin/</id>
    <published>2020-01-22T04:46:25.000Z</published>
    <updated>2020-01-23T13:32:13.915Z</updated>
    
    <content type="html"><![CDATA[<p>Session 을 이용한 로그인 폼 작성법</p><a id="more"></a><p>SessionLoginForm.jsp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;EUC-KR&quot;</span><br><span class="line">    pageEncoding&#x3D;&quot;EUC-KR&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;EUC-KR&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;h2&gt; Session Login &lt;&#x2F;h2&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;SessionLoginProc.jsp&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">&lt;table border&#x3D;&quot;1&quot; width&#x3D;&quot;400&quot;&gt;</span><br><span class="line">&lt;tr height&#x3D;&quot;50&quot;&gt;</span><br><span class="line">&lt;td width&#x3D;&quot;150&quot; align&#x3D;&quot;center&quot;&gt; ID &lt;&#x2F;td&gt;</span><br><span class="line">&lt;td width&#x3D;&quot;250&quot;&gt; &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;id&quot; &#x2F;&gt; &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr height&#x3D;&quot;50&quot;&gt;</span><br><span class="line">&lt;td width&#x3D;&quot;150&quot; align&#x3D;&quot;center&quot;&gt; Password &lt;&#x2F;td&gt;</span><br><span class="line">&lt;td width&#x3D;&quot;250&quot;&gt; &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pass&quot; &#x2F;&gt; &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr height&#x3D;&quot;50&quot;&gt;</span><br><span class="line">&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Login&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;center&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>SessionLoginProc.jsp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;EUC-KR&quot;</span><br><span class="line">    pageEncoding&#x3D;&quot;EUC-KR&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;EUC-KR&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">request.setCharacterEncoding(&quot;euc-kr&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;사용자로부터 데이터를 읽어드림</span><br><span class="line">String id &#x3D; request.getParameter(&quot;id&quot;);</span><br><span class="line">String pass &#x3D; request.getParameter(&quot;pass&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;아이디와 패스워드를 저장</span><br><span class="line">session.setAttribute(&quot;id&quot;, id);</span><br><span class="line">session.setAttribute(&quot;pass&quot;, pass);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;세션의 유지시간 설정</span><br><span class="line">session.setMaxInactiveInterval(60);</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt; Your id is &lt;%&#x3D; id %&gt;&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href&#x3D;&quot;SessionLoginProc2.jsp&quot;&gt;Next page&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;center&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>SessionLoginProc2.jsp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;EUC-KR&quot;</span><br><span class="line">    pageEncoding&#x3D;&quot;EUC-KR&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;EUC-KR&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">&#x2F;&#x2F;세션을 이용하여 데이터를 불러드림</span><br><span class="line">String id &#x3D; (String) session.getAttribute(&quot;id&quot;);</span><br><span class="line">String pass &#x3D; (String) session.getAttribute(&quot;pass&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt; Your id is &lt;%&#x3D; id %&gt;&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;center&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Session 을 이용한 로그인 폼 작성법&lt;/p&gt;
    
    </summary>
    
    
      <category term="JSP" scheme="http://jbj828.github.io/categories/JSP/"/>
    
    
      <category term="jsp" scheme="http://jbj828.github.io/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>게시판 만들기 TIL</title>
    <link href="http://jbj828.github.io/2020/01/21/today1/"/>
    <id>http://jbj828.github.io/2020/01/21/today1/</id>
    <published>2020-01-21T13:46:25.000Z</published>
    <updated>2020-01-21T13:23:02.234Z</updated>
    
    <content type="html"><![CDATA[<p>오늘 배운 것</p><ul><li><p>게시판 만들기 중 생긴 버그로 인해 한동안 고생했다. 해답은 역시…에러창을 잘 들여다보면 나온다. 아직 모든 버그를 고치지 못했지만 고지가 보인다. </p><a id="more"></a></li><li><p>MySQL과 오라클은 데이터베이스로 문법이 대부분 비슷할 것이라 생각한 착각이 시간을 잡아먹었다. 전혀 예상치 못했던 부분에서 문법이 달랐다. 항상 링크가 잘못되었다고 생각했다. 역시 문법 문제였다.</p></li><li><p>처음으로 프로젝트를 문서화했다. 구체적으로 모든 코드를 적지 않았다. 프로젝트 시작 전 초안을 만든다는 생각으로 작성했다. 늘 짐으로 느껴졌던 문서화가 생각보다 재밌었고 프로젝트의 구조를 이해하는 데 도움이 되었다.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;오늘 배운 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;게시판 만들기 중 생긴 버그로 인해 한동안 고생했다. 해답은 역시…에러창을 잘 들여다보면 나온다. 아직 모든 버그를 고치지 못했지만 고지가 보인다. &lt;/p&gt;
    
    </summary>
    
    
      <category term="JSP" scheme="http://jbj828.github.io/categories/JSP/"/>
    
    
      <category term="jsp" scheme="http://jbj828.github.io/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>Connection Pool</title>
    <link href="http://jbj828.github.io/2020/01/20/ConnectionPool/"/>
    <id>http://jbj828.github.io/2020/01/20/ConnectionPool/</id>
    <published>2020-01-20T13:46:25.000Z</published>
    <updated>2020-01-20T13:43:13.441Z</updated>
    
    <content type="html"><![CDATA[<p>Connection Pool이란?</p><ul><li><p>동시 접속자가 가질 수 있는 connection을 하나로 모아놓고 관리한다는 개념. 누군가 접속하면 자신이 관리하는 Pool에서 남아있는 Connection을 제공한다. 하지만 남아있는 connection이 없는 경우, 해당 클라이언트는 대기 상태로 전환시킨다. 이후 connection이 다시 pool에 들어오면 대기상태의 클라이언트에게 순서대로 제공한다.</p><a id="more"></a></li><li><p>즉, 데이터베이스와 연결된 connection을 미리 만들어서 pool 속에 저장해 두었다가 필요할 때 connection을 pool에서 쓰고 다시 pool에 반환하는 기법.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Connection Pool이란?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;동시 접속자가 가질 수 있는 connection을 하나로 모아놓고 관리한다는 개념. 누군가 접속하면 자신이 관리하는 Pool에서 남아있는 Connection을 제공한다. 하지만 남아있는 connection이 없는 경우, 해당 클라이언트는 대기 상태로 전환시킨다. 이후 connection이 다시 pool에 들어오면 대기상태의 클라이언트에게 순서대로 제공한다.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://jbj828.github.io/categories/Database/"/>
    
    
      <category term="database" scheme="http://jbj828.github.io/tags/database/"/>
    
  </entry>
  
</feed>
