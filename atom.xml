<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Developer Javit</title>
  
  <subtitle>Slowly and Steadily</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jbj828.github.io/"/>
  <updated>2020-03-29T15:08:51.715Z</updated>
  <id>http://jbj828.github.io/</id>
  
  <author>
    <name>Jay Chung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sorting</title>
    <link href="http://jbj828.github.io/2020/03/30/Al-sorting2/"/>
    <id>http://jbj828.github.io/2020/03/30/Al-sorting2/</id>
    <published>2020-03-29T15:30:25.000Z</published>
    <updated>2020-03-29T15:08:51.715Z</updated>
    
    <content type="html"><![CDATA[<p>sorting</p><a id="more"></a><h3 id="What-is-Sorting"><a href="#What-is-Sorting" class="headerlink" title="What is Sorting?"></a>What is Sorting?</h3><p>Sorting refers to arranging data in a particular format : either ascending or descending</p><h3 id="Types-of-Sorting"><a href="#Types-of-Sorting" class="headerlink" title="Types of Sorting"></a>Types of Sorting</h3><img src="/2020/03/30/Al-sorting2/sorting1.PNG" class="" width="500" height="500" title="Types-of-sorting"><br><h3 id="In-Place-vs-Out-Place-Sorting"><a href="#In-Place-vs-Out-Place-Sorting" class="headerlink" title="In-Place vs Out-Place Sorting"></a>In-Place vs Out-Place Sorting</h3><h5 id="In-Place-Sort"><a href="#In-Place-Sort" class="headerlink" title="In-Place Sort:"></a>In-Place Sort:</h5><ul><li>Sorting algorithms which does not require any extra space for sorting.</li><li>Example - Bubble Sort</li></ul><h5 id="Out-Place-Sort"><a href="#Out-Place-Sort" class="headerlink" title="Out-Place Sort:"></a>Out-Place Sort:</h5><ul><li>Sorting algorithms which requires extra space for sorting</li><li>Example - Merge sort</li></ul><br><h3 id="Stable-vs-Unstable-Sorting"><a href="#Stable-vs-Unstable-Sorting" class="headerlink" title="Stable vs Unstable Sorting"></a>Stable vs Unstable Sorting</h3><h5 id="Stable-Sort"><a href="#Stable-Sort" class="headerlink" title="Stable Sort:"></a>Stable Sort:</h5><ul><li>If a Sorting algorithm after sorting the contents <strong>does not change the sequence</strong> of similar content in which they appear, is called Stable sorting.</li><li>Example - Insertion sort</li></ul><h5 id="Unstable-Sort"><a href="#Unstable-Sort" class="headerlink" title="Unstable Sort:"></a>Unstable Sort:</h5><ul><li>If a sorting algorithm after sorting the contents, <strong>changes the sequence</strong> of similar content in which they appear, it is called Unstable sorting.</li><li>Example - Quick Sort</li></ul><br><h3 id="Why-“Stable-Sort”-is-important"><a href="#Why-“Stable-Sort”-is-important" class="headerlink" title="Why “Stable Sort” is important?"></a>Why “Stable Sort” is important?</h3><ul><li>Scenarios where ‘sort key’ is not the entire identity of the item.</li><li>Consider a person object with a name and a Age. Let’s say we sorted based on their name. If we were to then sort by age in a stable way, we’d guarentee that our original ordering would be preserved for people with the same age.</li><li>‘group by’ clauses of Database uses this concept very heavily.</li></ul><br><h3 id="Few-Terminologies"><a href="#Few-Terminologies" class="headerlink" title="Few Terminologies"></a>Few Terminologies</h3><ul><li><p>Increasing Order</p><ul><li>If successive element is greater than previous one.</li><li>ex) 1,3,4,6,8,9</li></ul></li><li><p>Decreasing Order</p><ul><li>If successive element is less than current one.</li><li>ex) 9,8,6,4,3,1</li></ul></li><li><p>Non-Increasing Order</p><ul><li>If successive element is less than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values.</li><li>ex) 9,8,6,3,3,1</li></ul></li><li><p>Non-Decreasing Order</p><ul><li>If the successive element is greater than or equals to its previous element in the sequence. This order occurs when the sequence contains duplicate values.</li><li>ex) 1,3,3,6,8,9</li></ul></li></ul><br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sorting&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hashing - Double Probing</title>
    <link href="http://jbj828.github.io/2020/03/29/Al-hashing-double-hashing/"/>
    <id>http://jbj828.github.io/2020/03/29/Al-hashing-double-hashing/</id>
    <published>2020-03-29T12:30:25.000Z</published>
    <updated>2020-03-29T14:06:14.413Z</updated>
    
    <content type="html"><![CDATA[<p>hashing - double probing</p><a id="more"></a><p>DoubleProbing.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class DoubleHashing &#123;</span><br><span class="line">    String[] hashTable;</span><br><span class="line">    int noOfCellsUsedInHashTable;</span><br><span class="line"></span><br><span class="line">    DoubleHashing()&#123;</span><br><span class="line">        hashTable &#x3D; new String[13];</span><br><span class="line">        noOfCellsUsedInHashTable &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; hash function to be used on keys</span><br><span class="line">    public int simpleASCIIHashFunction(String x, int M)&#123;</span><br><span class="line">        char[] ch;</span><br><span class="line">        ch &#x3D; x.toCharArray();</span><br><span class="line">        int i, sum;</span><br><span class="line">        for(i &#x3D; 0, sum &#x3D; 0; i &lt; x.length(); i++)&#123;</span><br><span class="line">            sum +&#x3D; ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Index from Hash Function : &quot; + sum%M);</span><br><span class="line">        return sum % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2nd Hash Function</span><br><span class="line">    int secondHashFunction(String x, int M)&#123;</span><br><span class="line">        char[] ch;</span><br><span class="line">        ch &#x3D; x.toCharArray();</span><br><span class="line">        int i, sum;</span><br><span class="line">        for(i &#x3D; 0, sum &#x3D; 0; i &lt; x.length(); i++)&#123;</span><br><span class="line">            sum +&#x3D; ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">        while(sum &gt; 13)&#123;</span><br><span class="line">            sum &#x3D; addAllTheDigitsTogether(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int addAllTheDigitsTogether(int sum)&#123;</span><br><span class="line">        int value &#x3D; 0;</span><br><span class="line">        while(sum &gt; 0)&#123;</span><br><span class="line">            value &#x3D; sum % 10;</span><br><span class="line">            sum &#x3D; sum &#x2F; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; get Load Factor</span><br><span class="line">    public double getLoadFactor()&#123;</span><br><span class="line">        double loadFactor &#x3D; noOfCellsUsedInHashTable * 1.0 &#x2F; hashTable.length;</span><br><span class="line">        return loadFactor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert key in Hash Table</span><br><span class="line">    public void insertKeyInHashTable(String value)&#123;</span><br><span class="line">        double loadFactor &#x3D; getLoadFactor();</span><br><span class="line">        if(loadFactor &gt;&#x3D; 0.75)&#123;</span><br><span class="line">            System.out.println(&quot;Load Factor of this hash table is over 0.75. We need to rehash!! &quot;);</span><br><span class="line">            rehashKeys(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int firstHashResult &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line">            int secondHashResult &#x3D; secondHashFunction(value, hashTable.length);</span><br><span class="line"></span><br><span class="line">            for(int i &#x3D; 0; i &lt; hashTable.length; i++)&#123;</span><br><span class="line">                int index &#x3D; (firstHashResult + (i * secondHashResult)) % hashTable.length;</span><br><span class="line">                if(hashTable[index] &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    hashTable[index] &#x3D; value;</span><br><span class="line">                    System.out.println(&quot;Succeed in inserting value on the hash table&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;Cannot insert the value on the index of &quot; + index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        noOfCellsUsedInHashTable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Creates a new hash table and rehashing</span><br><span class="line">    public void rehashKeys(String newString)&#123;</span><br><span class="line">        noOfCellsUsedInHashTable &#x3D; 0;</span><br><span class="line">        ArrayList&lt;String&gt; data &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        for(String s : hashTable)&#123;</span><br><span class="line">            if(s !&#x3D; null)&#123;</span><br><span class="line">                data.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data.add(newString);</span><br><span class="line">        hashTable &#x3D; new String[hashTable.length * 2];</span><br><span class="line">        for(String s : data)&#123;</span><br><span class="line">            insertKeyInHashTable(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search for a given key in hash table</span><br><span class="line">    public boolean searchKeyInHashTable(String value)&#123;</span><br><span class="line">        int index &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line">            for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">                int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">                if(hashTable[newIndex] &#x3D;&#x3D; value)&#123;</span><br><span class="line">                    System.out.println(&quot;Found the value!!&quot;);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(&quot;Cannot find the value&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete Key from Hash Table</span><br><span class="line">    public void deleteKeyFromHashTable(String value)&#123;</span><br><span class="line">        int index &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">            int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">            if(hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(value))&#123;</span><br><span class="line">                hashTable[newIndex] &#x3D; null;</span><br><span class="line">                System.out.println(&quot;Delete the value on the hash table&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;No value on the hash Table&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Display the hash table</span><br><span class="line">    public void displayTheHashTable()&#123;</span><br><span class="line">        if(hashTable &#x3D;&#x3D; null)&#123;</span><br><span class="line">            System.out.println(&quot;Hash Table is not exist&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; hashTable.length; i++)&#123;</span><br><span class="line">            System.out.println(hashTable[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete entire hash table</span><br><span class="line">    public void deleteEntireHashTable()&#123;</span><br><span class="line">        hashTable &#x3D; null;</span><br><span class="line">        System.out.println(&quot;Delete the hash table&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hashing - double probing&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hashing - Quadratic Probing</title>
    <link href="http://jbj828.github.io/2020/03/29/Al-hashing-quadrotic-probing/"/>
    <id>http://jbj828.github.io/2020/03/29/Al-hashing-quadrotic-probing/</id>
    <published>2020-03-29T08:30:25.000Z</published>
    <updated>2020-03-29T14:06:39.430Z</updated>
    
    <content type="html"><![CDATA[<p>Hashing - Quadratic Probing</p><a id="more"></a><p>QuadraticProbing.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class QuadraticProbing &#123;</span><br><span class="line"></span><br><span class="line">     String[] hashTable;</span><br><span class="line">     int noOfCellUsedInHashTable;</span><br><span class="line"></span><br><span class="line">     QuadraticProbing()&#123;</span><br><span class="line">         hashTable &#x3D; new String[13];</span><br><span class="line">         noOfCellUsedInHashTable &#x3D; 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Hash Function to be used on keys</span><br><span class="line">    public int simpleASCIIHashFunction(String x, int M)&#123;</span><br><span class="line">         char ch[];</span><br><span class="line">         ch &#x3D; x.toCharArray();</span><br><span class="line">         int sum, i;</span><br><span class="line">         for(i &#x3D; 0, sum &#x3D; 0; i &lt; ch.length; i++)&#123;</span><br><span class="line">             sum +&#x3D; ch[i];</span><br><span class="line">         &#125;</span><br><span class="line">         return sum % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Returns load factor of Hash Table</span><br><span class="line">    public double getLoadFactor()&#123;</span><br><span class="line">         double loadFactor &#x3D; noOfCellUsedInHashTable * 1.0 &#x2F; hashTable.length;</span><br><span class="line">         return loadFactor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert Key in Hash Table</span><br><span class="line">    public void insertKeyInHashTable(String value)&#123;</span><br><span class="line">         double loadFactor &#x3D; getLoadFactor();</span><br><span class="line">         if(loadFactor &gt;&#x3D; 0.75)&#123;</span><br><span class="line">             System.out.println(&quot;The hash table is full. Rehash the table&quot;);</span><br><span class="line">             rehashing(value);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             System.out.println(&quot;Inserting key in Hash Table&quot;);</span><br><span class="line">             int index &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line">             int counter &#x3D; 0;</span><br><span class="line">             for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">                 int newIndex &#x3D; (index + (counter*counter)) % hashTable.length;</span><br><span class="line">                 if(hashTable[newIndex] &#x3D;&#x3D; null)&#123;</span><br><span class="line">                     hashTable[newIndex] &#x3D; value;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     System.out.println(&quot;Index is not blank&quot;);</span><br><span class="line">                 &#125;</span><br><span class="line">                 counter++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         noOfCellUsedInHashTable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create a new Hash Table and Rehashing</span><br><span class="line">    public void rehashing(String newString)&#123;</span><br><span class="line">        noOfCellUsedInHashTable &#x3D; 0;</span><br><span class="line">        ArrayList&lt;String&gt; data &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        for(String s : hashTable)&#123;</span><br><span class="line">            if(s !&#x3D; null)</span><br><span class="line">                data.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        data.add(newString);</span><br><span class="line">        hashTable &#x3D; new String[hashTable.length *2];</span><br><span class="line">        for(String s : data)&#123;</span><br><span class="line">            insertKeyInHashTable(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search for a given key in Hash Table</span><br><span class="line">    public boolean searchKeyOnHashTable(String key)&#123;</span><br><span class="line"></span><br><span class="line">         int index &#x3D; simpleASCIIHashFunction(key, hashTable.length);</span><br><span class="line">         for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">             int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">             if(hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(key))&#123;</span><br><span class="line">                 System.out.println(&quot;Found the key!!&quot;);</span><br><span class="line">                 return true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;Cannot find the key&quot;);</span><br><span class="line">         return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete Key From Hash Table</span><br><span class="line">    public void deleteKeyFromHashTable(String key)&#123;</span><br><span class="line">         int index &#x3D; simpleASCIIHashFunction(key, hashTable.length);</span><br><span class="line"></span><br><span class="line">         for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">             int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">             if(hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(key))&#123;</span><br><span class="line">                 hashTable[newIndex] &#x3D; null;</span><br><span class="line">                 System.out.println(&quot;Delete the key&quot;);</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;Cannot find the key&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Display the hash table</span><br><span class="line">    public void displayTheHashTable()&#123;</span><br><span class="line">         if(hashTable &#x3D;&#x3D; null)&#123;</span><br><span class="line">             System.out.println(&quot;HashTable is not exist&quot;);</span><br><span class="line">         &#125; else&#123;</span><br><span class="line">             for(int i &#x3D; 0; i &lt; hashTable.length; i++)&#123;</span><br><span class="line">                 System.out.println(hashTable[i]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete Entire hash table</span><br><span class="line">    public void deleteEntireHashTable()&#123;</span><br><span class="line">         hashTable &#x3D; null;</span><br><span class="line">        System.out.println(&quot;Hash Table is deleted&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hashing - Quadratic Probing&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hashing - Linear Probing</title>
    <link href="http://jbj828.github.io/2020/03/28/Al-hash-linear-probing/"/>
    <id>http://jbj828.github.io/2020/03/28/Al-hash-linear-probing/</id>
    <published>2020-03-28T14:30:25.000Z</published>
    <updated>2020-03-28T13:24:26.432Z</updated>
    
    <content type="html"><![CDATA[<p>hashing - linear probing</p><a id="more"></a><p>LinearProbing.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class LinearProbing &#123;</span><br><span class="line"></span><br><span class="line">    String[] hashTable;</span><br><span class="line">    int noOfCellsUsedInHashTable;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor</span><br><span class="line">    LinearProbing()&#123;</span><br><span class="line">        hashTable &#x3D; new String[13];</span><br><span class="line">        noOfCellsUsedInHashTable &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Hash function to be used on keys</span><br><span class="line">    public int simpleASCIIHashFunction(String x, int M)&#123;</span><br><span class="line">        char ch[];</span><br><span class="line">        ch &#x3D; x.toCharArray();</span><br><span class="line">        int i, sum;</span><br><span class="line">        for(sum &#x3D;0, i &#x3D; 0; i &lt; x.length(); i++)&#123;</span><br><span class="line">            sum &#x3D; sum + ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Returns LoadFactor of HashTable</span><br><span class="line">    public double getLoadFactor()&#123;</span><br><span class="line">        double loadFactor &#x3D; noOfCellsUsedInHashTable * 1.0 &#x2F; hashTable.length;</span><br><span class="line">        return loadFactor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert key in hash table</span><br><span class="line">    public void insertKeyInHashTable(String value)&#123;</span><br><span class="line">        double loadFactor&#x3D; getLoadFactor();</span><br><span class="line">        if(loadFactor &gt;&#x3D; 0.75)&#123;</span><br><span class="line">            rehashKeys(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Inserting \&quot;&quot; + value + &quot;\&quot; in HashTable...&quot;);</span><br><span class="line">            int index &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line">            for(int i &#x3D; index; i &lt; index+ hashTable.length; i++)&#123;</span><br><span class="line">                int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">                if(hashTable[newIndex] &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    hashTable[newIndex] &#x3D; value;</span><br><span class="line">                    System.out.println(&quot;Successfully insert the value on the index &quot; + newIndex);</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    System.out.println(&quot;Failed to insert the value on the index &quot; + newIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        noOfCellsUsedInHashTable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create a new HashTable and Rehashing</span><br><span class="line">    public void rehashKeys(String newStringToBeInserted)&#123;</span><br><span class="line">        noOfCellsUsedInHashTable &#x3D; 0;</span><br><span class="line">        ArrayList&lt;String&gt; data &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        for(String s : hashTable)&#123;</span><br><span class="line">            if(s !&#x3D; null)&#123;</span><br><span class="line">                data.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data.add(newStringToBeInserted);</span><br><span class="line">        hashTable &#x3D; new String[hashTable.length * 2];</span><br><span class="line">        for(String s : data)&#123;</span><br><span class="line">            insertKeyInHashTable(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search for a given key in Hash Table</span><br><span class="line">    public boolean searchKeyInHashTable(String key) &#123;</span><br><span class="line">        int index &#x3D; simpleASCIIHashFunction(key, hashTable.length);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; index; i &lt; index + hashTable.length; i++) &#123;</span><br><span class="line">            int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">            if (hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(key)) &#123;</span><br><span class="line">                System.out.println(&quot;The key is found on the index of &quot; + newIndex);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Not Found&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete Key from HashTable</span><br><span class="line">    public void deleteKeyInHashTable(String key)&#123;</span><br><span class="line">        int index &#x3D; simpleASCIIHashFunction(key, hashTable.length);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">            int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">            if(hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(key))&#123;</span><br><span class="line">                hashTable[newIndex] &#x3D; null;</span><br><span class="line">                System.out.println(&quot;Delete the key you want&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Failed to delete the key&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Display the Hash Table</span><br><span class="line">    public void displayHashTable()&#123;</span><br><span class="line">        if(hashTable &#x3D;&#x3D; null)&#123;</span><br><span class="line">            System.out.println(&quot;No hashTable&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; hashTable.length; i++)&#123;</span><br><span class="line">            System.out.println(hashTable[i] + &quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deletes entire Hash table</span><br><span class="line">    public void deleteEntireHashTable()&#123;</span><br><span class="line">        if(hashTable &#x3D;&#x3D; null)&#123;</span><br><span class="line">            System.out.println(&quot;No hash table!! Check again!!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable &#x3D; null;</span><br><span class="line">        System.out.println(&quot;Completely deleted!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hashing - linear probing&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Vuex - Actions</title>
    <link href="http://jbj828.github.io/2020/03/28/VueJS-actions/"/>
    <id>http://jbj828.github.io/2020/03/28/VueJS-actions/</id>
    <published>2020-03-28T09:46:25.000Z</published>
    <updated>2020-03-28T03:22:56.832Z</updated>
    
    <content type="html"><![CDATA[<p>actions</p><a id="more"></a><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions?"></a>Actions?</h3><p>Mutations에는 순차적인 로직들만 선언하고 Actions에는 비순차적 또는 비동기 처리 로직들을 선언한다. </p><p>Mutations의 역할은 State 관리이다. 상태관리 자체는 한 데이터에 대해 여러 개의 컴포넌트가 관여하는 것을 효율적으로 관리하기 위한 것이다. 하지만 Mutations에 비동기 처리 로직들이 포함되면 같은 값에 대해 여러 개의 컴포넌트에서 변경을 요청했을 때, 변경 순서 파악이 어렵게 된다. </p><p>이 문제를 사전에 차단하기 위해 비동기 처리 로직은 Actions로, 동기 처리 로직은 Mutations로  나눠서 구현한다.</p><p>따라서, <code>setTimeout()</code>이나 서버와의 http 통신 처리 같이 결과를 받아올 타이밍이 예측되지 않은 로직은 Actions에 선언한다.</p><h5 id="Actions-등록"><a href="#Actions-등록" class="headerlink" title="Actions 등록"></a>Actions 등록</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js</span><br><span class="line">export const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  mutations : &#123;</span><br><span class="line">    addCounter : function(state, payload)&#123;</span><br><span class="line">      return state.counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions : &#123;</span><br><span class="line">    addCounter : function(context)&#123;</span><br><span class="line">      &#x2F;&#x2F; commit의 대상인 addCounter는 mutations의 메서드를 의미</span><br><span class="line">      return context.commit(&#39;addCounter&#39;); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>상태가 변화하는 걸 추적하기 위해 actions는 결국 mutations의 메서드를 호출(commit)하는 구조가 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js</span><br><span class="line">export const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  actions : &#123;</span><br><span class="line">    getServerData : function(context)&#123;</span><br><span class="line">      return axios.get(&quot;sample.json&quot;).then(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    delayFewMinutes : function(context)&#123;</span><br><span class="line">      return setTimeout(function()&#123;</span><br><span class="line">        commit(&#39;addCounter&#39;);</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>HTTP get 요청이나 setTimeout과 같은 비동기 처리 로직들은 actions에 선언해준다.</p><h5 id="Actions-사용"><a href="#Actions-사용" class="headerlink" title="Actions 사용"></a>Actions 사용</h5><p>앞에선 mutations를 이용하여 counter를 하나씩 늘렸다. 이번엔 actions를 이용해보자. actions를 호출할 때는 아래와 같이 <strong>dispatch()</strong>를 이용한다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">methods : &#123;</span><br><span class="line">  &#x2F;&#x2F;Mutations를 이용할 때</span><br><span class="line">  addCounter()&#123;</span><br><span class="line">    this.$store.commit(&#39;addCounter&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Actions를 이용할 때</span><br><span class="line">  addCounter()&#123;</span><br><span class="line">    this.$store.dispatch(&#39;addCounter&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Actions에-인자-값-넘기기"><a href="#Actions에-인자-값-넘기기" class="headerlink" title="Actions에 인자 값 넘기기"></a>Actions에 인자 값 넘기기</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;asyncIncrement(&#123;by : 50, duration: 500&#125;)&quot;&gt;Increment&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  actions : &#123;</span><br><span class="line">    &#x2F;&#x2F; payload는 일반적으로 사용하는 인자 명</span><br><span class="line">    asyncIncrement : function(context, payload)&#123;</span><br><span class="line">      return setTimeout(function()&#123;</span><br><span class="line">        context.commit(&#39;increment&#39;, payload.by);</span><br><span class="line">      &#125;, payload.duration);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>출처 : <a href="https://joshua1988.github.io/web-development/vuejs/vuex-getters-mutations/" target="_blank" rel="noopener">Captain Pangyo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;actions&lt;/p&gt;
    
    </summary>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/categories/VueJS/"/>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/tags/VueJS/"/>
    
  </entry>
  
  <entry>
    <title>Vuex - Getters and Mutations</title>
    <link href="http://jbj828.github.io/2020/03/28/VueJS-getters-and-mutations/"/>
    <id>http://jbj828.github.io/2020/03/28/VueJS-getters-and-mutations/</id>
    <published>2020-03-28T06:46:25.000Z</published>
    <updated>2020-03-28T02:43:37.848Z</updated>
    
    <content type="html"><![CDATA[<p>getters and mutations</p><a id="more"></a><h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters?"></a>Getters?</h3><p>중앙 데이터 관리식 구조에서 발생하는 문제점 중 하나는 각 컴포넌트에서 Vuex의 데이터를 접근할 때 중복된 코드를 반복호출 하게 되는 것이다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">computed: &#123;</span><br><span class="line">  doubleCounter() &#123;</span><br><span class="line">    return this.$store.state.counter * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Child.vue</span><br><span class="line">computed: &#123;</span><br><span class="line">  doubleCounter() &#123;</span><br><span class="line">    return this.$store.state.counter * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>여러 컴포넌트에서 같은 로직을 비효율적으로 중복 사용하고 있다. 이 때, Vuex의 데이터(state) 변경을 각 컴포넌트에서 수행하는 게 아니라, Vuex에서 수행하도록 하고 각 컴포넌트에서 수행 로직을 호출하면, 코드 가독성도 올라가고 성능에서도 이점이 생긴다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js (Vuex)</span><br><span class="line">getters : &#123;</span><br><span class="line">  doubleCounter : function(state)&#123;</span><br><span class="line">    return state.counter * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">computed : &#123;</span><br><span class="line">  doubleCounter()&#123;</span><br><span class="line">    return this.$store.getters.doubleCounter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Child.vue</span><br><span class="line">computed : &#123;</span><br><span class="line">  doubleCounter()&#123;</span><br><span class="line">    return this.$store.getters.doubleCounter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>참고로, <code>computed</code>의 장점인Caching 효과는 단순히 state 값을 반환하는 것이 아니라, getters에 선언된 속성에서 filter(), reverse() 등의 추가적인 계산 로직이 들어갈 때 발휘된다.</p><h4 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h4><p>Vuex에 내장된 helper 함수, mapGetter로 이미 위에서 한 번 가독성이 올라간 코드를 더 직관적이게 작성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  Parent counter : &#123;&#123; parentCounter&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">import &#123; mapGetters &#125; from &quot;vuex&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">computed : mapGetters(&#123;</span><br><span class="line">  parentCounter : &#39;getCounter&#39; &#x2F;&#x2F; getCounter는 Vuex의 getters에 선언된 속성 이름</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>여기서 주의할 점은 위 방법은 컴포넌트 자체에서 사용할 computed 속성과 함께 사용할 수 없다는 점이다. 해결방안은 ES6의 문법 <code>...</code>을 사용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line"></span><br><span class="line">import &#123; mapGetters &#125; from &quot;vuex&quot;</span><br><span class="line"></span><br><span class="line">computed : &#123;</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    &#39;getCounter&#39;</span><br><span class="line">  ]),</span><br><span class="line">  anotherCounter()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다만 <code>...</code> 문법을 사용하려면 Babel stage-2 라이브러리 설치 및 babel preset에 추가가 필요하다.</p><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations?"></a>Mutations?</h3><p>Mutations란 Vuex의 데이터, 즉 state 값을 변경하는 로직들을 의미한다. Getters와 차이점은</p><ol><li>인자를 받아 Vuex에 넘겨줄 수 있고</li><li>computed가 아닌 methods에 등록</li></ol><p>Actions와의 차이점은</p><ol><li>Mutations는 동기적 로직을 정의</li><li>Actions는 비동기적 로직을 정의</li></ol><p><strong>Mutations의 성격상 안에 정의한 로직들이 순차적으로 일어나야 각 컴포넌트의 반영 여부를 제대로 추적할 수가 있기 때문이다</strong></p><p><code>commit</code>을 이용하여 state를 변경한다.</p><h5 id="Mutations-등록"><a href="#Mutations-등록" class="headerlink" title="Mutations 등록"></a>Mutations 등록</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js</span><br><span class="line">export const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  mutations : &#123;</span><br><span class="line">    addCounter : function(state, payload)&#123;</span><br><span class="line">      return state.counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Mutations-사용"><a href="#Mutations-사용" class="headerlink" title="Mutations 사용"></a>Mutations 사용</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  Parent counter : &#123;&#123; parentCounter&#125;&#125; &lt;br&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;addCounter&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">methods : &#123;</span><br><span class="line">  addCounter()&#123;</span><br><span class="line">    &#x2F;&#x2F; this.$store.state.counter++;</span><br><span class="line">    this.$store.commit(&#39;addCounter&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 주목할 부분은 getters처럼 <code>this.$store.mutations.addCounter</code> 같은 접근이 불가능하고, commit을 이용하여 mutations 이벤트를 호출해야 한다는 점이다. 앞서 설명한 추적 가능한 상태 변화를 위해 프레임워크가 이렇게 구조화 되어 있는 것이다.</p><h5 id="Mutations에-인자-값-넘기기"><a href="#Mutations에-인자-값-넘기기" class="headerlink" title="Mutations에 인자 값 넘기기"></a>Mutations에 인자 값 넘기기</h5><p>각 컴포넌트에서 Vuex의 state를 조작하는 데 필요한 특정 값들을 넘기고 싶을 때는 <code>commit()</code>에 두번째 인자를 추가한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&#39;addCounter&#39;, 10);</span><br><span class="line">this.$store.commit(&#39;addCounter&#39;, &#123;</span><br><span class="line">  value : 10,</span><br><span class="line">  arr : [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vuex에서 아래와 같이 받을 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations : &#123;</span><br><span class="line">  &#x2F;&#x2F; payload가 &#123; value : 10&#125; 일 경우</span><br><span class="line">  addCounter: function(state, payload)&#123;</span><br><span class="line">    state.counter &#x3D; payload.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>데이터 인자 명은 보통 <code>payload</code>를 많이 쓴다.</p><ul><li>변경 된 state 값을 받아오는 <strong>Getters</strong></li><li>state 값을 변경하기 위한 메서드를 정의하는 <strong>Mutations</strong></li></ul><p>출처 : <a href="https://joshua1988.github.io/web-development/vuejs/vuex-getters-mutations/" target="_blank" rel="noopener">Captain Pangyo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;getters and mutations&lt;/p&gt;
    
    </summary>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/categories/VueJS/"/>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/tags/VueJS/"/>
    
  </entry>
  
  <entry>
    <title>Structure of Vuex</title>
    <link href="http://jbj828.github.io/2020/03/27/VueJS-basic-structure-of-Vuex/"/>
    <id>http://jbj828.github.io/2020/03/27/VueJS-basic-structure-of-Vuex/</id>
    <published>2020-03-27T06:46:25.000Z</published>
    <updated>2020-03-27T10:33:31.854Z</updated>
    
    <content type="html"><![CDATA[<p>structure of vuex</p><a id="more"></a><p>모든 Vuex 애플리케이션의 중심에는 <code>store</code>가 있다. <code>store</code>는 기본적으로 애플리케이션 상태를 보유하고 있는 컨테이너이다. Vuex 저장소가 일반 전역 개체와 두 가지 다른 점이 있다.</p><ol><li>Vuex store는 반응형이다. Vue 컴포넌트는 상태를 검색할 때 저장소의 상태가 변경되면 효율적으로 대응하고 업데이트 한다.</li><li>저장소의 상태를 직접 변경할 수 없다. <strong>커밋을 이용한 변이</strong>만 가능하다. 이렇게 하면 모든 상태에 대한 추적이 가능해져 앱을 사용해 툴을 더 잘 이해할 수 있다.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;모듈 시스템 사용할 경우 Vue.use(Vuex)를 먼저 호출해야 한다</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.store(&#123;</span><br><span class="line">  state : &#123;</span><br><span class="line">    count : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations : &#123;</span><br><span class="line">    increment(state)&#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이제 state 객체에 <code>store.state</code>로 접근하여 <code>store.commit</code> 메소드로 상태 변경을 트리거 할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#39;increment&#39;)</span><br><span class="line"></span><br><span class="line">console.log(store.state.count) &#x2F;&#x2F; -&gt; 1</span><br></pre></td></tr></table></figure><p>다시 말해, <code>store.state.count</code>를 직접 변경하는 대신 변이를 수행하는 이유는 명시적으로 추적을 하기 때문이다. </p><p>컴포넌트 안에서 저장소 상태를 사용하는 것은 단순히 계산된 속성 내에서 상태를 반환하는 것이다. 변경을 트리거하는 것은 컴포넌트 메소드에서 변경을 커밋하는 것을 의미한다.</p><p><strong>가장 기본적인 Vuex 카운터 앱</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; count &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;increment&quot;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;decrement&quot;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; make sure to call Vue.use(Vuex) if using a module system</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">  increment: state &#x3D;&gt; state.count++,</span><br><span class="line">    decrement: state &#x3D;&gt; state.count--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">    return store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      store.commit(&#39;increment&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement () &#123;</span><br><span class="line">    store.commit(&#39;decrement&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>출처 : <a href="https://vuex.vuejs.org/kr/guide/" target="_blank" rel="noopener">Vuex</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;structure of vuex&lt;/p&gt;
    
    </summary>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/categories/VueJS/"/>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/tags/VueJS/"/>
    
  </entry>
  
  <entry>
    <title>What is the Vuex?</title>
    <link href="http://jbj828.github.io/2020/03/26/VueJS-vuex/"/>
    <id>http://jbj828.github.io/2020/03/26/VueJS-vuex/</id>
    <published>2020-03-26T06:46:25.000Z</published>
    <updated>2020-03-26T08:01:33.249Z</updated>
    
    <content type="html"><![CDATA[<p>vuex</p><a id="more"></a><h3 id="원칙-1-Single-Source-of-Truth-단일-데이터-소스"><a href="#원칙-1-Single-Source-of-Truth-단일-데이터-소스" class="headerlink" title="원칙 1 : Single Source of Truth(단일 데이터 소스)"></a>원칙 1 : Single Source of Truth(단일 데이터 소스)</h3><p>컴포넌트들 간에 공유해야 하는 데이터(예: 애플리케이션 데이터)는 이를 사용하는 컴포넌트와는 별도로 단일 위치에 보관해야 한다.</p><p>이 단일 위치를 <code>store(저장소)</code>라고 한다. 컴포넌트는 이 위치에서 애플리케이션 데이터를 읽어야 하며 충돌이나 불일치를 방지하기 위해 복사본을 자체적으로 보관해서는 안된다.</p><h3 id="원칙-2-Data-is-Read-Only"><a href="#원칙-2-Data-is-Read-Only" class="headerlink" title="원칙 2 : Data is Read-Only"></a>원칙 2 : Data is Read-Only</h3><p>컴포넌트들은 저장소에서 데이터를 자유롭게 읽을 수 있다. 그러나 직접 변경은 불가능.</p><p>대신 데이터를 변경할 것이라는 것을 store에 알려야 하며, store은 “mutations”라고 하는 정의된 함수들을 통해 변경을 완수해야할 책임이 있다.</p><p>이렇게 데이터 변경 로직을 중앙 집중화하면 데이터에 불일치가 일어나거나 데이터에 다른 문제들이 생겼을 때 여러 곳을 일일이 뒤져볼 필요가 없다. 이것은 어떤 익명의 컴포넌트가 예상치 못한 방식으로 데이터를 변경할 가능성을 최소화 해준다.</p><h3 id="원칙-3-Mutations-are-Synchronous-Mutation은-동기적이다"><a href="#원칙-3-Mutations-are-Synchronous-Mutation은-동기적이다" class="headerlink" title="원칙 3 : Mutations are Synchronous(Mutation은 동기적이다)"></a>원칙 3 : Mutations are Synchronous(Mutation은 동기적이다)</h3><p>위에 두 가지 원칙을 지키는 애플리케이션에서 데이터를 디버그 하는 것이 훨씬 쉽다. mutation의 commit을 기록하고 응답 상태가 어떻게 변경되는지 관찰할 수 있다.(Vue Devtools에서 Vuex를 사용할 때 실제로 그렇게 디버그 할 수 있다.)</p><p>그러나 만약 우리의 “mutation”이 비동기적으로 일어난다면 그런 방식의 디버그는 불가능 할 것이다. commit이 언제 발생했는지는 알 수 있어도, commit 안에 콜백이나 Promise 같은 것들이 들어간다면 추적이 불가능해진다.</p><p>mutation이 동기적으로 일어나는 것, 데이터가 예측할 수 없는 이벤트의 순서와 시간에 종속되지 않도로 보장한다.</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex?"></a>Vuex?</h3><p>Vuex는 Vue 애플리케이션에서 Flux 아키텍처를 구현하는 데 도움이 되는 라이브러리이다. 위 원칙 덕분에 Vuex는 여러 컴포넌트에서 데이터를 공유해도 애플리케이션 데이터를 투명하고 예측 가능한 상태로 유지한다.</p><p>Vuex를 구현하기 위해서는 store, mutators 가 포함되며 store에서 데이터를 읽는 모든 컴포넌트를 자동으로 업데이트한다. </p><p>또한 핫 모듈 리로딩(실행 중인 애플리케이션에서 모듈 업데이트) 및 시간 이동 디버깅(버그 추적을 위한 mutation 이벤트 역추적)과 같은 멋진 개발 기능을 제공한다.</p><p><em>출처 : <a href="https://medium.com/@itsnothingg/%EB%8F%84%EB%8C%80%EC%B2%B4-vuex%EA%B0%80-%EB%AD%90%EA%B8%B8%EB%9E%98-ad5bc15f2371" target="_blank" rel="noopener">도대체 Vuex가 뭐길래?</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vuex&lt;/p&gt;
    
    </summary>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/categories/VueJS/"/>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/tags/VueJS/"/>
    
  </entry>
  
  <entry>
    <title>The basic of VueJS</title>
    <link href="http://jbj828.github.io/2020/03/25/VueJS-Basic/"/>
    <id>http://jbj828.github.io/2020/03/25/VueJS-Basic/</id>
    <published>2020-03-25T13:46:25.000Z</published>
    <updated>2020-03-25T14:51:37.317Z</updated>
    
    <content type="html"><![CDATA[<p>basic of vueJS</p><a id="more"></a><h3 id="What-is-VueJS"><a href="#What-is-VueJS" class="headerlink" title="What is VueJS?"></a>What is VueJS?</h3><p>MVVM 패턴의 ViewModel 레이어에 해당하는 화면단 라이브러리</p><ul><li>데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련 API를 지원한는 데 궁극적 목적이 있다.</li><li>양방향 데이터 바인딩 제공</li><li>컴포넌트 간 통신은 단방향 데이터 흐름(부모 -&gt; 자식)</li></ul><img src="/2020/03/25/VueJS-Basic/vue.png" class="" width="500" height="300" title="Vue"><h3 id="MVVM-Pattern"><a href="#MVVM-Pattern" class="headerlink" title="MVVM Pattern?"></a>MVVM Pattern?</h3><p>Backend 로직과 Client의 마크업 &amp; 데이터 표현단을 분리하기 위한 구조로 전통적인 MVC 패턴의 방식에서 기인하였다. 간단하게 생각해서 화면 앞단의 화면 동작 관련 로직과 뒷단의 DB 데이터 처리 및 서버 로직을 분리하고, 뒷단에서 넘어온 데이터를 Model에 담아 View로 넘겨주는 중간 지점이라고 보면 된다.</p><h4 id="Steps-for-Passing-Props"><a href="#Steps-for-Passing-Props" class="headerlink" title="Steps for Passing Props"></a>Steps for Passing Props</h4><ol><li>Add the prop to the parent component’s template with a v-bind expression</li><li>Tell the child component about the props it should expect to get</li></ol><p>출처 : <a href="https://joshua1988.github.io/" target="_blank" rel="noopener">Captain Pangyo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;basic of vueJS&lt;/p&gt;
    
    </summary>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/categories/VueJS/"/>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/tags/VueJS/"/>
    
  </entry>
  
  <entry>
    <title>Filtering Data</title>
    <link href="http://jbj828.github.io/2020/03/23/NodeJS-filtering-data/"/>
    <id>http://jbj828.github.io/2020/03/23/NodeJS-filtering-data/</id>
    <published>2020-03-23T01:46:25.000Z</published>
    <updated>2020-03-23T01:56:14.783Z</updated>
    
    <content type="html"><![CDATA[<p>filtering data </p><a id="more"></a><p>For data filtering, we’ll use query parameters. This will allow clients to fetch all tasks, just the complete tasks, or just the incomplete tasks.</p><h3 id="Filtering-Data"><a href="#Filtering-Data" class="headerlink" title="Filtering Data"></a>Filtering Data</h3><p>The <code>completed</code> query parameter is on the task documents of MongoDB. This query parameter can be set to <code>true</code> or <code>false</code>. This will prevent clients from fetching unnecessary data tha they don’t plan on using.</p><p>First up, create an object to store the search criteria.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const match &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure><p>From there, check if the query parameter was provided. The provided value should be parsed into a boolean and stored on <code>match.completed</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (req.query.completed) &#123;</span><br><span class="line">  match.completed &#x3D; req.query.completed &#x3D;&#x3D;&#x3D; &#39;true&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Last up, <code>match</code> can be added onto <code>populate</code> to fetch just the users that match the search criteria.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">await req.user.populate(&#123;</span><br><span class="line">  path: &#39;tasks&#39;,</span><br><span class="line">  match</span><br><span class="line">&#125;).exexPopulate()</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; READ USER&#39;S TASKS</span><br><span class="line">&#x2F;&#x2F; GET &#x2F;tasks?completed&#x3D;true</span><br><span class="line">&#x2F;&#x2F; GET &#x2F;tasks?limit&#x3D;10&amp;skip&#x3D;10</span><br><span class="line">&#x2F;&#x2F; GET &#x2F;tasks?sortBy&#x3D;createdAt:desc</span><br><span class="line">router.get(&#39;&#x2F;tasks&#39;, auth, async (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    const match &#x3D; &#123;&#125;</span><br><span class="line">    const sort &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    if (req.query.completed) &#123;</span><br><span class="line">        match.completed &#x3D; req.query.completed &#x3D;&#x3D;&#x3D; &#39;true&#39;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (req.query.sortBy) &#123;</span><br><span class="line">        const parts &#x3D; req.query.sortBy.split(&#39;:&#39;)</span><br><span class="line">        sort[parts[0]] &#x3D; parts[1] &#x3D;&#x3D;&#x3D; &#39;desc&#39; ? -1 : 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        await req.user.populate(&#123;</span><br><span class="line">            path: &#39;tasks&#39;,</span><br><span class="line">            match,</span><br><span class="line">            options: &#123;</span><br><span class="line">                limit: parseInt(req.query.limit),</span><br><span class="line">                skip: parseInt(req.query.skip),</span><br><span class="line">                sort</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).execPopulate();</span><br><span class="line">        res.send(req.user.tasks);</span><br><span class="line"></span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        res.status(500).send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>출처 : NodeJS course on Udemy by Andrew Mead</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;filtering data &lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Populate, Virtual</title>
    <link href="http://jbj828.github.io/2020/03/21/MongoDB-populate/"/>
    <id>http://jbj828.github.io/2020/03/21/MongoDB-populate/</id>
    <published>2020-03-21T06:46:25.000Z</published>
    <updated>2020-03-21T11:25:37.079Z</updated>
    
    <content type="html"><![CDATA[<p>populate</p><a id="more"></a><h3 id="Populate"><a href="#Populate" class="headerlink" title="Populate"></a>Populate</h3><ul><li>몽구스의 편리한 기능 중 하나인 populate</li><li>몽고DB를 사용하다보면 하나의 다큐먼트가 다른 다큐먼트의 ObjectId를 쓰는 경우가 있다. 그럴 때 그 ObjectId를 실제 객체로 치환하는 작업이 필요하다.</li><li>즉 populate는 ObjectId에 해당하는 값과 객체를 치환해주는 역할을 해준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const Task &#x3D; mongoose.model(&#39;Task&#39;, &#123;</span><br><span class="line"> owner: &#123;</span><br><span class="line"> type: mongoose.Schema.Types.ObjectId,</span><br><span class="line"> required: true,</span><br><span class="line"> ref: &#39;User&#39;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>ref</code>에 해당 ObjectId가 속해있는 모델을 넣어준다. 자기자신을 가리켜도 되고 다른 컬렉션 모델이어도 상관없다.</p><p>You can fetch the owner of a given task.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const task &#x3D; await Task.findById(&#39;5c2e505a3253e18a43e612e6&#39;)</span><br><span class="line">await task.populate(&#39;owner&#39;).execPopulate()</span><br><span class="line">console.log(task.owner)</span><br></pre></td></tr></table></figure><p>결과적으로 <strong>ObjectId가 실제 객체로 치환</strong>된다.</p><p> populate는 자바스크립트 단에서 합쳐주는 것이지 JOIN처럼 DB 자체에서 합쳐주는 것이 아니다. 따라서 성능이 그렇게 좋지는 않습니다. 특히 populate가 중첩되면 성능 문제가 생길 확률이 커집니다.</p><br><h3 id="Virtual"><a href="#Virtual" class="headerlink" title="Virtual"></a>Virtual</h3><p>다큐먼트에는 없지만 객체에는 있는 가상의 필드를 만들어준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userSchema.virtual(&#39;detail&#39;).get(function()&#123;</span><br><span class="line">  return &#96;I am $&#123;this.nickname&#125; and birthday is $&#123;this.birth.toLocaleString()&#125;.&#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>스키마에 virtual를 붙이면 users 컬렉션을 조회할 때 <code>{email: ..., password: ...., detail: ...}</code> 처럼 detail 필드가 생긴다. 그리고 get 메소드 안에 넣어준 함수의 return 값이 들어있다. 기존 필드들을 활용해서 새로운 가상 필드를 만드는 것이다.</p><p> 출처 : <a href="https://www.zerocho.com/category/MongoDB/post/59a66f8372262500184b5363" target="_blank" rel="noopener">zeroCho TV</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;populate&lt;/p&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://jbj828.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://jbj828.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Making Model Method(mongoose)</title>
    <link href="http://jbj828.github.io/2020/03/20/MongoDB-Making-model-method/"/>
    <id>http://jbj828.github.io/2020/03/20/MongoDB-Making-model-method/</id>
    <published>2020-03-20T06:46:25.000Z</published>
    <updated>2020-03-20T04:48:21.771Z</updated>
    
    <content type="html"><![CDATA[<p>Making model method</p><a id="more"></a><p>보통 API 컨트롤러 파일에서 데이터 모델의 내장함수들에 직접 접근하여 데이터를 생성하고 조회를 한다.</p><p>이번엔 데이터 모델에 임의 메소드, 쿼리 헬퍼를 만들어서 데이터 작업을 좀 더 용이하게 하는 방법을 알아본다.</p><p>모델 메소드는 두 종류로 만들 수 있다. <code>.statics</code> 와 <code>.methods</code> 이다. 각 종류는 서로 가리키는 <code>this</code> 값이 다르다. 전자의 경우 모델 자체를 가리키고, 후자의 경우 데이터 인스턴스를 가리킨다. </p><h3 id="static-메소드"><a href="#static-메소드" class="headerlink" title="static 메소드"></a>static 메소드</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Check the user&#39;s email and password</span><br><span class="line">userSchema.statics.findByCredentials &#x3D; async function (email, password) &#123;</span><br><span class="line">    const user &#x3D; await User.findOne(&#123; email &#125;)</span><br><span class="line"></span><br><span class="line">    if (!user) &#123;</span><br><span class="line">        throw new Error(&#39;Unable to login&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const isMatch &#x3D; await bcrypt.compare(password, user.password)</span><br><span class="line"></span><br><span class="line">    if (!isMatch) &#123;</span><br><span class="line">        throw new Error(&#39;Unable to login&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="인스턴스-메소드"><a href="#인스턴스-메소드" class="headerlink" title="인스턴스 메소드"></a>인스턴스 메소드</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Generate the token and save on the database</span><br><span class="line">userSchema.methods.generateAuthToken &#x3D; async function () &#123;</span><br><span class="line">    const user &#x3D; this</span><br><span class="line">    const token &#x3D; jwt.sign(&#123; _id: user._id.toString &#125;, &#39;studyNodeJs&#39;)</span><br><span class="line"></span><br><span class="line">    user.tokens &#x3D; user.tokens.concat(&#123; token &#125;)</span><br><span class="line">    await user.save();</span><br><span class="line"></span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>메소드를 만들 땐, 스키마를 모델화 하기 전에, <code>.statics</code> 혹은 <code>.methods</code>를 사용하여 정의를 해주어야 한다.</p><p>이렇게 메소드를 만들면, 우리가 원하는 작업마다 이름을 붙여줄 수 있게 되고 코드를 분리시킬 수 있어 가독성도 높아진다. 쿼리를 작성할 때 데이터 구조를 확인하기 위하여 컨트롤러 파일과 모델 파일을 동시에 볼 필요도 없어서 편해진다. </p><p>출처 : <a href="https://backend-intro.vlpt.us/" target="_blank" rel="noopener">backend</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Making model method&lt;/p&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://jbj828.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://jbj828.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>JSON Web Token</title>
    <link href="http://jbj828.github.io/2020/03/20/NodeJS-json-web-token/"/>
    <id>http://jbj828.github.io/2020/03/20/NodeJS-json-web-token/</id>
    <published>2020-03-20T04:46:25.000Z</published>
    <updated>2020-03-20T04:23:29.009Z</updated>
    
    <content type="html"><![CDATA[<p>token</p><a id="more"></a><h3 id="Token-기반-인증에-대한-소개"><a href="#Token-기반-인증에-대한-소개" class="headerlink" title="Token 기반 인증에 대한 소개"></a>Token 기반 인증에 대한 소개</h3><ol><li><p><strong>Stateless</strong> Server<br>상태를 유지하지 않음. 상태 정보를 저장하지 않으면 서버는 클라이언트 측에서 들어오는 요청만으로만 작업을 처리한다.이렇게 상태가 없는 경우 클라이언트와 서버의 연결고리가 없기 때문에 서버의 확장성(Scalability)가 높아진다.</p></li><li><p>Best for Mobile Application<br> Android/iOS 모바일 어플리케이션을 개발한다면, 안전한 API를 만들기 위해서 쿠키 같은 인증 시스템은 이상적이지 않다(쿠키 컨테이너를 사용해야 함). 토큰 기반 인증 도입하면, 간단하게 이 번거로움을 해결 할 수 있다</p></li><li><p>인증정보를 다른 어플리케이션으로 전달<br> 대표적 예로 OAuth가 있다. 페이스북/구글 같은 소셜 계정들을 이용하여 다른 웹 서비스에서도 로그인 할 수 있게 할 수 있다.</p></li><li><p>보안<br> 토큰 기반 인증 시스템을 사용하여 어플리케이션 보안 높일 수 있다.</p></li></ol><h3 id="토큰-기반-시스템의-작동-원리"><a href="#토큰-기반-시스템의-작동-원리" class="headerlink" title="토큰 기반 시스템의 작동 원리"></a>토큰 기반 시스템의 작동 원리</h3><ol><li>유저가 아이디와 비밀번호로 <code>로그인</code></li><li>서버측에서 해당 <code>계정정보를 검증</code></li><li>계정정보가 정확하다면, 서버측에서 유저에게 <code>signed토큰을 발급</code>(signed의 의미는 해당 토큰이 서버에서 정상적으로 발급된 토큰임을 증명하는 signature를 지니고 있다는 것)</li><li>클라이언트 측에서 전달받은 <code>토큰을 저장</code>해두고, 서버에 요청을 할 때마다, 해당 <code>토큰을 함께 서버에 전달</code></li><li>서버는 <code>토큰 검증</code>하고, <code>요청에 응답</code></li></ol><h2 id="JSON-Web-Token"><a href="#JSON-Web-Token" class="headerlink" title="JSON Web Token"></a>JSON Web Token</h2><p>JWT은 웹표준으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인(self-contained)방식으로 정보를 안전성 있게 전달해줍니다.</p><p><strong>자가 수용적(self contained)</strong><br>  JWT는 필요한 모든 정보를 자체적으로 지니고 있다. JWT 시스템에서 발급된 토큰은, 토큰에 대한 기본 정보, 전달 할 정보(로그인 시스템에서는 유저 정보) 그리고 토큰이 검증 됐다는 것을 증명해주는 signature를 포함하고 있다.</p><h4 id="JWT의-생김새"><a href="#JWT의-생김새" class="headerlink" title="JWT의 생김새"></a>JWT의 생김새</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaaaaaa.bbbbbbbbbbbbbbb.cccccccccccccccc</span><br><span class="line"> header(헤더)      payload(내용)   signature(서명)</span><br></pre></td></tr></table></figure><p>출처 : <a href="https://velopert.com/" target="_blank" rel="noopener">Veloplert.Log</a> - 공부목적으로 사용했습니다</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;token&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Async/Await</title>
    <link href="http://jbj828.github.io/2020/03/17/NodeJS-async-await/"/>
    <id>http://jbj828.github.io/2020/03/17/NodeJS-async-await/</id>
    <published>2020-03-17T11:46:25.000Z</published>
    <updated>2020-03-17T13:29:58.883Z</updated>
    
    <content type="html"><![CDATA[<p>async/await</p><a id="more"></a><p>These provide an improved syntax for working with promises. You’ll be able to write complex asynchronous code that looks like normal synchronous code. This makes it much easier to write and maintain asynchronous code.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const add &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            if (a &lt; 0 || b &lt; 0) &#123;</span><br><span class="line">                return reject(&#39;Numbers must be non-negative&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(a + b);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const doWork &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    const sum &#x3D; await add(1, 99)</span><br><span class="line">    const sum2 &#x3D; await add(sum, 50)</span><br><span class="line">    const sum3 &#x3D; await add(sum2, -10)</span><br><span class="line">    return sum3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doWork().then((result) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;result&#39;, result)</span><br><span class="line">&#125;).catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;e&#39;, e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;async/await&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://jbj828.github.io/2020/03/15/NodeJS-Promise/"/>
    <id>http://jbj828.github.io/2020/03/15/NodeJS-Promise/</id>
    <published>2020-03-15T11:46:25.000Z</published>
    <updated>2020-03-17T08:27:45.096Z</updated>
    
    <content type="html"><![CDATA[<p>promise</p><a id="more"></a><p>출처 : <a href="https://joshua1988.github.io/web-development/javascript/promise-for-beginners/" target="_blank" rel="noopener">Captain Pangyo</a><br>공부목적을 위해 이용했습니다.</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul><li><p>“A promise is an object that may produce a single value some time in the future”</p></li><li><p>프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다. </p></li></ul><h3 id="Why-we-need-it"><a href="#Why-we-need-it" class="headerlink" title="Why we need it?"></a>Why we need it?</h3><ul><li>프로미스는 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용한다. 일반적으로 웹 애플리케이션을 구현할 때 서버에서 데이터를 요청하고 받아오기 위해 사용한다.</li></ul><p>비동기 처리를 위해 콜백 함수를 사용한 경우</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const doWorkCallback &#x3D; (callback) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; callback(&#39;Error&#39;, undefined);</span><br><span class="line">        callback(undefined, [1, 3, 4])</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doWorkCallback((error, result) &#x3D;&gt; &#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        return console.log(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>비동기 처리를 위해 Promise API를 사용한 경우</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const doWorkPromise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        resolve([2, 3, 4]);</span><br><span class="line">        reject(&#39;Thing went wrong!&#39;)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">doWorkPromise.then((result) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;Success&#39;, result)</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;Error&#39;, error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise의-3가지-상태-states"><a href="#Promise의-3가지-상태-states" class="headerlink" title="Promise의 3가지 상태(states)"></a>Promise의 3가지 상태(states)</h3><p>여기서 말하는 상태란 프로미스의 처리 과정을 의미한다. <code>new Promise()</code>로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖는다.</p><ul><li>Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태</li><li>Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태</li><li>Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태</li></ul><h4 id="Pending"><a href="#Pending" class="headerlink" title="Pending"></a>Pending</h4><p>먼저 <code>new Promise()</code> 메서드를 호출하면 대기(Pending) 상태가 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise();</span><br></pre></td></tr></table></figure><p><code>new Promise()</code> 메서드를 호출할 때 콜백 함수를 선언할 수 있고, 콜백 함수의 인자는 <code>resolve</code>, <code>reject</code>입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Fulfilled-이행"><a href="#Fulfilled-이행" class="headerlink" title="Fulfilled(이행)"></a>Fulfilled(이행)</h4><p>여기서 콜백 함수의 인자 <code>resolve</code>를 아래와 같이 실행하면 이행(Fulfilled) 상태가 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve, reject)&#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>그리고 이행 상태가 되면 아래와 같이 <code>then()</code>을 이용하여 처리 결과 값을 받을 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function getData()&#123;</span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    var data &#x3D; 100;</span><br><span class="line">    resolve(data);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; resolve()의 결과 값 data를 resolveData로 받음</span><br><span class="line">getData().then(function(resolveData)&#123;</span><br><span class="line">  console.log(resolveData); &#x2F;&#x2F; 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Rejected-실패"><a href="#Rejected-실패" class="headerlink" title="Rejected(실패)"></a>Rejected(실패)</h4><p><code>new Promise()</code>로 프로미스 객체를 생성하면 콜백 함수 인자로 <code>resolve</code>와 <code>reject</code>를 사용할 수 있다. 여기서 <code>reject</code>를 아래와 같이 호출하면 실패(Rejected) 상태가 된다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve, reject)&#123;</span><br><span class="line">  reject();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>그리고 실패 상태가 되면 실패한 이유(실패 처리의 결과 값)를 <code>catch()</code>로 받을 수 있다.ss</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function getData()&#123;</span><br><span class="line">  return new Promise(function(resolve, reject)&#123;</span><br><span class="line">    reject(new Error(&quot;Request is failed&quot;))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reject()의 결과 값 Error를 err에 받음</span><br><span class="line">getData().then().catch(function(err)&#123;</span><br><span class="line">  console.log(err); &#x2F;&#x2F; Error: Request is failed</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="/2020/03/15/NodeJS-Promise/promise.PNG" class="" width="500" height="300" title="promise"><p>프로미스 처리 흐름(출처 : MDN)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function getData() &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    $.get(&#39;url 주소&#x2F;products&#x2F;1&#39;, function(response) &#123;</span><br><span class="line">      if (response) &#123;</span><br><span class="line">        resolve(response);</span><br><span class="line">      &#125;</span><br><span class="line">      reject(new Error(&quot;Request is failed&quot;));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 위 $.get() 호출 결과에 따라 &#39;response&#39; 또는 &#39;Error&#39; 출력</span><br><span class="line">getData().then(function(data) &#123;</span><br><span class="line">  console.log(data); &#x2F;&#x2F; response 값 출력</span><br><span class="line">&#125;).catch(function(err) &#123;</span><br><span class="line">  console.error(err); &#x2F;&#x2F; Error 출력</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>위 코드는 서버에서 제대로 응답을 받아오면 resolve() 메서드를 호출하고, 응답이 없으면 reject() 메서드를 호출하는 예제입니다. 호출된 메서드에 따라 then()이나 catch()로 분기하여 응답 결과 또는 오류를 출력합니다.</p><h3 id="Promise-Chaining"><a href="#Promise-Chaining" class="headerlink" title="Promise Chaining"></a>Promise Chaining</h3><p>Promise chaining is a syntax that allows you to chain together multiple asychronous tasks in a specific order. This is great for complex code where one asynchronous task needs to be performed after the completion of a different asynchronous task.</p><p>With the dummy asychronous function defined, promise chaining can be used to call <code>add</code> twice.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const add &#x3D; (a, b) &#x3D;&gt; &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(a + b);</span><br><span class="line">        &#125;, 2000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2).then((sum) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(sum)</span><br><span class="line"></span><br><span class="line">    add(sum, 5).then((sum2) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(sum2)</span><br><span class="line">    &#125;).catch((e) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise chaining occurs when the then callback function returns a promise. This allows<br>you to chain on another then call which will run when the second promise is fulfilled. catch<br>can still be called to handle any errors that might occur along the way.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(1, 1).then((sum) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(sum)</span><br><span class="line">    return add(sum, 4)</span><br><span class="line">&#125;).then((sum2) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(sum2)</span><br><span class="line">&#125;).catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;promise&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Default Function Parameters</title>
    <link href="http://jbj828.github.io/2020/03/12/ES6-default-function-parameters/"/>
    <id>http://jbj828.github.io/2020/03/12/ES6-default-function-parameters/</id>
    <published>2020-03-12T14:46:25.000Z</published>
    <updated>2020-03-12T15:00:38.686Z</updated>
    
    <content type="html"><![CDATA[<p>default function parameters</p><a id="more"></a><h3 id="Default-Function-Parameters"><a href="#Default-Function-Parameters" class="headerlink" title="Default Function Parameters"></a>Default Function Parameters</h3><p>ES6 provides a new syntax to set default values for function arguments.</p><p>Function parameters are <code>undefined</code> unless an argument value is provided when the function is called. ES6 now allows function parameters to be configured with a custom default value.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const greeter &#x3D; (name &#x3D; &#39;user&#39;, age) &#x3D;&gt; &#123;</span><br><span class="line"> console.log(&#39;Hello &#39; + name)</span><br><span class="line">&#125;</span><br><span class="line">greeter(&#39;Andrew&#39;) &#x2F;&#x2F; Will print: Hello Andrew</span><br><span class="line">greeter() &#x2F;&#x2F; Will print: Hello user</span><br></pre></td></tr></table></figure><p>This syntax can also be used to provide default values when using ES6 destructuring. The <code>transaction</code> function below shows this off by providing a default value for <code>stock</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const transaction &#x3D; (type, &#123; label, stock &#x3D; 0 &#125; &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line"> console.log(type, label, stock)</span><br><span class="line">&#125;</span><br><span class="line">transaction(&#39;order&#39;)</span><br></pre></td></tr></table></figure><br><p><em>reference : Udemy ‘The Complete Node.js Developer course’ by Andrew Mead</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;default function parameters&lt;/p&gt;
    
    </summary>
    
    
      <category term="ES6" scheme="http://jbj828.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://jbj828.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Browser HTTP Requests with Fetch</title>
    <link href="http://jbj828.github.io/2020/03/12/NodeJS-fetch-API/"/>
    <id>http://jbj828.github.io/2020/03/12/NodeJS-fetch-API/</id>
    <published>2020-03-12T14:46:25.000Z</published>
    <updated>2020-03-12T15:00:44.237Z</updated>
    
    <content type="html"><![CDATA[<p>fetch API</p><a id="more"></a><p>This chapter shows you how to make HTTP AJAX requests from the browser.<br><br></p><h3 id="The-Fetch-API"><a href="#The-Fetch-API" class="headerlink" title="The Fetch API"></a>The Fetch API</h3><p>Web APIs provide you with a way to make HTTP requests from JavaScript in the browser. This is done using the <code>fetch</code> function. <code>fetch</code> expects to be called with the URL as the first argument. It sends off the HTTP request and gives you back the response.</p><p>The <code>fetch</code> call below is used to fetch the weather for Boston. An if statement is then used to either print the forecast or the error message.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;weather?address&#x3D;Boston&#39;).then((response) &#x3D;&gt; &#123;</span><br><span class="line"> response.json().then((data) &#x3D;&gt; &#123;</span><br><span class="line"> if (data.error) &#123;</span><br><span class="line"> console.log(data.error)</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> console.log(data.location)</span><br><span class="line"> console.log(data.forecast)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><p><em>reference : Udemy ‘The Complete Node.js Developer course’ by Andrew Mead</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;fetch API&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>The Query String</title>
    <link href="http://jbj828.github.io/2020/03/12/NodeJS-Query-String/"/>
    <id>http://jbj828.github.io/2020/03/12/NodeJS-Query-String/</id>
    <published>2020-03-12T05:46:25.000Z</published>
    <updated>2020-03-12T14:49:11.956Z</updated>
    
    <content type="html"><![CDATA[<p>Query String</p><a id="more"></a><h4 id="The-Query-String"><a href="#The-Query-String" class="headerlink" title="The Query String"></a>The Query String</h4><p>The query string is a portion of the URL that allows you to provide additional information to the server. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.get(&#39;&#x2F;weather&#39;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(req.query)</span><br><span class="line">    if (!req.query.address) &#123;</span><br><span class="line">        return res.send(&#123;</span><br><span class="line">            error: &quot;You must provide an address.&quot;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        forcast: &#39;forcast&#39;,</span><br><span class="line">        location: &#39;location&#39;,</span><br><span class="line">        address: req.query.address</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Query String&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/HTTPS Request without library</title>
    <link href="http://jbj828.github.io/2020/03/11/NodeJS-Http-request/"/>
    <id>http://jbj828.github.io/2020/03/11/NodeJS-Http-request/</id>
    <published>2020-03-11T05:46:25.000Z</published>
    <updated>2020-03-11T06:12:03.290Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP Request without library</p><a id="more"></a><p>This is the low level access to the NodeJS. Without using library, we can also get the http/https request.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const https &#x3D; require(&quot;https&quot;);</span><br><span class="line"></span><br><span class="line">const url &#x3D; &#39;https:&#x2F;&#x2F;api.darksky.net&#x2F;forecast&#x2F;924276c331b8a398db96364a44fd10a2&#x2F;40,-50?units&#x3D;si&#39;</span><br><span class="line"></span><br><span class="line">const request &#x3D; https.request(url, (response) &#x3D;&gt; &#123;</span><br><span class="line">    let data &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">    response.on(&#39;data&#39;, (chunk) &#x3D;&gt; &#123;</span><br><span class="line">        data &#x3D; data + chunk.toString();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    response.on(&#39;end&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">        const body &#x3D; JSON.parse(data);</span><br><span class="line">        console.log(body);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">request.on(&#39;error&#39;, (error) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;An error&#39;, error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">request.end();</span><br></pre></td></tr></table></figure><p>This is the console result</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  latitude: 40,  </span><br><span class="line">  longitude: -50,</span><br><span class="line">  timezone: &#39;Etc&#x2F;GMT+3&#39;,</span><br><span class="line">  currently: &#123;</span><br><span class="line">    time: 1583906798,</span><br><span class="line">    summary: &#39;Partly Cloudy&#39;,</span><br><span class="line">    icon: &#39;partly-cloudy-night&#39;,</span><br><span class="line">    precipIntensity: 0,</span><br><span class="line">    precipProbability: 0,</span><br><span class="line">    temperature: 16.48,</span><br><span class="line">    apparentTemperature: 16.48,</span><br><span class="line">    dewPoint: 12.34,</span><br><span class="line">    humidity: 0.77,</span><br><span class="line">    pressure: 1028,</span><br><span class="line">    windSpeed: 5.67,</span><br><span class="line">    windGust: 9.52,</span><br><span class="line">    windBearing: 248,</span><br><span class="line">    cloudCover: 0.41,</span><br><span class="line">    uvIndex: 0,</span><br><span class="line">    visibility: 16.093,</span><br><span class="line">    ozone: 330.9</span><br><span class="line">  &#125;,</span><br><span class="line">  hourly: &#123;</span><br><span class="line">    summary: &#39;Windy in the afternoon and evening.&#39;,</span><br><span class="line">    icon: &#39;partly-cloudy-day&#39;,</span><br><span class="line">    data: [</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object], [Object], [Object], [Object],</span><br><span class="line">      [Object]</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  daily: &#123;</span><br><span class="line">    summary: &#39;Rain on Friday through next Wednesday.&#39;,</span><br><span class="line">    icon: &#39;rain&#39;,</span><br><span class="line">    data: [</span><br><span class="line">      [Object], [Object],</span><br><span class="line">      [Object], [Object],</span><br><span class="line">      [Object], [Object],</span><br><span class="line">      [Object], [Object]</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  flags: &#123;</span><br><span class="line">    sources: [</span><br><span class="line">      &#39;cmc&#39;,   &#39;gfs&#39;,</span><br><span class="line">      &#39;icon&#39;,  &#39;isd&#39;,</span><br><span class="line">      &#39;madis&#39;, &#39;nam&#39;,</span><br><span class="line">      &#39;sref&#39;</span><br><span class="line">    ],</span><br><span class="line">    &#39;nearest-station&#39;: 0,</span><br><span class="line">    units: &#39;si&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  offset: -3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP Request without library&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Callback Function</title>
    <link href="http://jbj828.github.io/2020/03/11/NodeJS-callback-function/"/>
    <id>http://jbj828.github.io/2020/03/11/NodeJS-callback-function/</id>
    <published>2020-03-11T04:46:25.000Z</published>
    <updated>2020-03-10T15:06:06.721Z</updated>
    
    <content type="html"><![CDATA[<p>callback function on nodejs</p><a id="more"></a><h3 id="The-Callback-Function"><a href="#The-Callback-Function" class="headerlink" title="The Callback Function"></a>The Callback Function</h3><p>A callback function is a function that’s passed as an argument to another function.</p><p>Callback functions are at the core of asynchronous development. When you perform an asynchronous operation, you will provide Node with a callback function. Node will then call the callback when the async operation is complete. This is how you get access to the results of the async operation, whether it’s an HTTP request for JSON data or a query to a database for a user’s profile.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const add &#x3D; (a, b, callback) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        callback(a + b)</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 4, (sum) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(sum) &#x2F;&#x2F; Should print: 5</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;callback function on nodejs&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
</feed>
