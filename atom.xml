<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Developer Javit</title>
  
  <subtitle>Slowly and Steadily</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jbj828.github.io/"/>
  <updated>2020-02-18T09:02:11.759Z</updated>
  <id>http://jbj828.github.io/</id>
  
  <author>
    <name>Jay Chung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Trie Coding</title>
    <link href="http://jbj828.github.io/2020/02/18/Al-Trie-Coding/"/>
    <id>http://jbj828.github.io/2020/02/18/Al-Trie-Coding/</id>
    <published>2020-02-18T07:30:25.000Z</published>
    <updated>2020-02-18T09:02:11.759Z</updated>
    
    <content type="html"><![CDATA[<p>Trie coding</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">package trie;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Trie &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Private class</span><br><span class="line">private class TrieNode &#123;</span><br><span class="line">Map&lt;Character, TrieNode&gt; children;</span><br><span class="line">boolean endOfWord;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Constructor</span><br><span class="line">public TrieNode() &#123;</span><br><span class="line">children &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">endOfWord &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; End of inner class</span><br><span class="line"></span><br><span class="line">private final TrieNode root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Constructor</span><br><span class="line">public Trie() &#123;</span><br><span class="line">root &#x3D; new TrieNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Insert word into Trie</span><br><span class="line">public void insert(String word) &#123;</span><br><span class="line">TrieNode current &#x3D; root;</span><br><span class="line">for (int i &#x3D; 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">char ch &#x3D; word.charAt(i);</span><br><span class="line">TrieNode node &#x3D; current.children.get(ch);</span><br><span class="line">if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">node &#x3D; new TrieNode();</span><br><span class="line">current.children.put(ch, node);</span><br><span class="line">&#125;</span><br><span class="line">current &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line">current.endOfWord &#x3D; true;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + word + &quot; in Trie !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Search for a word in Trie</span><br><span class="line">public boolean search(String word) &#123;</span><br><span class="line">TrieNode currentNode &#x3D; root;</span><br><span class="line">for (int i &#x3D; 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">char ch &#x3D; word.charAt(i);</span><br><span class="line">TrieNode node &#x3D; currentNode.children.get(ch); </span><br><span class="line">if (node &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;CASE#1 -- if node does not exist for given char then return false</span><br><span class="line">System.out.println(&quot;Word: &quot; + word + &quot; does not exists in Trie !&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">currentNode &#x3D; node;</span><br><span class="line">&#125;</span><br><span class="line">if(currentNode.endOfWord &#x3D;&#x3D; true) &#123;</span><br><span class="line">System.out.println(&quot;Word: &quot; + word + &quot; exists in Trie !&quot;); &#x2F;&#x2F;CASE#2 -- Word exists in Trie</span><br><span class="line">&#125;else &#123;&#x2F;&#x2F;CASE#3 -- Current word is a prefix of another word. But this word does not exists</span><br><span class="line">System.out.println(&quot;Word: &quot; + word + &quot; does not exists in Trie ! But this is a Prefix of another Word !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return currentNode.endOfWord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Delete word from Trie</span><br><span class="line">public void delete(String word) &#123;</span><br><span class="line">if (search(word) &#x3D;&#x3D; true) &#123;</span><br><span class="line">delete(root, word, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Returns true if parent should delete the mapping</span><br><span class="line">private boolean delete(TrieNode parentNode, String word, int index) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; CASE#1 -- Some other word&#39;s prefix is same as Prefix of this word (BCDE, BCKG)</span><br><span class="line">&#x2F;&#x2F; CASE#2 -- We are at last character of this word and This word is a Prefix of some other word (BCDE, BCDEFG)</span><br><span class="line">&#x2F;&#x2F; CASE#3 -- Some other word is a Prefix of this word (BCDE, BC)</span><br><span class="line">&#x2F;&#x2F; CASE#4 -- No one is dependent on this Word (BCDE, BCDE)</span><br><span class="line"></span><br><span class="line">char ch &#x3D; word.charAt(index);</span><br><span class="line">TrieNode currentNode &#x3D; parentNode.children.get(ch);</span><br><span class="line"></span><br><span class="line">boolean canThisNodeBeDeleted;</span><br><span class="line"></span><br><span class="line">if (currentNode.children.size() &gt; 1) &#123;</span><br><span class="line">System.out.println(&quot;Entering Case#1&quot;);</span><br><span class="line">delete(currentNode, word, index + 1); &#x2F;&#x2F; CASE#1</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (index &#x3D;&#x3D; word.length() - 1) &#123; &#x2F;&#x2F; CASE#2</span><br><span class="line">System.out.println(&quot;Entering Case#2&quot;);</span><br><span class="line">if (currentNode.children.size() &gt;&#x3D; 1) &#123;</span><br><span class="line">currentNode.endOfWord &#x3D; false;&#x2F;&#x2F;updating endOfWord will signify that this word is not there in Trie</span><br><span class="line">return false;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Character &quot; + ch + &quot; has no dependency, hence deleting it from last&quot;);</span><br><span class="line">parentNode.children.remove(ch);</span><br><span class="line">return true;&#x2F;&#x2F; If this word is not a prefix of some other word, and since this is last</span><br><span class="line">&#x2F;&#x2F; character, we should</span><br><span class="line">&#x2F;&#x2F; return true, indicating we are ok to delete this node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (currentNode.endOfWord &#x3D;&#x3D; true) &#123; &#x2F;&#x2F; CASE#3</span><br><span class="line">System.out.println(&quot;Entering Case#3&quot;);</span><br><span class="line">delete(currentNode, word, index + 1); </span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Entering Case#1&quot;);</span><br><span class="line">canThisNodeBeDeleted &#x3D; delete(currentNode, word, index + 1); &#x2F;&#x2F; CASE#4</span><br><span class="line">if (canThisNodeBeDeleted &#x3D;&#x3D; true) &#123;</span><br><span class="line">System.out.println(&quot;Character &quot; + ch + &quot; has no dependency, hence deleting it&quot;);</span><br><span class="line">parentNode.children.remove(ch);</span><br><span class="line">return true; &#x2F;&#x2F; Current node can also be deleted</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false; &#x2F;&#x2F; Someone is dependent on this node, hence dont delete it</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; End of class</span><br></pre></td></tr></table></figure><Br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Trie coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://jbj828.github.io/2020/02/16/Al-Trie/"/>
    <id>http://jbj828.github.io/2020/02/16/Al-Trie/</id>
    <published>2020-02-16T06:30:25.000Z</published>
    <updated>2020-02-17T00:43:39.182Z</updated>
    
    <content type="html"><![CDATA[<p>trie</p><a id="more"></a><p><strong>What is Trie?</strong></p><ul><li>It is a search tree, which is typically used to store/search strings in space/time efficient way.</li><li>In it, any node can store non repetitive multiple characters.</li><li>Also, every node stores ‘link’ of next character of the string.</li><li>Also, every node keeps a track of ‘end of String’</li></ul><br><p><strong>Why learn Trie?</strong></p><ul><li>Used to solve many standard problems in efficient ways<ul><li>Spelling checker</li><li>Auto Complete string</li><li>Etc..</li></ul></li></ul><br><p><strong>Creating a Trie</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Trie()</span><br><span class="line">  create a blank node</span><br></pre></td></tr></table></figure><br><p><strong>Inserting a String in Trie</strong></p><ul><li>Case#1 - Trie is blank(air)</li><li>Case#2 - New String’s prefix is common with another String’s Prefix(aio)</li><li>Case#3 - New String’s prefix is already present as complete String(airk)</li><li>Case#4 - String to be inserted is already present in Trie</li></ul><br><p><strong>Searching a String in Trie</strong> </p><p>ex)abc</p><ul><li>Case#1 - String does not exist in Trie(ex) xyz)</li><li>Case#2 - String exists in Trie(ex) abc)</li><li>Case#3 - Current String is a prefix of another String. But this string does not exist in Trie.(ex) ab)</li></ul><br><p><strong>Deleting a String from Trie</strong></p><ul><li>Case#1 - Some other word’s prefix is same as Prefix of this word(BCDE, BCKG)</li><li>Case#2 - This word is a prefix of some other word(BCDE,BCDEF)</li><li>Case#3 - Some other word is a prefix of this word(BCDE,BC)</li><li>Case#4 - No one is dependent on this word(k)</li></ul><Br><p><strong>Trie-Practical use</strong></p><ul><li>Auto Complete</li><li>Spell Checkers</li></ul><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;trie&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Heap Coding</title>
    <link href="http://jbj828.github.io/2020/02/15/Al-BinaryHeapCoding/"/>
    <id>http://jbj828.github.io/2020/02/15/Al-BinaryHeapCoding/</id>
    <published>2020-02-15T13:30:25.000Z</published>
    <updated>2020-02-15T13:26:55.261Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Heap Coding</p><a id="more"></a><p>HeapByArray.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class HeapByArray &#123;</span><br><span class="line">int[] arr;</span><br><span class="line">int sizeOfTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor</span><br><span class="line">public HeapByArray(int size) &#123;</span><br><span class="line">&#x2F;&#x2F;We are adding 1 here so that first cell of the array can be left blank all the time. This is eliminate problem of array starting from index 0.</span><br><span class="line">arr &#x3D; new int[size+1];</span><br><span class="line">this.sizeOfTree &#x3D; 0;</span><br><span class="line">System.out.println(&quot;Empty Heap has been created !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int sizeOfArray() &#123;</span><br><span class="line">return arr.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int sizeOfTree() &#123;</span><br><span class="line">System.out.println(&quot;Size Of Tree: &quot; + sizeOfTree);</span><br><span class="line">return sizeOfTree;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isHeapEmpty() &#123;</span><br><span class="line">if (sizeOfTree &lt;&#x3D; 0) &#123;</span><br><span class="line">System.out.println(&quot;Tree is empty !&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Tree is not empty !&quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteheap() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Heap has been deleted !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Insert a new value in Heap</span><br><span class="line">public void insertInHeap(int value) &#123;</span><br><span class="line">&#x2F;&#x2F;Doing +1 because sizeOfTree always points to the last occupied cell of the array </span><br><span class="line">System.out.println(&quot;Inserting &quot; + value + &quot; in Heap...&quot;);</span><br><span class="line">arr[sizeOfTree+1] &#x3D; value;</span><br><span class="line">sizeOfTree++;</span><br><span class="line">HeapifyBottomToTop(sizeOfTree);</span><br><span class="line">System.out.println(&quot;Inserted &quot; + value + &quot; successfully in Heap !&quot;);</span><br><span class="line">levelOrder();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Peek into Heap</span><br><span class="line">public void peek() &#123;</span><br><span class="line">if(sizeOfTree &#x3D;&#x3D; 0) &#123;</span><br><span class="line">System.out.println(&quot;Heap is empty !&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Head of the Heap is: &quot; + arr[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Extract Head of Heap</span><br><span class="line">public int extractHeadOfHeap() &#123;</span><br><span class="line">if(sizeOfTree &#x3D;&#x3D; 0) &#123;</span><br><span class="line">System.out.println(&quot;Heap is empty !&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Head of the Heap is: &quot; + arr[1]);</span><br><span class="line">System.out.println(&quot;Extracting it now...&quot;);</span><br><span class="line">int extractedValue &#x3D; arr[1];</span><br><span class="line">arr[1] &#x3D; arr[sizeOfTree];</span><br><span class="line">sizeOfTree--;</span><br><span class="line">HeapifyTopToBottom(1);</span><br><span class="line">System.out.println(&quot;Successfully extracted value from Heap.&quot;);</span><br><span class="line">levelOrder();</span><br><span class="line">return extractedValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void HeapifyBottomToTop(int index) &#123;</span><br><span class="line">int parent &#x3D; index &#x2F; 2;</span><br><span class="line">&#x2F;&#x2F; We are at root of the tree. Hence no more Heapifying is required.</span><br><span class="line">if (index &lt;&#x3D; 1) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; If Current value is smaller than its parent, then we need to swap</span><br><span class="line">if (arr[index] &lt; arr[parent]) &#123;</span><br><span class="line">int tmp &#x3D; arr[index];</span><br><span class="line">arr[index] &#x3D; arr[parent];</span><br><span class="line">arr[parent] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">HeapifyBottomToTop(parent);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void HeapifyTopToBottom(int index) &#123;</span><br><span class="line">int left  &#x3D; index*2;</span><br><span class="line">int right &#x3D; (index*2)+1;</span><br><span class="line">int smallestChild &#x3D; 0;</span><br><span class="line"></span><br><span class="line">if (sizeOfTree &lt; left) &#123; &#x2F;&#x2F;If there is no child of this node, then nothing to do. Just return.</span><br><span class="line">return; </span><br><span class="line">&#125;else if (sizeOfTree &#x3D;&#x3D; left) &#123; &#x2F;&#x2F;If there is only left child of this node, then do a comparison and return.</span><br><span class="line">if(arr[index] &gt; arr[left]) &#123;</span><br><span class="line">int tmp &#x3D; arr[index];</span><br><span class="line">arr[index] &#x3D; arr[left];</span><br><span class="line">arr[left] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123; &#x2F;&#x2F;If both children are there</span><br><span class="line">if(arr[left] &lt; arr[right]) &#123; &#x2F;&#x2F;Find out the smallest child</span><br><span class="line">smallestChild &#x3D; left;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">smallestChild &#x3D; right;</span><br><span class="line">&#125;</span><br><span class="line">if(arr[index] &gt; arr[smallestChild]) &#123; &#x2F;&#x2F;If Parent is greater than smallest child, then swap</span><br><span class="line">int tmp &#x3D; arr[index];</span><br><span class="line">arr[index] &#x3D; arr[smallestChild];</span><br><span class="line">arr[smallestChild] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HeapifyTopToBottom(smallestChild);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void levelOrder() &#123;</span><br><span class="line">System.out.println(&quot;Printing all the elements of this Heap...&quot;);&#x2F;&#x2F; Printing from 1 because 0th cell is dummy</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; sizeOfTree; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Heap Coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Heap</title>
    <link href="http://jbj828.github.io/2020/02/14/Al-BinaryHeap/"/>
    <id>http://jbj828.github.io/2020/02/14/Al-BinaryHeap/</id>
    <published>2020-02-14T13:16:25.000Z</published>
    <updated>2020-02-15T14:46:04.039Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Heap theory </p><a id="more"></a><br><p><strong>What is Binary Heap</strong></p><ul><li><p>Definition : Binary Heap is a Binary Tree with some special properties.</p><br><ol><li><p>Heap property</p><ul><li>Value of any given node must be &lt;= value of its children(Min-Heap)</li><li>Value of any given node must be &gt;= value of its children(Max-Heap)<br></li></ul></li><li><p>Complete tree</p><ul><li>All levels are completely filled except possibly the last level and the last level has all keys as left as possible.</li><li>This makes Binary Heap ideal candidate for Array Implementation.</li></ul></li></ol></li></ul><Br><p><strong>Why should we learn Binary Heap?</strong></p><p>There are cases when we want to find ‘min/max’ number among set of numbers in log(n) time. Also, we want to make sure that Inserting additional numbers does not take more than O(log n) time.</p><br><ul><li><p>Possible Solutions:</p><ol><li>Store the numbers in sorted Array &lt;- Take O(n) time complexity</li><li>Store the numbers in Linked List in sorted manner &lt;- Take O(n) time complexity</li></ol></li></ul><br>Binary Heap will solve this problem with O(log n).<br><p><strong>Types of Binary Heap</strong></p><ol><li>Min-Heap : If the value of each node is less than or equal to value of both of its children.</li><li>Max-Heap : If the value of each node is more than or equal to value of both of its children.</li></ol><br><p><strong>Practical Use</strong></p><ol><li>Prim’s Algorithm</li><li>Heap Sort</li><li>Priority Queue</li></ol><p><br><br></p><h4 id="Binary-Heap-Array-Representaion"><a href="#Binary-Heap-Array-Representaion" class="headerlink" title="Binary Heap - Array Representaion"></a>Binary Heap - Array Representaion</h4><ul><li>Implementation options<ul><li>Array based Implementation</li><li>Reference/Pointer based Implementation</li></ul></li></ul><br><p><strong>Insertion in Heap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insertValueInHeap(value)</span><br><span class="line">  if tree does not exists</span><br><span class="line">    return error message</span><br><span class="line">  else</span><br><span class="line">    insert &#39;value&#39; in first unused cell of Array</span><br><span class="line">    sizeOfHeap++</span><br><span class="line">    heapifyBottomToTop(sizeOfHeap)  ----- O(log n) : this means the height of the tree, the recursive call will step every node until it reaches the number which is smaller(Min-Heap) than its children</span><br></pre></td></tr></table></figure><Br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>ExtractMin from Heap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extractMin()</span><br><span class="line">  if tree does not exist</span><br><span class="line">    return error message</span><br><span class="line">  else</span><br><span class="line">    extract 1st cell of Array</span><br><span class="line">    promote last element to first</span><br><span class="line">    sizeOfHeap--</span><br><span class="line">    heapifyTopToBottom(1)</span><br></pre></td></tr></table></figure><Br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>Delete Heap</strong></p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteHeap()</span><br><span class="line">  set array to null</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1) </li></ul><br><p><strong>Reason why we don’t use Reference implementation(linked list) on Binary Heap</strong></p><ul><li>When we try to extract min/max number from the tree using reference, we need to loop all over the tree to find the value. This procedure takes O(n) time complexity. Inefficient!!</li></ul><p><Br><Br></p><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Heap theory &lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>AVL Tree Coding</title>
    <link href="http://jbj828.github.io/2020/02/14/AVL-code/"/>
    <id>http://jbj828.github.io/2020/02/14/AVL-code/</id>
    <published>2020-02-14T05:16:25.000Z</published>
    <updated>2020-02-14T05:17:03.311Z</updated>
    
    <content type="html"><![CDATA[<p>AVL Tree Coding</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">import node.*;</span><br><span class="line"></span><br><span class="line">public class AVLTree &#123;</span><br><span class="line">    BinaryNode root;</span><br><span class="line">    public BinaryNode getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor</span><br><span class="line">    AVLTree() &#123;</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert values in AVL Tree</span><br><span class="line">    void insert(int value) &#123;</span><br><span class="line">        root &#x3D; insert(root, value);</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    BinaryNode insert(BinaryNode currentNode, int value) &#123;</span><br><span class="line">        &#x2F;&#x2F; THIS ELSE_IF BLOCK IS BST CONDITION</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Successfully inserted &quot; + value + &quot; in AVL Tree&quot;);</span><br><span class="line">            return createNewNode(value);</span><br><span class="line">        &#125; else if (value &lt;&#x3D; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setLeft(insert(currentNode.getLeft(), value));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.setRight(insert(currentNode.getRight(), value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; THIS IS WHERE WE WILL DO AVL SPECIFIC WORK</span><br><span class="line">        int balance &#x3D; checkBalance(currentNode.getLeft(), currentNode.getRight());</span><br><span class="line">        if (balance &gt; 1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getLeft().getLeft(), currentNode.getLeft().getRight()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);&#x2F;&#x2F; LL Condition</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setLeft(leftRotate(currentNode.getLeft())); &#x2F;&#x2F; LR Condition</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (balance &lt; -1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getRight().getRight(), currentNode.getRight().getLeft()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);&#x2F;&#x2F; RR Condition</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setRight(rightRotate(currentNode.getRight()));&#x2F;&#x2F; RL Condition</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getLeft().setHeight(calculateHeight(currentNode.getLeft()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentNode.getRight() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getRight().setHeight(calculateHeight(currentNode.getRight()));</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        return currentNode;</span><br><span class="line"></span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    private BinaryNode leftRotate(BinaryNode currentNode) &#123;</span><br><span class="line">        BinaryNode newRoot &#x3D; currentNode.getRight();</span><br><span class="line">        currentNode.setRight(currentNode.getRight().getLeft());</span><br><span class="line">        newRoot.setLeft(currentNode);</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        newRoot.setHeight(calculateHeight(newRoot));</span><br><span class="line">        return newRoot;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    private BinaryNode rightRotate(BinaryNode currentNode) &#123;</span><br><span class="line">        BinaryNode newRoot &#x3D; currentNode.getLeft();</span><br><span class="line">        currentNode.setLeft(currentNode.getLeft().getRight());</span><br><span class="line">        newRoot.setRight(currentNode);</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        newRoot.setHeight(calculateHeight(newRoot));</span><br><span class="line">        return newRoot;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    private int checkBalance(BinaryNode rootLeft, BinaryNode rootRight) &#123;</span><br><span class="line">        if((rootLeft &#x3D;&#x3D; null) &amp;&amp; (rootRight &#x3D;&#x3D; null)) &#123; &#x2F;&#x2F;if current node is a leaf node then no need to check balance of its children</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if (rootLeft &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return -1 * (rootRight.getHeight() + 1); &#x2F;&#x2F; if left node node is not there then simply return right node&#39;s</span><br><span class="line">            &#x2F;&#x2F; height + 1</span><br><span class="line">            &#x2F;&#x2F; we need to make it -1 because blank height is considered</span><br><span class="line">            &#x2F;&#x2F; having height as &#39;-1&#39;</span><br><span class="line">        &#125; else if (rootRight &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return rootLeft.getHeight() + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return rootLeft.getHeight() - rootRight.getHeight(); &#x2F;&#x2F; +1 is not required, as both right and left child</span><br><span class="line">            &#x2F;&#x2F; exits and 1 gets nullified</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Calculate height of Node</span><br><span class="line">    private int calculateHeight(BinaryNode currentNode) &#123;</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1 + Math.max((currentNode.getLeft() !&#x3D; null ? currentNode.getLeft().getHeight() : -1),</span><br><span class="line">                (currentNode.getRight() !&#x3D; null ? currentNode.getRight().getHeight() : -1));</span><br><span class="line"></span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; creates a new blank new node</span><br><span class="line">    public BinaryNode createNewNode(int value) &#123;</span><br><span class="line">        BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">        node.setValue(value);</span><br><span class="line">        node.setHeight(0);&#x2F;&#x2F; Since this is a leaf node, its height is 0</span><br><span class="line">        return node;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Level order traversal of BST</span><br><span class="line">    void levelOrderTraversal() &#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        System.out.println(&quot;Printing Level order traversal of AVL Tree...&quot;);</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists !&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">            System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">            if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getLeft());</span><br><span class="line">            if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deleting a node from BST</span><br><span class="line">    public void deleteNodeOfBST(int value) &#123;</span><br><span class="line">        System.out.println(&quot;Deleting &quot; + value + &quot; from AVL Tree ...&quot;);</span><br><span class="line">        root &#x3D; deleteNodeOfBST(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method for delete</span><br><span class="line">    public BinaryNode deleteNodeOfBST(BinaryNode currentNode, int value) &#123;</span><br><span class="line">        &#x2F;&#x2F; THIS ELSE_IF BLOCK IS BST CONDITION</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        if (value &lt; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setLeft(deleteNodeOfBST(currentNode.getLeft(), value));</span><br><span class="line">        &#125; else if (value &gt; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setRight(deleteNodeOfBST(currentNode.getRight(), value));</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; If currentNode is the node to be deleted</span><br><span class="line">            &#x2F;&#x2F;System.out.println(&quot;currentNode is the node to be deleted&quot;);</span><br><span class="line">            if (currentNode.getLeft() !&#x3D; null &amp;&amp; currentNode.getRight() !&#x3D; null) &#123; &#x2F;&#x2F; if nodeToBeDeleted have both children</span><br><span class="line">                BinaryNode temp &#x3D; currentNode;</span><br><span class="line">                BinaryNode minNodeForRight &#x3D; minimumElement(temp.getRight());&#x2F;&#x2F; Finding minimum element from right subtree</span><br><span class="line">                currentNode.setValue(minNodeForRight.getValue()); &#x2F;&#x2F; Replacing current node with minimum node from right subtree</span><br><span class="line">                deleteNodeOfBST(currentNode.getRight(), minNodeForRight.getValue());&#x2F;&#x2F; Deleting minimum node from right now</span><br><span class="line">            &#125; else if (currentNode.getLeft() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only left child</span><br><span class="line">                currentNode &#x3D; currentNode.getLeft();</span><br><span class="line">            &#125; else if (currentNode.getRight() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only right child</span><br><span class="line">                currentNode &#x3D; currentNode.getRight();</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; if nodeToBeDeleted do not have child (Leaf node)</span><br><span class="line">                &#x2F;&#x2F;System.out.println(&quot;This node is leaf node&quot;);</span><br><span class="line">                currentNode &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            return currentNode;&#x2F;&#x2F; if it is a leaf node,then no need to do balancing for this node, do only for its ancestors</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; THIS IS WHERE WE WILL DO AVL SPECIFIC WORK</span><br><span class="line">        int balance &#x3D; checkBalance(currentNode.getLeft(), currentNode.getRight());</span><br><span class="line">        if (balance &gt; 1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getLeft().getLeft(), currentNode.getLeft().getRight()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);&#x2F;&#x2F; LL Condition</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setLeft(leftRotate(currentNode.getLeft())); &#x2F;&#x2F; LR Condition</span><br><span class="line">                currentNode &#x3D; rightRotate(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (balance &lt; -1) &#123;</span><br><span class="line">            if (checkBalance(currentNode.getRight().getRight(), currentNode.getRight().getLeft()) &gt; 0) &#123;</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);&#x2F;&#x2F; RR Condition</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                currentNode.setRight(rightRotate(currentNode.getRight()));&#x2F;&#x2F; RL Condition</span><br><span class="line">                currentNode &#x3D; leftRotate(currentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getLeft().setHeight(calculateHeight(currentNode.getLeft()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (currentNode.getRight() !&#x3D; null) &#123;</span><br><span class="line">            currentNode.getRight().setHeight(calculateHeight(currentNode.getRight()));</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line">        return currentNode;</span><br><span class="line"></span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Get minimum element in binary search tree</span><br><span class="line">    public static BinaryNode minimumElement(BinaryNode root) &#123;</span><br><span class="line">        if (root.getLeft() &#x3D;&#x3D; null)</span><br><span class="line">            return root;</span><br><span class="line">        else &#123;</span><br><span class="line">            return minimumElement(root.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void printTreeGraphically() &#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; level &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        int CurrentLevel &#x3D; 1;</span><br><span class="line">        boolean previousLevelWasAllNull &#x3D; false;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        level.add(1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\nPrinting Level order traversal of Tree...&quot;);</span><br><span class="line">        if(root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists !&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            if(CurrentLevel &#x3D;&#x3D; level.peek()) &#123; &#x2F;&#x2F;if we are in the same level</span><br><span class="line">                if(queue.peek()&#x3D;&#x3D;null) &#123;</span><br><span class="line">                    queue.add(null);level.add(CurrentLevel+1);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    queue.add(queue.peek().getLeft());level.add(CurrentLevel+1);</span><br><span class="line">                    queue.add(queue.peek().getRight());level.add(CurrentLevel+1);</span><br><span class="line">                    previousLevelWasAllNull &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(queue.remove() + &quot;  &quot;);level.remove();</span><br><span class="line">            &#125;else &#123; &#x2F;&#x2F;level has changed</span><br><span class="line">                System.out.println(&quot;\n&quot;);</span><br><span class="line">                CurrentLevel++;</span><br><span class="line">                if(previousLevelWasAllNull &#x3D;&#x3D; true) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                previousLevelWasAllNull &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#x2F;&#x2F;end of loop</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AVL Tree Coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>AVL Tree</title>
    <link href="http://jbj828.github.io/2020/02/12/Al-AVL-Tree/"/>
    <id>http://jbj828.github.io/2020/02/12/Al-AVL-Tree/</id>
    <published>2020-02-12T06:30:25.000Z</published>
    <updated>2020-02-12T14:47:49.330Z</updated>
    
    <content type="html"><![CDATA[<p>AVL Tree</p><a id="more"></a><p><strong>Why AVL Tree?</strong></p><ul><li>Depending on Incoming data, A Binary Search tree can get skewed and hence its performance starts going down. Instead of O(log n) for insertion/searching/deleting it can go up to O(n)</li><li>AVL tree attempts to solve this problem of ‘skewing’ by introducing concept called ‘Rotation’.</li></ul><p><strong>What is AVL Tree?</strong></p><ul><li>An AVL tree is a balanced ‘Binary Search Tree’ where the height of immediate subtrees of any node differs by at most one(also called balance factor).</li><li>If at any time heights differ by more than one, rebalancing is done to restore this property(called rotation).</li><li>Empty height is always considered -1.</li></ul><br><h3 id="Algorithm-of-AVL-Tree"><a href="#Algorithm-of-AVL-Tree" class="headerlink" title="Algorithm of AVL Tree"></a>Algorithm of AVL Tree</h3><ul><li>create, search, traverse Algorithm is totally same as the BST.</li></ul><h4 id="Insertion-of-node-in-AVL-Tree"><a href="#Insertion-of-node-in-AVL-Tree" class="headerlink" title="Insertion of node in AVL Tree"></a>Insertion of node in AVL Tree</h4><ul><li>Case#1 - Whene ‘rotation’ is not required.<ul><li>The algorithm is same as the BST Insertion.</li></ul></li><li>Case#2 - When ‘rotation is required(LL, LR, RR, RL).</li></ul><p><strong>Left-Left Condition</strong></p><ul><li>What is Left-Left condition?<ul><li>Left-Left Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Right Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rightRotate(currentDisbalancedNode)</span><br><span class="line">  newRoot &#x3D; currentDisbalancedNode.left</span><br><span class="line">  currentDisbalancedNode.left &#x3D; currentDisbalancedNode.left.right</span><br><span class="line">  newRoot.right &#x3D; currentDisbalancedNode</span><br><span class="line">  currentDisabledNode.height &#x3D; calculateHeight(currentDisbalancedNode)</span><br><span class="line">  newRoot.height &#x3D; calculateHeight(newRoot)</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Left-Right Condition</strong></p><ul><li>What is Left-Right condition?<ul><li>Left-Right Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Left Rotation followed by Right Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">leftRotate(currentDisbalancedNode&#39;sLeftChild)</span><br><span class="line">  newRoot &#x3D; currentDisbalancedNode&#39;sLeftChild.right</span><br><span class="line">  currentDisbalancedNode&#39;sLeftChild.right &#x3D; currentDisbalancedNode&#39;sLeftChild.right.left</span><br><span class="line">  newRoot.left &#x3D; currentDisbalancedNode&#39;sLeftChild</span><br><span class="line">  currentDisbalancedNode&#39;sLeftChild.Height &#x3D; calculateHeight(currentDisbalancedNode&#39;sLeftChild)</span><br><span class="line">  newRoot.Height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  rightRotate(currentDisbalancedNode)  ------ left-left Condition이랑 같음</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Right-Right Condition</strong></p><ul><li>What is Right-Right condition?<ul><li>Right-Right Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Left Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leftRotate(currentDisbalancedNode)</span><br><span class="line">  newRoot &#x3D; currentDisbalancedNode.right</span><br><span class="line">  currentDisbalancedNode.right &#x3D; currentDisbalancedNode.right.left</span><br><span class="line">  newRoot.left &#x3D; currentDisbalancedNode</span><br><span class="line">  currentDisbalancedNode.Height &#x3D; calculateHeight(currentDisbalancedNode)</span><br><span class="line">  newRoot.Height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Right-left Condition</strong></p><ul><li>What is Right-left condition?<ul><li>Right-left Node from currentNode is causing disbalance.</li><li>In this case we do a ‘Right Rotation followed by Left Rotation’.</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rightRotate(currentDisableNode&#39;sRight)</span><br><span class="line">  newRoot &#x3D; currentDisableNode&#39;sRight.left</span><br><span class="line">  currentDisableNode&#39;sRight.left.right &#x3D; currentDisableNode&#39;sRight</span><br><span class="line">  currentDisableNode&#39;sRight.height &#x3D; calculateHeight(currentDisableNode&#39;sRight)</span><br><span class="line">  newRoot.height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot;</span><br><span class="line"></span><br><span class="line">leftRotate(currentDisabledNode)</span><br><span class="line">  newRoot &#x3D; currentDisabledNode.right</span><br><span class="line">  currentDisabledNode.right &#x3D; currentDisabledNode.right.left</span><br><span class="line">  newRoot.left &#x3D; currentDisabledNode</span><br><span class="line">  currentDisabledNode.height &#x3D; calculateHeight(currentDisabledNode)</span><br><span class="line">  newRoot.height &#x3D; calculateHeight(newRoot)</span><br><span class="line">  return newRoot</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Insertion Algorithm in AVL Tree</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Node Insert(Node root, int data)</span><br><span class="line">  if(root &#x3D;&#x3D; null) return new Node(data)</span><br><span class="line">  else if(data &lt;&#x3D; root.data) root.left &#x3D; insert(root.left, data)</span><br><span class="line">  else root.right &#x3D; insert(root.right, data)</span><br><span class="line">  </span><br><span class="line">  int balance &#x3D; height(root.left) - height(root.right)</span><br><span class="line">  if(balance &gt; 1)</span><br><span class="line">    if height(root.left.left) &gt;&#x3D; height(root.left.right)</span><br><span class="line">      RightRotation(root) &#x2F;&#x2F;LL condition</span><br><span class="line">    else</span><br><span class="line">      LeftRotation(root.left)</span><br><span class="line">      RightRotation(root)  &#x2F;&#x2F; LR condition</span><br><span class="line"></span><br><span class="line">  else if(balance &lt; -1)  &#x2F;&#x2F; if right subtree is overloaded</span><br><span class="line">    if height(root.right.right) &gt;&#x3D; height(root.right.left)</span><br><span class="line">      LeftRotation(root)  &#x2F;&#x2F; RR condition</span><br><span class="line">    else</span><br><span class="line">      RightRotation(root.right)</span><br><span class="line">      LeftRotation(root)  &#x2F;&#x2F; RL condition</span><br><span class="line">  </span><br><span class="line">  root.height &#x3D; max(root.left, root.right) + 1</span><br><span class="line">  return root</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n)</li></ul><br><h4 id="Deletion-of-Node-from-AVL-Tree"><a href="#Deletion-of-Node-from-AVL-Tree" class="headerlink" title="Deletion of Node from AVL Tree"></a>Deletion of Node from AVL Tree</h4><ul><li>Deletion of a node<ul><li>Case#1 - When tree does not exists</li><li>Case#2 - When ‘rotation’ is not required(BST Conditions)<ul><li>Node to be deleted is leaf node</li><li>Node to be deleted is having 1 child</li><li>Node to be deleted has 2 children</li></ul></li><li>Case#3 - When ‘rotation’ is required(LL, LR, RR, RL)</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeOfAVL(currentNode, valueToBeDeleted)</span><br><span class="line">  if(currentNode &#x3D;&#x3D; null) return null;</span><br><span class="line"></span><br><span class="line">  if(valueToBeDeleted &lt; currentNode.value)</span><br><span class="line">    then currentNode.left &#x3D; deleteNodeOfAVL(currentNode.left, valueToBeDeleted)</span><br><span class="line">  else if(valueToBeDeleted &gt; currentNode.value)</span><br><span class="line">    then currentNode.right &#x3D; deleteNodeOfAVL(currentNode.right, valueToBeDeleted)</span><br><span class="line">  else  &#x2F;&#x2F;if the currentNode is the node to be deleted</span><br><span class="line">      if currentNode have both children, then find minimum element from right subtree(Case#3)</span><br><span class="line">          replace current node with minimum node from right subtree and delete minimum node from right</span><br><span class="line"></span><br><span class="line">      else if nodeToBeDeleted has only left child(Case#2)</span><br><span class="line">            then currentNode &#x3D; currentNode.left</span><br><span class="line">      else if nodeToBeDeleted has only right child</span><br><span class="line">      (Case#2)</span><br><span class="line">            then currentNode &#x3D; currentNode.right</span><br><span class="line">      </span><br><span class="line">      else &#x2F;&#x2F;if nodeToBeDeleted do not have child(Case#1)</span><br><span class="line">            currentNode &#x3D; null;</span><br><span class="line"></span><br><span class="line">  int balance &#x3D; checkBalance(currentNode.left, currentNode.right);</span><br><span class="line"></span><br><span class="line">  if(balance &gt; 1)</span><br><span class="line">      if(checkBalance(currentNode.left().left(), currentNode.left().right()) &gt; 0)</span><br><span class="line">          currentNode &#x3D; rightRotate(currentNode); &#x2F;&#x2F;LL Condition</span><br><span class="line">      </span><br><span class="line">      else </span><br><span class="line">          currentNode.left &#x3D; leftRotate(currentNode.left);</span><br><span class="line">          currentNode &#x3D; rightRotate  &#x2F;&#x2F;LR condition</span><br><span class="line">    </span><br><span class="line">    else if(balance &lt; -1)</span><br><span class="line">      if(checkBalance(currentNode.right().right(), currentNode.right().left()) &gt; 0)</span><br><span class="line">          currentNode &#x3D; leftRotate(currentNode); &#x2F;&#x2F;RR Condition</span><br><span class="line"></span><br><span class="line">      else </span><br><span class="line">          currentNode.right &#x3D; rightRotate(currentNode.right); &#x2F;&#x2F;RL condition</span><br><span class="line">          currentNode &#x3D; leftRotate(currentNode);</span><br><span class="line"></span><br><span class="line">  if(currentNode.left() !&#x3D; null) then currentNode.left().setHeight(calculateHeight(currentNode.left));</span><br><span class="line">  if(currentNode.right() !&#x3D; null) then currentNode.right().setHeight(calculateHeight(currentNode.right());</span><br><span class="line">  currentNode.setHeight(calculateHeight(currentNode));</span><br><span class="line"></span><br><span class="line">  return currentNode;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n)</li></ul><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AVL Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree Coding</title>
    <link href="http://jbj828.github.io/2020/02/11/Al-BST-code/"/>
    <id>http://jbj828.github.io/2020/02/11/Al-BST-code/</id>
    <published>2020-02-11T09:30:25.000Z</published>
    <updated>2020-02-11T10:25:35.382Z</updated>
    
    <content type="html"><![CDATA[<p>BST Coding</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import node.BinaryNode;</span><br><span class="line"></span><br><span class="line">public class BinarySearchTreeByLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    BinaryNode root;</span><br><span class="line"></span><br><span class="line">    public BinaryNode getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor</span><br><span class="line">    BinarySearchTreeByLinkedList() &#123;</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert values in BST</span><br><span class="line">    void insert(int value) &#123;</span><br><span class="line">        root &#x3D; insert(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method</span><br><span class="line">    BinaryNode insert(BinaryNode currentNode, int value) &#123;</span><br><span class="line">        if (currentNode &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; if root node is blank then insert new node there</span><br><span class="line">            System.out.println(&quot;Successfully inserted &quot; + value + &quot; in BST&quot;);</span><br><span class="line">            return createNewNode(value);</span><br><span class="line">        &#125; else if (value &lt;&#x3D; currentNode.getValue()) &#123;</span><br><span class="line">            currentNode.setLeft(insert(currentNode.getLeft(), value));</span><br><span class="line">            return currentNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentNode.setRight(insert(currentNode.getRight(), value));</span><br><span class="line">            return currentNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; creates a new blank new node</span><br><span class="line">    public BinaryNode createNewNode(int value) &#123;</span><br><span class="line">        BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">        node.setValue(value);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deleting a node from BST</span><br><span class="line">    public void deleteNodeOfBST(int value) &#123;</span><br><span class="line">        System.out.println(&quot;\n\nDeleting &quot; + value + &quot; from BST...&quot;);</span><br><span class="line">        deleteNodeOfBST(root,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Helper Method for delete</span><br><span class="line">    public BinaryNode deleteNodeOfBST(BinaryNode root, int value) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Value not found in BST&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (value &lt; root.getValue()) &#123;</span><br><span class="line">            root.setLeft(deleteNodeOfBST(root.getLeft(), value));</span><br><span class="line">        &#125; else if (value &gt; root.getValue()) &#123;</span><br><span class="line">            root.setRight(deleteNodeOfBST(root.getRight(), value));</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; If currentNode is the node to be deleted</span><br><span class="line"></span><br><span class="line">            if (root.getLeft() !&#x3D; null &amp;&amp; root.getRight() !&#x3D; null) &#123; &#x2F;&#x2F; if nodeToBeDeleted have both children</span><br><span class="line">                BinaryNode temp &#x3D; root;</span><br><span class="line">                BinaryNode minNodeForRight &#x3D; minimumElement(temp.getRight());&#x2F;&#x2F; Finding minimum element from right subtree</span><br><span class="line">                root.setValue(minNodeForRight.getValue()); &#x2F;&#x2F; Replacing current node with minimum node from right subtree</span><br><span class="line">                root.setRight(deleteNodeOfBST(root.getRight(), minNodeForRight.getValue()));  &#x2F;&#x2F; Deleting minimum node from right now</span><br><span class="line">            &#125; else if (root.getLeft() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only left child</span><br><span class="line">                root &#x3D; root.getLeft();</span><br><span class="line">            &#125; else if (root.getRight() !&#x3D; null) &#123;&#x2F;&#x2F; if nodeToBeDeleted has only right child</span><br><span class="line">                root &#x3D; root.getRight();</span><br><span class="line">            &#125; else &#x2F;&#x2F; if nodeToBeDeleted do not have child (Leaf node)</span><br><span class="line">                root &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Get minimum element in binary search tree</span><br><span class="line">    public static BinaryNode minimumElement(BinaryNode root) &#123;</span><br><span class="line">        if (root.getLeft() &#x3D;&#x3D; null)</span><br><span class="line">            return root;</span><br><span class="line">        else &#123;</span><br><span class="line">            return minimumElement(root.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search a node in BST</span><br><span class="line">    void searchForValue(int value) &#123;</span><br><span class="line">        searchForValue(root, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search a node in BST</span><br><span class="line">    BinaryNode searchForValue(BinaryNode node, int value) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Value: &quot; + value + &quot; not found in BST.&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else if (node.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">            System.out.println(&quot;Value: &quot; + value + &quot; found in BST.&quot;);</span><br><span class="line">            return node;</span><br><span class="line">        &#125; else if (value &lt; node.getValue()) &#123;</span><br><span class="line">            return searchForValue(node.getLeft(), value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return searchForValue(node.getRight(), value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Level order traversal of BST</span><br><span class="line">    void levelOrderTraversal() &#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        System.out.println(&quot;\nPrinting Level order traversal of Tree...&quot;);</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists !&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">            System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">            if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getLeft());</span><br><span class="line">            if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">                queue.add(presentNode.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete entire BST</span><br><span class="line">    public void deleteTree() &#123;</span><br><span class="line">        System.out.println(&quot;Deleting entire Tree...&quot;);</span><br><span class="line">        root &#x3D; null;</span><br><span class="line">        System.out.println(&quot;Tree deleted successfully !&quot;);</span><br><span class="line">    &#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void printTreeGraphically()&#123;</span><br><span class="line">        Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; level &#x3D; new LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        int CurrentLevel &#x3D; 1;</span><br><span class="line">        boolean previousLevelWasAllNull &#x3D; false;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        level.add(1);</span><br><span class="line"></span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            System.out.println(&quot;Tree does not exists&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            if(CurrentLevel &#x3D;&#x3D; level.peek())&#123;</span><br><span class="line">                if(queue.peek() &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    queue.add(null);</span><br><span class="line">                    level.add(CurrentLevel +1);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    queue.add(queue.peek().getLeft());</span><br><span class="line">                    level.add(CurrentLevel + 1);</span><br><span class="line">                    queue.add(queue.peek().getRight());</span><br><span class="line">                    level.add(CurrentLevel + 1);</span><br><span class="line">                    previousLevelWasAllNull &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(queue.remove() + &quot; &quot;);</span><br><span class="line">                level.remove();</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;\n&quot;);</span><br><span class="line">                CurrentLevel++;</span><br><span class="line">                if(previousLevelWasAllNull &#x3D;&#x3D; true)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                previousLevelWasAllNull &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BST Coding&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree</title>
    <link href="http://jbj828.github.io/2020/02/10/Al-BST/"/>
    <id>http://jbj828.github.io/2020/02/10/Al-BST/</id>
    <published>2020-02-10T14:30:25.000Z</published>
    <updated>2020-02-11T02:55:18.265Z</updated>
    
    <content type="html"><![CDATA[<p>The theory of BST</p><a id="more"></a><p><strong>What is BST?</strong></p><ul><li>Binary Search Tree(BST) is a Binary Tree which all the nodes follows the below mentioned properties<ul><li>The left sub-tree of a node has a key less than or equal to its parent node’s key.</li><li>The right sub tree of a node has a key greater than to its parent node’s key.</li></ul></li></ul><br><p><strong>Why should we learn BST?</strong></p><ul><li>Binary tree implemented by linked list has good space efficient compared to the BT implemented by Array. However, it is not good on Insertion, deletion, searching, traversing which has time complexity of O(n). BST will improve the time complexity of binary tree by O(log n).</li></ul><p><br><br></p><p><strong>Algorithm - Creation of blank BST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createBST()</span><br><span class="line">  Initialize Root with null</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1)</li></ul><br><p><strong>Algorithm - Searching a node in BST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BST_Search(root, value)  ------------T(n)</span><br><span class="line">  if(root is null)</span><br><span class="line">    return null</span><br><span class="line">  else if(root &#x3D;&#x3D; value)</span><br><span class="line">    return root</span><br><span class="line">  else if(value &lt; root)</span><br><span class="line">    BST_Search(root.left, value)  ----T(n&#x2F;2)</span><br><span class="line">  else if(value &gt; root)</span><br><span class="line">    BST_Search(root.right, value) ----T(n&#x2F;2)</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) —-beacuse of recursive call</li></ul><br><p><strong>Algorithm - Traverse in BST</strong></p><ul><li>Totally same as traversing Binary Tree</li></ul><br><p><strong>Algorithm - Inserting a node in BST</strong></p><ul><li>Cases<ul><li>BST is  blank</li><li>BST is non-blank</li></ul></li></ul><p>Using Stack on the behind of the scene.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BST_Insert(currentNode, valueToInsert)</span><br><span class="line">  if(currentNode is null)</span><br><span class="line">    create a node, insert &#39;valueToInsert&#39; in it</span><br><span class="line">  else if(valueToInsert &lt;&#x3D; currentNode&#39;s value)</span><br><span class="line">    currentNode.left &#x3D; BST_Insert(currentNode.left, valueToInsert)</span><br><span class="line">  else</span><br><span class="line">    currentNode.right &#x3D; BST_Insert(currentNode.right, valueToInsert)</span><br><span class="line">  return currentNode</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>Algorithm - Deleting a node in BST</strong></p><ul><li>Cases<ul><li>Node to be deleted is leaf node</li><li>Node to be deleted is having 1 child</li><li>Node to be deleted has 2 child</li></ul></li></ul><p>Using Stack on the behind of the scene.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeOfBST(root, valueToBeDeleted)  --------------------------------------T(n)</span><br><span class="line">  if(root &#x3D;&#x3D; null) return null;</span><br><span class="line">  if(valueToBeDeleted &lt; root.value)</span><br><span class="line">    then root.left &#x3D; deleteNodeOfBST(root.left, valueToBeDeleted)   ---------------T(n&#x2F;2)</span><br><span class="line">  else if(valueToBeDeleted &gt; root.value)</span><br><span class="line">    then root.right &#x3D; deleteNodeOfBST(root.right, valueToBeDeleted)  ---------------T(n&#x2F;2)</span><br><span class="line">  else &#x2F;&#x2F; if cuurentNode is the node to be deleted</span><br><span class="line">      if root have both children, then find minimum element from right subtree(Case#3)  -------------O(log n)</span><br><span class="line">          replace current node with minimum node from right subtree and delete minimum node from right</span><br><span class="line">      else if node ToBeDeleted has only left child(Case#2)</span><br><span class="line">            then root &#x3D; root.left();</span><br><span class="line">      else &#x2F;&#x2F; if node ToBeDeleted do not have child(Case#1)</span><br><span class="line">            root &#x3D; null;</span><br><span class="line">  return root;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(log n)</li><li>Space Complexity - O(log n) </li></ul><br><p><strong>Algorithm - Deleting entire tree in BST</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeleteBST()</span><br><span class="line">  root &#x3D; null;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(1)</li><li>Space Complexity - O(1) </li></ul><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The theory of BST&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Code(Array Implementation)</title>
    <link href="http://jbj828.github.io/2020/02/10/Al-BT-arrayCode/"/>
    <id>http://jbj828.github.io/2020/02/10/Al-BT-arrayCode/</id>
    <published>2020-02-10T13:30:25.000Z</published>
    <updated>2020-02-10T13:57:29.861Z</updated>
    
    <content type="html"><![CDATA[<p>Array Implementation code</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeByArray &#123;</span><br><span class="line">int [] arr;</span><br><span class="line">int lastUsedIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor for blank Tree</span><br><span class="line">public BinaryTreeByArray(int size) &#123;</span><br><span class="line">arr &#x3D; new int[size+1];</span><br><span class="line">this.lastUsedIndex &#x3D; 0; </span><br><span class="line">System.out.println(&quot;Blank Tree of size &quot; +size+ &quot; has been created !\n&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Check if array is full</span><br><span class="line">boolean isTreeFull()&#123;</span><br><span class="line">if(arr.length-1 &#x3D;&#x3D; lastUsedIndex) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; New node should be inserted at the first empty place in the array</span><br><span class="line">void insert(int value) &#123;</span><br><span class="line">if(!isTreeFull()) &#123;</span><br><span class="line">arr[lastUsedIndex+1] &#x3D; value;</span><br><span class="line">lastUsedIndex++;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot;+value+ &quot; in the tree!&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Could not insert value in the Tree as it is full !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;level-Order traversal of binary tree</span><br><span class="line">public void levelOrder() &#123;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;lastUsedIndex;i++ ) &#123;</span><br><span class="line">System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Pre-Order traversal of binary tree</span><br><span class="line">public void preOrder(int index) &#123;</span><br><span class="line">if (index &gt; lastUsedIndex) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(arr[index] + &quot; &quot;);</span><br><span class="line">preOrder(index * 2);</span><br><span class="line">preOrder(index * 2 + 1);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Post-Order Traversal of binary tree</span><br><span class="line">void postOrder(int index) &#123;</span><br><span class="line">if (index &gt; lastUsedIndex) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">postOrder(index * 2);</span><br><span class="line">postOrder(index * 2 + 1);</span><br><span class="line">System.out.print(arr[index] + &quot; &quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; In-Order Traversal of binary tree</span><br><span class="line">void inOrder(int index) &#123;</span><br><span class="line">if (index &gt; lastUsedIndex) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">inOrder(index * 2);</span><br><span class="line">System.out.print(arr[index] + &quot; &quot;);</span><br><span class="line">inOrder(index * 2 + 1);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Do a linear search on the array </span><br><span class="line">public int search(int value) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; lastUsedIndex; i++) &#123;</span><br><span class="line">if (arr[i] &#x3D;&#x3D; value) &#123;</span><br><span class="line">System.out.print(value +&quot; exists in the Tree! &quot;);</span><br><span class="line">System.out.println(&quot;It is at the location: &quot; + i);</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(value + &quot; does not exists in Tree !&quot;);</span><br><span class="line">System.out.println();</span><br><span class="line">return -1;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; delete operation of binary tree</span><br><span class="line">public void delete(int value) &#123;</span><br><span class="line">int location &#x3D; search(value);</span><br><span class="line">&#x2F;&#x2F;If Value does not exists in Array</span><br><span class="line">if (location &#x3D;&#x3D; -1) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;insert last element of the Tree into current location</span><br><span class="line">arr[location] &#x3D; arr[lastUsedIndex];</span><br><span class="line">lastUsedIndex--;</span><br><span class="line">System.out.println(&quot;Successfully deleted &quot; + value + &quot; from the Tree !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteTree()&#123;</span><br><span class="line">try &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Tree has been deleted successfully !&quot;);</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">System.out.println(&quot;There was an error deleting the tree.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Array Implementation code&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree - Array Implementation</title>
    <link href="http://jbj828.github.io/2020/02/09/Al-BT-array/"/>
    <id>http://jbj828.github.io/2020/02/09/Al-BT-array/</id>
    <published>2020-02-09T13:30:25.000Z</published>
    <updated>2020-02-10T05:59:33.729Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree implemented by Array</p><a id="more"></a><p><strong>How does tree looks when implemented via Array?</strong></p><ul><li>Left Child - cell[2x]</li><li>Right Child - cell[2x+1]</li><li>cell[0] = null </li></ul><br><p><strong>Creation of Binary tree</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createBinaryTree()</span><br><span class="line">  create a blank array of &#39;size&#39;</span><br><span class="line">  update lastUsedIndex to 0</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(1)</li><li>Space Complextiy : O(n)</li></ul><br><p><strong>Insertion of node</strong></p><ul><li>Insertion<ul><li>If array is full, return error message</li><li>Insert at first vacant cell in Array</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insertValueInBinaryTree()</span><br><span class="line">  if Tree is full</span><br><span class="line">    return error message</span><br><span class="line">  else</span><br><span class="line">    insert value in first unused cell of array</span><br><span class="line">    update lastUsedIndex</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(1)</li><li>Space Complextiy : O(1)</li></ul><br><p><strong>Search a node</strong></p><ul><li>Search<ul><li>When the value to be searched does not exists in the tree</li><li>When the value to be searched exists in the tree</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">searchValueInBinaryTree()</span><br><span class="line">  traverse the entire array from 1 to lastUsedIndex</span><br><span class="line">  if value is found</span><br><span class="line">    return success message</span><br><span class="line">  return error message</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(1)</li></ul><br><p><strong>In-Order Traversal</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InorderTraversal(index)</span><br><span class="line">  if index &gt; lastUsedIndex</span><br><span class="line">      return</span><br><span class="line">  else</span><br><span class="line">    InorderTraversal(index*2)</span><br><span class="line">    print current index.value</span><br><span class="line">    InorderTraversal(index*2 + 1)</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(n) —- stack에 쌓이기 때문에</li></ul><br><p><strong>Levle-Order Traversal</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">levelOrderTraversal()</span><br><span class="line">  loop: 1 to lastUsedIndex</span><br><span class="line">    print current index.value</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(1) </li></ul><br><p><strong>Deletion of Node</strong></p><ul><li>Deletion<ul><li>When the value to be deleted is not existing in the tree</li><li>When the value to be deleted is exists in the tree</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeFromBinaryTree()</span><br><span class="line">  search for desired value in array</span><br><span class="line">    if value found</span><br><span class="line">      replace this cell&#39;s value with last cell and update lastUsedIndex</span><br><span class="line">  return error message</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(n)</li><li>Space Complextiy : O(1) </li></ul><br><p><strong>Delete Binary Tree</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deleteBinaryTree()</span><br><span class="line">  set array as null</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity : O(1)</li><li>Space Complextiy : O(1) </li></ul><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree implemented by Array&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Code(Linked list)</title>
    <link href="http://jbj828.github.io/2020/02/08/Al-BT-linkedlist-code/"/>
    <id>http://jbj828.github.io/2020/02/08/Al-BT-linkedlist-code/</id>
    <published>2020-02-08T13:30:25.000Z</published>
    <updated>2020-02-08T12:10:30.642Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree code by linked list</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">import node.BinaryNode;</span><br><span class="line"></span><br><span class="line">public class BinaryTreeByLinkedList &#123;</span><br><span class="line">BinaryNode root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Constructor for creating a blank Binary Tree</span><br><span class="line">BinaryTreeByLinkedList()&#123;</span><br><span class="line">this.root &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; inserts a new node at deepest place in Tree</span><br><span class="line">void insert(int value) &#123;</span><br><span class="line">BinaryNode node &#x3D; new BinaryNode();</span><br><span class="line">node.setValue(value);</span><br><span class="line">if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">root &#x3D; node;</span><br><span class="line">System.out.println(&quot;Successfully inserted new node at Root !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">presentNode.setLeft(node);</span><br><span class="line">System.out.println(&quot;Successfully inserted new node !&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;else if (presentNode.getRight() &#x3D;&#x3D; null) &#123;</span><br><span class="line">presentNode.setRight(node);</span><br><span class="line">System.out.println(&quot;Successfully inserted new node !&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of else-if</span><br><span class="line">&#125;&#x2F;&#x2F;end of loop</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Search for a given value in binary tree</span><br><span class="line">void search(int value) &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">System.out.println(&quot;Value-&quot;+value+&quot; is found in Tree !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if (presentNode.getLeft()!&#x3D;null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight()!&#x3D;null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of loop</span><br><span class="line">System.out.println(&quot;Value-&quot;+value+&quot; is not found in Tree !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; delete node from binary tree</span><br><span class="line">void deleteNodeOfBinaryTree(int value) &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">&#x2F;&#x2F; if node is found then copy deepest node here and delete deepest node.</span><br><span class="line">if (presentNode.getValue() &#x3D;&#x3D; value) &#123;</span><br><span class="line">presentNode.setValue(getDeepestNode().getValue());</span><br><span class="line">DeleteDeepestNode();</span><br><span class="line">System.out.println(&quot;Deleted the node !!&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of while loop</span><br><span class="line">System.out.println(&quot;Did not find the node!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete deepest node</span><br><span class="line">public void DeleteDeepestNode() &#123;</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">BinaryNode previousNode, presentNode &#x3D; null;</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">previousNode &#x3D; presentNode;</span><br><span class="line">presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() &#x3D;&#x3D; null) &#123;</span><br><span class="line">previousNode.setRight(null);</span><br><span class="line">return;</span><br><span class="line">&#125;else if ((presentNode.getRight() &#x3D;&#x3D; null)) &#123;</span><br><span class="line">presentNode.setLeft(null);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of while loop</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; get last node of last level of binary tree</span><br><span class="line">public BinaryNode getDeepestNode() &#123;</span><br><span class="line">&#x2F;&#x2F; make an empty queue. Queue is Interface and LinkedList is class</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">BinaryNode presentNode &#x3D; null;</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">presentNode &#x3D; queue.remove();</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">return presentNode;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; pre-order traversal of binary tree</span><br><span class="line">void preOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">preOrder(node.getLeft());</span><br><span class="line">preOrder(node.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; post-order traversal of binary tree</span><br><span class="line">void postOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null)</span><br><span class="line">return;</span><br><span class="line">postOrder(node.getLeft());</span><br><span class="line">postOrder(node.getRight());</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; in-order traversal of binary tree</span><br><span class="line">void inOrder(BinaryNode node) &#123;</span><br><span class="line">if (node &#x3D;&#x3D; null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">inOrder(node.getLeft());</span><br><span class="line">System.out.print(node.getValue() + &quot; &quot;);</span><br><span class="line">inOrder(node.getRight());</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; level order traversal of binary tree</span><br><span class="line">void levelOrder() &#123;</span><br><span class="line">&#x2F;&#x2F; make a queue for level order. Queue is Interface and LinkedList is class</span><br><span class="line">Queue&lt;BinaryNode&gt; queue &#x3D; new LinkedList&lt;BinaryNode&gt;();</span><br><span class="line">queue.add(root);</span><br><span class="line">while (!queue.isEmpty()) &#123;</span><br><span class="line">BinaryNode presentNode &#x3D; queue.remove();</span><br><span class="line">System.out.print(presentNode.getValue() + &quot; &quot;);</span><br><span class="line">if (presentNode.getLeft() !&#x3D; null) &#123;</span><br><span class="line">queue.add(presentNode.getLeft());</span><br><span class="line">&#125;</span><br><span class="line">if (presentNode.getRight() !&#x3D; null)</span><br><span class="line">queue.add(presentNode.getRight());</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Delete Tree</span><br><span class="line">void deleteTree() &#123;</span><br><span class="line">root &#x3D; null;</span><br><span class="line">System.out.println(&quot;Binary Tree has been deleted successfully&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree code by linked list&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree - Traverse, Search, Insertion,(Linked List Implementation)</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-binaryTreeTraverse/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-binaryTreeTraverse/</id>
    <published>2020-02-06T14:30:25.000Z</published>
    <updated>2020-02-09T12:45:04.868Z</updated>
    
    <content type="html"><![CDATA[<p>Traverse Binary Tree</p><a id="more"></a><h3 id="Traversing-all-nodes-of-Binary-Tree-Linked-List-implementation"><a href="#Traversing-all-nodes-of-Binary-Tree-Linked-List-implementation" class="headerlink" title="Traversing all nodes of Binary Tree(Linked List implementation)"></a>Traversing all nodes of Binary Tree(Linked List implementation)</h3><p><strong>Depth first search</strong></p><ol><li>PreOrder Traversal</li><li>InOrder Traversal</li><li>PostOrder Traversal</li></ol><p><strong>Breadth first search</strong></p><ol><li>LevelOrder Traversal</li></ol><br><h3 id="PreOrder-Traversal-Using-Stack"><a href="#PreOrder-Traversal-Using-Stack" class="headerlink" title="* PreOrder Traversal(Using Stack)"></a>* PreOrder Traversal(Using Stack)</h3><ul><li>Root</li><li>Left Subtree</li><li>Right Subtree</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">preorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    print root</span><br><span class="line">    preorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    preorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)  : Recursive call로 많은 노드가 스택에 push, pull 되기 때문에</li></ul><br><h3 id="In-Order-Traversal-Using-Stack"><a href="#In-Order-Traversal-Using-Stack" class="headerlink" title="* In-Order Traversal(Using Stack)"></a>* In-Order Traversal(Using Stack)</h3><ul><li>Left Subtree</li><li>Root</li><li>Right Subtree</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">inorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    inorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    print root</span><br><span class="line">    inorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)</li></ul><br><h3 id="Post-Order-Traversal-Using-Stack"><a href="#Post-Order-Traversal-Using-Stack" class="headerlink" title="* Post-Order Traversal(Using Stack)"></a>* Post-Order Traversal(Using Stack)</h3><ul><li>Left Subtree</li><li>Right Subtree</li><li>Root</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postorderTraverse(root)&#123;  ----------------T(n)</span><br><span class="line">  if(root equals null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    postorderTraversal(root.left)  -------T(n&#x2F;2)</span><br><span class="line">    postorderTraversal(root.right) -------T(n&#x2F;2)</span><br><span class="line">    print root</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>Time Complexity - O(n)</li><li>Space Complexity - O(n)</li></ul><br><h3 id="Level-Order-Traversal-Using-Queue"><a href="#Level-Order-Traversal-Using-Queue" class="headerlink" title="* Level-Order Traversal(Using Queue)"></a>* Level-Order Traversal(Using Queue)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">levelOrderTraversal(root)&#123;</span><br><span class="line">  create a Queue(Q)</span><br><span class="line">  enqueue(root)</span><br><span class="line">  while(Queue is not empty)&#123;</span><br><span class="line">    enqueue() the child of the first element</span><br><span class="line">    dequeue() and print</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<p><br><br></p><h3 id="Searching-a-node-Using-Level-order-Traversal"><a href="#Searching-a-node-Using-Level-order-Traversal" class="headerlink" title="* Searching a node(Using Level-order Traversal)"></a>* Searching a node(Using Level-order Traversal)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">searchForGivenValue(value)&#123;</span><br><span class="line">  if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">    return error message</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    do a level order traversal</span><br><span class="line">      if value found</span><br><span class="line">        return success message</span><br><span class="line">    return unsuccessful message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<br><h3 id="Insertion-of-node-Using-Level-order-Traversal"><a href="#Insertion-of-node-Using-Level-order-Traversal" class="headerlink" title="* Insertion of node(Using Level-order Traversal)"></a>* Insertion of node(Using Level-order Traversal)</h3><ul><li>Insertion<ul><li>When the root is blank</li><li>Insert at first vacant child</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">insertNodeInBinaryTree()&#123;</span><br><span class="line">  if(root is blank)&#123;</span><br><span class="line">    insert new node at root</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    do a level order traversal and find the first blank space</span><br><span class="line">    insert in that blank place</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)<br><h3 id="Deletion-of-node-Using-Level-order-Traversal"><a href="#Deletion-of-node-Using-Level-order-Traversal" class="headerlink" title="* Deletion of node(Using Level-order Traversal)"></a>* Deletion of node(Using Level-order Traversal)</h3><ul><li>Insertion<ul><li>When the value to be deleted is not existing in the tree</li><li>When the value to be deleted exists in the tree</li></ul></li></ul><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deleteNodeFromBinaryTree()</span><br><span class="line">  search for the node to be deleted</span><br><span class="line">  find deepest node in the tree(using level order traversal)</span><br><span class="line">  copy deepest node&#39;s data in current node</span><br><span class="line">  delete deepest node</span><br></pre></td></tr></table></figure><br>* Time Complexity - O(n)* Space Complexity - O(n)]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Traverse Binary Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-binary-tree/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-binary-tree/</id>
    <published>2020-02-06T07:30:25.000Z</published>
    <updated>2020-02-06T14:12:54.625Z</updated>
    
    <content type="html"><![CDATA[<p>Binary Tree</p><a id="more"></a><p><strong>What is Binary Tree</strong></p><ul><li>A tree is called as binary tree if each node has zero, one or two child.</li><li>It is a family of Data Structure(BST, Heap tree, AVL, Red-Black, Syntax tree, Huffman Coding tree, etc.)</li></ul><p><br><br></p><p><strong>Why should we learn Binary tree</strong></p><ul><li>Prerequisite for more advanced trees</li><li>Is used in solving specific problems like:<ul><li>Huffman Coding</li><li>Heap(Priority Queue)</li><li>Expression parsing</li></ul></li></ul><p><br><Br></p><p><strong>Types of Binary Tree</strong></p><ul><li>Strict Binary Tree : if each node has either 2 children or none.</li><li>Full Binary Tree : if each non leaf node has 2 children and all lead nodes are at same level</li><li>Complete Binary Tree : if all levels are completely filled except possibly the last level and the last level has all keys as left as possible</li></ul><p><br><Br></p><p><strong>Tree Representation</strong></p><ul><li>Using Linked List</li><li>Using Array</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Binary Tree&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Tree</title>
    <link href="http://jbj828.github.io/2020/02/06/Al-tree/"/>
    <id>http://jbj828.github.io/2020/02/06/Al-tree/</id>
    <published>2020-02-06T06:30:25.000Z</published>
    <updated>2020-02-06T13:59:34.402Z</updated>
    
    <content type="html"><![CDATA[<p>Tree Data Structure</p><a id="more"></a><p><strong>Properties of Tree</strong></p><ul><li>Used to represent data in hierarchical form</li><li>Every Node(ideally) has 2 components(Data &amp; Reference)</li><li>It has a Root node and 2 disjoint binary tree called left subtree and right subtree</li></ul><p><br><br></p><p><strong>Why we learn Tree?</strong></p><ul><li>Linked List is better in space efficiency over Array. However, Linked List does not have that good time efficiency on Insertion, Deletion and Searching which is O(n). </li><li>Tree data structure overcomes the problem of linked list.</li></ul><p><br><br></p><p><strong>Tree Terminologies</strong></p><ul><li>Root : Node with no parent</li><li>Edge : Link from parent to child</li><li>Leaf : Node with no children</li><li>Sibling : Children of same parent</li><li>Ancestor : means parent, grand-parent, great grand parent, and so on for a given node</li><li>Depth of node : Length of the path from root to node</li><li>Height of node : Length of the path from that node to the deepest node</li><li>Height of tree : Same as height of Root node</li><li>Predecessor : Predecessor of a node is the immediate previous node in Inorder traversal of the Binary Tree.</li><li>Successor : Successor of a node is the immediate next node in Inorder traversal of the Binary Tree.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tree Data Structure&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Circular Queue(Array) / Linear Queue(Linked List)</title>
    <link href="http://jbj828.github.io/2020/02/05/Al-CircularQueue/"/>
    <id>http://jbj828.github.io/2020/02/05/Al-CircularQueue/</id>
    <published>2020-02-05T03:30:25.000Z</published>
    <updated>2020-02-06T13:59:57.474Z</updated>
    
    <content type="html"><![CDATA[<p>Queue</p><a id="more"></a><p><strong>Why learn Circular Queue?</strong></p><ul><li>dequeue operation causes blank cells Linear Queue(Array Implementation). </li><li>삭제하고 남은 자리를 뒤에서부터 차례대로 채워넣으면 되지만 time complexity가 O(n)이 되어버린다. 우리의 목표는 항상 O(1)이다.</li></ul><p><br><br></p><p><strong>time / space complexity</strong></p><ul><li>Array는 만들 때 space complexity가 O(n) 나머지 메서드는 모두 O(1)</li><li>Linked List는 모든 메서드 O(1)<br>그러므로 Queue를 사용하고자 한다면 Linked List가 Space Complexity에서 낫기 때문에 Linked List사용하도록 한다</li></ul><p><br><br></p><p><strong>When to Use / Avoid Queue</strong></p><ul><li><p>When to Use</p><ul><li>Helps manage the data in particular way(FIFO)</li><li>Not easily corrupted(No one can easily insert data in middle)<br></li></ul></li><li><p>When to Avoid</p><ul><li>Random access not possible - if we have done some mistake, it is costly to rectify</li></ul></li></ul><p><br><br></p><p><strong>Circular Queue Coding</strong></p><p>CircularQueueByArray.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">public class CircularQueueByArray&#123;</span><br><span class="line"></span><br><span class="line">int[] arr;</span><br><span class="line">int topOfQueue;</span><br><span class="line">int size;</span><br><span class="line">int start;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public CircularQueueByArray(int size) &#123;</span><br><span class="line">this.arr &#x3D; new int[size];</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">this.topOfQueue &#x3D; -1;</span><br><span class="line">start &#x3D; -1;</span><br><span class="line">System.out.println(&quot;Successfully created an empty queue of size: &quot;+size);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void enQueue(int value) &#123;</span><br><span class="line">if(arr&#x3D;&#x3D;null) &#123;</span><br><span class="line">System.out.println(&quot;Array is not yet created. Please create one first.&quot;);</span><br><span class="line">&#125;else if (isQueueFull()) &#123;</span><br><span class="line">System.out.println(&quot;\nQueue overflow error!!&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">initializeStartOfArray();</span><br><span class="line">if (topOfQueue+1 &#x3D;&#x3D; size) &#123; &#x2F;&#x2F;if top is already at last cell of array, then reset it to first cell</span><br><span class="line">topOfQueue&#x3D;0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">topOfQueue++;</span><br><span class="line">&#125;</span><br><span class="line">arr[topOfQueue] &#x3D; value;</span><br><span class="line">System.out.println(&quot;\nSuccessfully inserted &quot;+value+&quot; in the queue&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void initializeStartOfArray() &#123;</span><br><span class="line">if (start &#x3D;&#x3D; -1) &#123; </span><br><span class="line">start &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deQueue() &#123;</span><br><span class="line">if (isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Queue underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;\n---------------------------------------------&quot;);</span><br><span class="line">System.out.println(&quot;Before Dequeue..&quot;);printArray();</span><br><span class="line">System.out.println(&quot;\nDequeing value from Queue...&quot;);</span><br><span class="line">System.out.println(&quot;Dequeued: &quot;+arr[start]+&quot; from queue&quot;);</span><br><span class="line">arr[start] &#x3D; 0; &#x2F;&#x2F;initialize the unused cell to 0</span><br><span class="line">if (start &#x3D;&#x3D; topOfQueue) &#123; &#x2F;&#x2F;if there is only 1 element in Queue</span><br><span class="line">start &#x3D; topOfQueue &#x3D; -1;</span><br><span class="line">&#125;else if (start+1 &#x3D;&#x3D; size) &#123; &#x2F;&#x2F;if start has reached end of array, then start again from 0</span><br><span class="line">start&#x3D;0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;After Dequeue..&quot;);printArray();</span><br><span class="line">System.out.println(&quot;---------------------------------------------&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueEmpty() &#123;</span><br><span class="line">if (topOfQueue &#x3D;&#x3D; -1)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueFull() &#123;</span><br><span class="line">if (topOfQueue+1 &#x3D;&#x3D; start) &#123; &#x2F;&#x2F;If we have completed a circle, then we can say that Queue is full</span><br><span class="line">return true;</span><br><span class="line">&#125;else if ((start&#x3D;&#x3D;0) &amp;&amp; (topOfQueue+1 &#x3D;&#x3D; size)) &#123; &#x2F;&#x2F;Trivial case of Queue being full</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void peekOperation() &#123;</span><br><span class="line">&#x2F;&#x2F;if stack is not empty, return the value on top of stack</span><br><span class="line">if (!isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;\nPeeking value from queue...&quot;);</span><br><span class="line">System.out.println(arr[start]); </span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;The queue is empty!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteStack() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting the entire Queue...&quot;);</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Queue is successfully deleted !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Print entire array</span><br><span class="line">public void printArray() &#123;</span><br><span class="line">System.out.println(&quot;Array now...&quot;);</span><br><span class="line">for(int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class="line">System.out.print(arr[i]+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\nStart &#x3D; &quot; + start);</span><br><span class="line">System.out.println(&quot;End &#x3D; &quot;+ topOfQueue);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><p><br><br></p><p>QueueByLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import linkedList.SingleLinkedList;</span><br><span class="line"></span><br><span class="line">public class QueueByLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    SingleLinkedList list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;constructor</span><br><span class="line">    public QueueByLinkedList() &#123;</span><br><span class="line">        list &#x3D; new SingleLinkedList();</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void enQueue(int value) &#123;</span><br><span class="line">        if (list.getHead() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            list.createSingleLinkedList(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; push a value on last of queue, update list tail too</span><br><span class="line">            list.insertInLinkedList(value, list.getSize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int deQueue() &#123;</span><br><span class="line">        int value &#x3D; -1;</span><br><span class="line">        if (isQueueEmpty()) &#123;</span><br><span class="line">            System.out.println(&quot;Queue underflow error!!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            value &#x3D; list.getHead().getValue();</span><br><span class="line">            list.deletionOfNode(0);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        if (!isQueueEmpty())</span><br><span class="line">            return list.getHead().getValue();</span><br><span class="line">        else &#123;</span><br><span class="line">            System.out.println(&quot;The queue is empty!!&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public boolean isQueueEmpty() &#123;</span><br><span class="line">        if (list.getHead() &#x3D;&#x3D; null)</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void deleteStack() &#123;</span><br><span class="line">        list.setHead(null);</span><br><span class="line">    &#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Queue&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Queue</title>
    <link href="http://jbj828.github.io/2020/02/05/Al-Queue/"/>
    <id>http://jbj828.github.io/2020/02/05/Al-Queue/</id>
    <published>2020-02-05T01:30:25.000Z</published>
    <updated>2020-02-06T14:17:15.456Z</updated>
    
    <content type="html"><![CDATA[<p>Queue</p><a id="more"></a><p><strong>What is a Queue?</strong></p><ul><li><p>Property of Queue</p><ul><li>follows FIFO(First In First Out) method</li></ul></li><li><p>Reason why learning</p><ul><li>When we need to create an application which utilizes “first incoming data first”.</li></ul></li></ul><p><br><br></p><p><strong>Implementation options of Queue</strong></p><ul><li>Array<ul><li>Linear Queue</li><li>Circular Queue</li></ul></li></ul><br><ul><li>Linked list<ul><li>Linear Queue</li></ul></li></ul><p><br><br></p><p><strong>Linear Queue by Array</strong><br><br></p><p>QueueByArray.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">public class QueueByArray&#123;</span><br><span class="line"></span><br><span class="line">int[] arr;</span><br><span class="line">int topOfQueue;</span><br><span class="line">int beginningOfQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public QueueByArray(int size) &#123;</span><br><span class="line">this.arr &#x3D; new int[size];</span><br><span class="line">this.topOfQueue &#x3D; -1;</span><br><span class="line">this.beginningOfQueue &#x3D; -1;</span><br><span class="line">System.out.println(&quot;Successfully created an empty queue of size: &quot;+size);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void enQueue(int value) &#123;</span><br><span class="line">if (isQueueFull()) &#123;</span><br><span class="line">System.out.println(&quot;Queue overflow error!!&quot;);</span><br><span class="line">&#125;else if (isQueueEmpty()) &#123; &#x2F;&#x2F;If the queue is empty then we need to initialize beginning index </span><br><span class="line">beginningOfQueue&#x3D;0;</span><br><span class="line">topOfQueue++;</span><br><span class="line">arr[topOfQueue] &#x3D; value;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot;+value+&quot; in the queue&quot;);</span><br><span class="line">&#125;else &#123; &#x2F;&#x2F;if the queue already has some elements in it then no need to initialize beginning index</span><br><span class="line">topOfQueue++;</span><br><span class="line">arr[topOfQueue] &#x3D; value;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot;+value+&quot; in the queue&quot;);</span><br><span class="line">&#125;</span><br><span class="line">printQueue();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void printQueue() &#123;</span><br><span class="line">if(!isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Queue now ...&quot;);</span><br><span class="line">for(int i&#x3D;beginningOfQueue; i&lt;&#x3D;topOfQueue; i++) &#123;</span><br><span class="line">System.out.println(arr[i] + &quot;   &quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Queue is empty !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void deQueue() &#123;</span><br><span class="line">if (isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Queue underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Dequeing value from Queue...&quot;);</span><br><span class="line">System.out.println(&quot;Dequeued: &quot;+arr[beginningOfQueue]+&quot; from queue&quot;);</span><br><span class="line">beginningOfQueue++;</span><br><span class="line">if(beginningOfQueue &gt; topOfQueue) &#123; &#x2F;&#x2F;If last element in the Queue is Dequeued</span><br><span class="line">beginningOfQueue &#x3D; topOfQueue &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printQueue();</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueEmpty() &#123;</span><br><span class="line">if ((beginningOfQueue &#x3D;&#x3D; -1) || (beginningOfQueue &#x3D;&#x3D; arr.length))</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isQueueFull() &#123;</span><br><span class="line">if (topOfQueue &#x3D;&#x3D; arr.length-1) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void peekOperation() &#123;</span><br><span class="line">if (!isQueueEmpty()) &#123;</span><br><span class="line">System.out.println(arr[beginningOfQueue]); </span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;The queue is empty!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteQueue() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Queue is successfully deleted !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Queue&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Stack</title>
    <link href="http://jbj828.github.io/2020/02/04/Stack/"/>
    <id>http://jbj828.github.io/2020/02/04/Stack/</id>
    <published>2020-02-04T02:30:25.000Z</published>
    <updated>2020-02-06T13:59:45.266Z</updated>
    
    <content type="html"><![CDATA[<p>Stack data structure</p><a id="more"></a><p><strong>Implementation options of Stack</strong></p><ul><li>Array<ul><li>pros : Easy to implement</li><li>cons : Fixed size</li></ul></li></ul><br><ul><li>Linked List<ul><li>pros : Variable size</li><li>cons : Moderate in implementation</li></ul></li></ul><br><br><p><strong>When to use / avoid Stack</strong><br><br></p><ul><li>When to use<ul><li>Helps manage the data in particular way(LIFO)</li><li>Cannnot be easily corrupted(No one can insert data in middle)<br></li></ul></li><li>When to avoid<ul><li>Random access not possible - if we have done some mistake, its costly to rectify.</li></ul></li></ul><p><br><br></p><p><strong>Stack By Array</strong></p><ul><li>StackByArray.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class StackByArray &#123;</span><br><span class="line"></span><br><span class="line">int[] arr;</span><br><span class="line">int topOfStack;&#x2F;&#x2F;keeps track of the cell which is last occupied in Array, this will help in insertion&#x2F;deletion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public StackByArray(int size) &#123;</span><br><span class="line">this.arr &#x3D; new int[size];</span><br><span class="line">this.topOfStack &#x3D; -1;</span><br><span class="line">System.out.println(&quot;Successfully created an empty Stack of Size: &quot;+size);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void push(int value) &#123;</span><br><span class="line">&#x2F;&#x2F;if array is full, show stack overflow error</span><br><span class="line">if (isFullStack()) &#123;</span><br><span class="line">System.out.println(&quot;Stack overflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">arr[topOfStack+1] &#x3D; value;</span><br><span class="line">topOfStack++;</span><br><span class="line">System.out.println(&quot;Successfully inserted &quot; + value + &quot; in the stack&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void pop() &#123;</span><br><span class="line">&#x2F;&#x2F;if array is empty, show stack underflow error</span><br><span class="line">if (isEmptyStack()) &#123;</span><br><span class="line">System.out.println(&quot;Stack underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Poping value from Stack: &quot; + arr[topOfStack] + &quot;...&quot;);</span><br><span class="line">topOfStack--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isEmptyStack() &#123;</span><br><span class="line">&#x2F;&#x2F;if top pointer is zero, the stack is empty</span><br><span class="line">if (topOfStack &#x3D;&#x3D; -1)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isFullStack() &#123;</span><br><span class="line">if (topOfStack &#x3D;&#x3D; arr.length-1) &#123;</span><br><span class="line">System.out.println(&quot;Stack is full !&quot;);</span><br><span class="line">return true;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void peekOperation() &#123;</span><br><span class="line">if (!isEmptyStack())</span><br><span class="line">System.out.println(&quot;Top of Stack: &quot; + arr[topOfStack]);</span><br><span class="line">else &#123;</span><br><span class="line">System.out.println(&quot;The stack is empty!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();System.out.println();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteStack() &#123;</span><br><span class="line">arr &#x3D; null;</span><br><span class="line">System.out.println(&quot;Stack is successfully deleted&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure></li></ul><p><br><br></p><p><strong>Stack By Linked List</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line">import linkedList.SingleLinkedList;</span><br><span class="line"></span><br><span class="line">public class StackByLinkedList &#123;</span><br><span class="line"></span><br><span class="line">SingleLinkedList list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;constructor</span><br><span class="line">public  StackByLinkedList() &#123;</span><br><span class="line">list &#x3D; new SingleLinkedList();</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void push(int value) &#123;</span><br><span class="line">if(list.getHead()&#x3D;&#x3D; null) &#123;</span><br><span class="line">list.createSingleLinkedList(value);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">list.insertInLinkedList(value, 0);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Inserted &quot; + value + &quot; in Stack !&quot;);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int pop() &#123;</span><br><span class="line">int value &#x3D; -1;</span><br><span class="line">if (isEmpty()) &#123;</span><br><span class="line">System.out.println(&quot;Stack underflow error!!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">value &#x3D; list.getHead().getValue();</span><br><span class="line">list.deletionOfNode(0);</span><br><span class="line">&#125;</span><br><span class="line">return value;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">if (list.getHead() &#x3D;&#x3D; null)</span><br><span class="line">return true;</span><br><span class="line">else</span><br><span class="line">return false;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int peek() &#123;</span><br><span class="line">if (!isEmpty())</span><br><span class="line">return list.getHead().getValue();</span><br><span class="line">else &#123;</span><br><span class="line">System.out.println(&quot;The stack is empty!!&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void deleteStack() &#123;</span><br><span class="line">list.setHead(null);</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Stack data structure&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Circular Double Linked List</title>
    <link href="http://jbj828.github.io/2020/02/03/Al-circularDoubleLinkedList/"/>
    <id>http://jbj828.github.io/2020/02/03/Al-circularDoubleLinkedList/</id>
    <published>2020-02-03T02:30:25.000Z</published>
    <updated>2020-02-03T02:19:49.566Z</updated>
    
    <content type="html"><![CDATA[<p>The method which could be applied to Circular Double Linked List</p><a id="more"></a><p>DoubleCircularLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">package com.chung</span><br><span class="line"></span><br><span class="line">public class DoubleCircularLinkedList &#123;</span><br><span class="line">private DoubleNode head;</span><br><span class="line">private DoubleNode tail;</span><br><span class="line">private int size;&#x2F;&#x2F; denotes size of list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSize(int size) &#123;</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DoubleNode createDoubleLinkedList(int nodeValue) &#123;</span><br><span class="line">head &#x3D; new DoubleNode();</span><br><span class="line">DoubleNode node &#x3D; new DoubleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">node.setNext(node);</span><br><span class="line">node.setPrev(node);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">tail &#x3D; node;</span><br><span class="line">size &#x3D; 1;&#x2F;&#x2F; size &#x3D;1</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DoubleNode getHead() &#123;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHead(DoubleNode head) &#123;</span><br><span class="line">this.head &#x3D; head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public DoubleNode getTail() &#123;</span><br><span class="line">return tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTail(DoubleNode tail) &#123;</span><br><span class="line">this.tail &#x3D; tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getLast() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLast(int last) &#123;</span><br><span class="line">this.size &#x3D; last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertInLinkedList(int nodeValue, int location) &#123;</span><br><span class="line">DoubleNode node &#x3D; new DoubleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);</span><br><span class="line">return; &#x2F;&#x2F; Linked List does not exists</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; insert at first position</span><br><span class="line">node.setNext(head);</span><br><span class="line">node.setPrev(tail);</span><br><span class="line">head.setPrev(node);</span><br><span class="line">tail.setNext(node);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">&#125; else if (location &gt;&#x3D; size) &#123; &#x2F;&#x2F; insert at last position</span><br><span class="line">node.setNext(head);</span><br><span class="line">node.setPrev(tail);</span><br><span class="line">head.setPrev(node);</span><br><span class="line">tail.setNext(node);</span><br><span class="line">tail &#x3D; node; &#x2F;&#x2F; to keep track of last node</span><br><span class="line">&#125; else &#123;&#x2F;&#x2F; insert at specified location</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">while (index &lt; location - 1) &#123;&#x2F;&#x2F; loop till we reach specified node</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">node.setPrev(tempNode);</span><br><span class="line">node.setNext(tempNode.getNext());</span><br><span class="line">tempNode.setNext(node);</span><br><span class="line">node.getNext().setPrev(node);</span><br><span class="line">&#125;</span><br><span class="line">size++;&#x2F;&#x2F; one node added so size increments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean existsLinkedList() &#123;</span><br><span class="line">&#x2F;&#x2F; if head is not null retrun true otherwise return false</span><br><span class="line">return head !&#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Traverse Linked List</span><br><span class="line">void traverseLinkedList() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if (i !&#x3D; size - 1) &#123;</span><br><span class="line">System.out.print(&quot; -&gt; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse Linked List reverse order</span><br><span class="line">void traverseLinkedListInReverseOrder() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode &#x3D; tail;</span><br><span class="line">System.out.println(&quot;\nPrinting Linked list in reverse order...&quot;);</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if (i !&#x3D; size-1) &#123;</span><br><span class="line">System.out.print(&quot; &lt;- &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getPrev();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse Linked List</span><br><span class="line">void printHeadUsingTail() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;\n\nPrinting Tail...&quot;);</span><br><span class="line">System.out.println(tail.getValue());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nPrinting Head using Head reference...&quot;);</span><br><span class="line">System.out.println(head.getValue());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;\nPrinting Head using Tail reference...&quot;);</span><br><span class="line">System.out.println(tail.getNext().getValue());</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Deletion of linked list</span><br><span class="line">void deleteLinkedList() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting Linked List...&quot;);</span><br><span class="line">if (tail &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;Linked List is already deleted, nothing to delete anymore !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">head.setPrev(null);</span><br><span class="line">tail.setNext(null);</span><br><span class="line">head &#x3D; null;</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">System.out.println(&quot;Linked List deleted successfully !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Searching a specified value in linked list</span><br><span class="line">boolean searchNode(int nodeValue) &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">traverseLinkedList();</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">if (tempNode.getValue() &#x3D;&#x3D; nodeValue) &#123;</span><br><span class="line">System.out.print(&quot;Found the node at location: &quot; + i);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;Node not found!! &quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deletes a node having a given value</span><br><span class="line">public void deletionOfNode(int location) &#123;</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);&#x2F;&#x2F; Linked List does not exists</span><br><span class="line">return;</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; we want to delete first element</span><br><span class="line">if (getSize() &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; if this is the only node in this list</span><br><span class="line">head.setNext(null);</span><br><span class="line">head.setPrev(null);</span><br><span class="line">head &#x3D; tail &#x3D; null;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">head &#x3D; head.getNext();</span><br><span class="line">head.setPrev(null);</span><br><span class="line">tail.setNext(head);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (location &gt;&#x3D; getSize()) &#123; &#x2F;&#x2F; If location is not in range or equal, then delete last node</span><br><span class="line">if (getSize() &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; if this is the only element in the list</span><br><span class="line">head.setNext(null);</span><br><span class="line">head.setPrev(null);</span><br><span class="line">tail &#x3D; head &#x3D; null;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">tail &#x3D; tail.getPrev();</span><br><span class="line">tail.setNext(head);</span><br><span class="line">head.setPrev(tail);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F; if any inside node is to be deleted</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; location - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F; we need to traverse till we find the location</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(tempNode.getNext().getNext()); &#x2F;&#x2F; delete the required node</span><br><span class="line">tempNode.getNext().setPrev(tempNode);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125; &#x2F;&#x2F; end of else</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><p>DoubleNode.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class DoubleNode &#123;</span><br><span class="line"></span><br><span class="line">    private int value;</span><br><span class="line">    private DoubleNode prev;</span><br><span class="line">    private DoubleNode next;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DoubleNode getPrev() &#123;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrev(DoubleNode prev) &#123;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DoubleNode getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(DoubleNode next) &#123;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return value + &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The method which could be applied to Circular Double Linked List&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Double Linked List</title>
    <link href="http://jbj828.github.io/2020/02/02/DoubleLinkedList/"/>
    <id>http://jbj828.github.io/2020/02/02/DoubleLinkedList/</id>
    <published>2020-02-02T14:46:25.000Z</published>
    <updated>2020-02-02T14:39:12.132Z</updated>
    
    <content type="html"><![CDATA[<p>The method which could be applied to Double Linked List</p><a id="more"></a><p>DoubleLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class DoubleLinkedList &#123;</span><br><span class="line">DoubleNode head;</span><br><span class="line">DoubleNode tail;</span><br><span class="line">int size;&#x2F;&#x2F;denotes size of list</span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSize(int size) &#123;</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DoubleNode createDoubleLinkedList(int nodeValue) &#123;</span><br><span class="line">head &#x3D; new DoubleNode();</span><br><span class="line">DoubleNode node &#x3D; new DoubleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">node.setNext(null);</span><br><span class="line">node.setPrev(null);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">tail &#x3D; node;</span><br><span class="line">size&#x3D;1;&#x2F;&#x2F; size &#x3D;1</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void insertInLinkedList(int nodeValue, int location) &#123;</span><br><span class="line">DoubleNode node &#x3D; new DoubleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);</span><br><span class="line">return; &#x2F;&#x2F; Linked List does not exists</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; insert at first position</span><br><span class="line">node.setNext(head);</span><br><span class="line">node.setPrev(null);</span><br><span class="line">head.setPrev(node);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">&#125; else if (location &gt;&#x3D; size) &#123;&#x2F;&#x2F; insert at last position</span><br><span class="line">node.setNext(null);</span><br><span class="line">tail.setNext(node);</span><br><span class="line">node.setPrev(tail);</span><br><span class="line">tail &#x3D; node; &#x2F;&#x2F; to keep track of last node</span><br><span class="line">&#125; else &#123;&#x2F;&#x2F; insert at specified location</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">while (index &lt; location - 1) &#123;&#x2F;&#x2F; loop till we reach specified node</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">node.setPrev(tempNode);</span><br><span class="line">node.setNext(tempNode.getNext());</span><br><span class="line">tempNode.setNext(node);</span><br><span class="line">node.getNext().setPrev(node);</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean existsLinkedList() &#123;</span><br><span class="line">&#x2F;&#x2F;if head is not null retrun true otherwise return false</span><br><span class="line">return head!&#x3D;null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Traverse the linked list from head to last</span><br><span class="line">void traverseLinkedList() &#123;</span><br><span class="line">if(existsLinkedList()) &#123;</span><br><span class="line">&#x2F;&#x2F;System.out.println(&quot;Linked List now: &quot;);</span><br><span class="line">DoubleNode tempNode&#x3D;head;</span><br><span class="line">for(int i &#x3D;0; i&lt;size;i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if(i!&#x3D;size-1) &#123;</span><br><span class="line">System.out.print(&quot; -&gt; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode&#x3D;tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse the linked list from head to last</span><br><span class="line">void traverseLinkedListInReverseOrder() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode &#x3D; tail;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if (i !&#x3D; size-1) &#123;</span><br><span class="line">System.out.print(&quot; &lt;- &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getPrev();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;delete whole linked list</span><br><span class="line">void deleteLinkedList() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting Linked List...&quot;);</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">tempNode.setPrev(null);</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head &#x3D; null;</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">System.out.println(&quot;Linked List deleted successfully !&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Search for a node in linked list </span><br><span class="line">boolean searchNode(int nodeValue) &#123;</span><br><span class="line">if(existsLinkedList()) &#123;</span><br><span class="line">DoubleNode tempNode&#x3D;head;</span><br><span class="line">for(int i &#x3D;0; i&lt;size;i++) &#123;</span><br><span class="line">if(tempNode.getValue()&#x3D;&#x3D;nodeValue) &#123;</span><br><span class="line">System.out.print(&quot;Found the node at locaiton: &quot; + i);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">tempNode&#x3D;tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;Node not found!! &quot;);</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Deletes a node having a given value</span><br><span class="line">public void deletionOfNode(int location) &#123;</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);&#x2F;&#x2F; Linked List does not exists</span><br><span class="line">return;</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; we want to delete first element</span><br><span class="line">if (getSize() &#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; if this is the only node in this list</span><br><span class="line">head &#x3D; tail &#x3D; null;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">head &#x3D; head.getNext();</span><br><span class="line">head.setPrev(null);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (location &gt;&#x3D; getSize()) &#123; &#x2F;&#x2F; If location is not in range or equal, then delete last node</span><br><span class="line">DoubleNode tempNode &#x3D; tail.getPrev(); &#x2F;&#x2F; temp node points to 2nd last node</span><br><span class="line">if (tempNode &#x3D;&#x3D; head) &#123; &#x2F;&#x2F; if this is the only element in the list</span><br><span class="line">tail &#x3D; head &#x3D; null;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(null);</span><br><span class="line">tail &#x3D; tempNode;</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line"></span><br><span class="line">&#125; else &#123; &#x2F;&#x2F; if any inside node is to be deleted</span><br><span class="line">DoubleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; location - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F; we need to traverse till we find the location</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(tempNode.getNext().getNext()); &#x2F;&#x2F; delete the required node</span><br><span class="line">tempNode.getNext().setPrev(tempNode);</span><br><span class="line">setSize(getSize() - 1);</span><br><span class="line">&#125; &#x2F;&#x2F; end of else</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><p>DoubleNode.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class DoubleNode &#123;</span><br><span class="line"></span><br><span class="line">    private int value;</span><br><span class="line">    private DoubleNode prev;</span><br><span class="line">    private DoubleNode next;</span><br><span class="line"></span><br><span class="line">    public int getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setValue(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DoubleNode getPrev() &#123;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrev(DoubleNode prev) &#123;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public DoubleNode getNext() &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNext(DoubleNode next) &#123;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return value + &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The method which could be applied to Double Linked List&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Circular Single Linked List</title>
    <link href="http://jbj828.github.io/2020/02/02/CircularSingleLinkedList/"/>
    <id>http://jbj828.github.io/2020/02/02/CircularSingleLinkedList/</id>
    <published>2020-02-02T06:46:25.000Z</published>
    <updated>2020-02-02T06:42:52.699Z</updated>
    
    <content type="html"><![CDATA[<p>The method which could be applied to Circular Single Linked List</p><a id="more"></a><p>SingleCircularLinkedList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class SingleCircularLinkedList &#123;</span><br><span class="line">private SingleNode head;</span><br><span class="line">private SingleNode tail;</span><br><span class="line">private int size;&#x2F;&#x2F; denotes size of list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SingleNode createSingleLinkedList(int nodeValue) &#123;</span><br><span class="line">head &#x3D; new SingleNode();</span><br><span class="line">SingleNode node &#x3D; new SingleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">node.setNext(node);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">tail &#x3D; node;</span><br><span class="line">size &#x3D; 1;&#x2F;&#x2F; size &#x3D;1</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SingleNode getHead() &#123;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHead(SingleNode head) &#123;</span><br><span class="line">this.head &#x3D; head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SingleNode getTail() &#123;</span><br><span class="line">return tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTail(SingleNode tail) &#123;</span><br><span class="line">this.tail &#x3D; tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getSize() &#123;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSize(int size) &#123;</span><br><span class="line">this.size &#x3D; size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insertInLinkedList(int nodeValue, int location) &#123;</span><br><span class="line">SingleNode node &#x3D; new SingleNode();</span><br><span class="line">node.setValue(nodeValue);</span><br><span class="line">System.out.println(&quot;Inserting new node at location: &quot; + location);</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);</span><br><span class="line">return; &#x2F;&#x2F; Linked List does not exists</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; insert at first position</span><br><span class="line">node.setNext(head);</span><br><span class="line">head &#x3D; node;</span><br><span class="line">tail.setNext(node); &#x2F;&#x2F; update tail</span><br><span class="line">&#125; else if (location &gt;&#x3D; size) &#123;&#x2F;&#x2F; insert at last position</span><br><span class="line">tail.setNext(node);</span><br><span class="line">tail &#x3D; node; &#x2F;&#x2F; to keep track of last node</span><br><span class="line">tail.setNext(head); &#x2F;&#x2F; update tail to circularly point head</span><br><span class="line">&#125; else &#x2F;&#x2F; insert at specified location</span><br><span class="line">&#123;</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">while (index &lt; location - 1) &#123;&#x2F;&#x2F; loop till we reach specified node</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">index++;</span><br><span class="line">&#125;&#x2F;&#x2F; insert new node after tempNode</span><br><span class="line">node.setNext(tempNode.getNext());</span><br><span class="line">tempNode.setNext(node);</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean existsLinkedList() &#123;</span><br><span class="line">&#x2F;&#x2F; if head is not null retrun true otherwise return false</span><br><span class="line">return head !&#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse Linked List</span><br><span class="line">void traverseLinkedList() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.print(tempNode.getValue());</span><br><span class="line">if (i !&#x3D; size - 1) &#123;</span><br><span class="line">System.out.print(&quot; -&gt; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;\nLinked List does not exists !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Traverse Linked List</span><br><span class="line">void printHeadUsingTail() &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;Printing Tail...&quot;);</span><br><span class="line">System.out.println(tail.getValue());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Printing Head using Head reference...&quot;);</span><br><span class="line">System.out.println(head.getValue());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Printing Head using Tail reference...&quot;);</span><br><span class="line">System.out.println(tail.getNext().getValue());</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;Linked List does not exists&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Delete linked list</span><br><span class="line">void deleteLinkedList() &#123;</span><br><span class="line">System.out.println(&quot;\n\nDeleting Linked List...&quot;);</span><br><span class="line">head &#x3D; null;</span><br><span class="line">if(tail &#x3D;&#x3D; null) &#123;</span><br><span class="line">System.out.println(&quot;Linked List is already deleted, nothing to delete !&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">tail.setNext(null);</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">System.out.println(&quot;Linked List deleted successfully !&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Search given value in Linked List</span><br><span class="line">boolean searchNode(int nodeValue) &#123;</span><br><span class="line">if (existsLinkedList()) &#123;</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; System.out.print(tempNode.value);</span><br><span class="line">if (tempNode.getValue() &#x3D;&#x3D; nodeValue) &#123;</span><br><span class="line">System.out.print(&quot;Found the node at location: &quot;+i);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">tempNode &#x3D; tempNode.getNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;Node not found!! &quot;);</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void deletionOfNode(int location) &#123;</span><br><span class="line">if (!existsLinkedList()) &#123;</span><br><span class="line">System.out.println(&quot;The linked list does not exist!!&quot;);&#x2F;&#x2F; Linked List does not exists</span><br><span class="line">return;</span><br><span class="line">&#125; else if (location &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; we want to delete first element</span><br><span class="line">head &#x3D; head.getNext();</span><br><span class="line">tail.setNext(head);</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line">if(getSize() &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; if there are no more nodes in this list</span><br><span class="line">tail &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if (location &gt;&#x3D; getSize())&#123; &#x2F;&#x2F;If location is not in range or equal, then delete last node</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; size - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F;temp node points to 2nd last node</span><br><span class="line">&#125;</span><br><span class="line">if (tempNode &#x3D;&#x3D; head) &#123; &#x2F;&#x2F;if this is the only element in the list</span><br><span class="line">tail &#x3D; head &#x3D; null;</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(head); </span><br><span class="line">tail&#x3D; tempNode;</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line"></span><br><span class="line">&#125;else &#123; &#x2F;&#x2F;if any inside node is to be deleted</span><br><span class="line">SingleNode tempNode &#x3D; head;</span><br><span class="line">for (int i &#x3D; 0; i &lt; location - 1; i++) &#123;</span><br><span class="line">tempNode &#x3D; tempNode.getNext(); &#x2F;&#x2F; we need to traverse till we find the location</span><br><span class="line">&#125;</span><br><span class="line">tempNode.setNext(tempNode.getNext().getNext()); &#x2F;&#x2F; delete the required node</span><br><span class="line">setSize(getSize()-1);</span><br><span class="line">&#125;&#x2F;&#x2F;end of else</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><p>SingleNode.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public  class SingleNode &#123;</span><br><span class="line">private int value;</span><br><span class="line">private SingleNode next;</span><br><span class="line"></span><br><span class="line">public int getValue() &#123;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setValue(int value) &#123;</span><br><span class="line">this.value &#x3D; value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public SingleNode getNext() &#123;</span><br><span class="line">return next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(SingleNode next) &#123;</span><br><span class="line">this.next &#x3D; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return  value + &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The method which could be applied to Circular Single Linked List&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
</feed>
