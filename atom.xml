<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Developer Javit</title>
  
  <subtitle>Slowly and Steadily</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jbj828.github.io/"/>
  <updated>2020-04-07T08:21:16.354Z</updated>
  <id>http://jbj828.github.io/</id>
  
  <author>
    <name>Jay Chung</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Coding Test Level1 - Day1</title>
    <link href="http://jbj828.github.io/2020/04/07/Al-PS1/"/>
    <id>http://jbj828.github.io/2020/04/07/Al-PS1/</id>
    <published>2020-04-07T03:30:25.000Z</published>
    <updated>2020-04-07T08:21:16.354Z</updated>
    
    <content type="html"><![CDATA[<p>coding test level1</p><a id="more"></a><h4 id="2016년-a월-b일의-요일을-구하시오"><a href="#2016년-a월-b일의-요일을-구하시오" class="headerlink" title="2016년 a월 b일의 요일을 구하시오"></a>2016년 a월 b일의 요일을 구하시오</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getDayName(a, b)&#123;</span><br><span class="line">  let dayName &#x3D; new Date(2016, a-1, b).toString().slice(0,3).toUpperCase()</span><br><span class="line"></span><br><span class="line">  return dayName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="단어-s의-가운데-글자를-반환하는-함수-구하기-단어의-길이가-짝수라면-가운데-두글자를-반환"><a href="#단어-s의-가운데-글자를-반환하는-함수-구하기-단어의-길이가-짝수라면-가운데-두글자를-반환" class="headerlink" title="단어 s의 가운데 글자를 반환하는 함수 구하기. 단어의 길이가 짝수라면 가운데 두글자를 반환."></a>단어 s의 가운데 글자를 반환하는 함수 구하기. 단어의 길이가 짝수라면 가운데 두글자를 반환.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function solution(s)&#123;</span><br><span class="line">    const wordLength &#x3D; s.length;</span><br><span class="line">    const middlePoint &#x3D; Math.floor(wordLength &#x2F; 2 );</span><br><span class="line"></span><br><span class="line">    if(wordLength % 2 &#x3D;&#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return s[middlePoint-1].concat(s[middlePoint]);</span><br><span class="line">    &#125; else if(wordLength % 2 &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class="line">        return s[middlePoint];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="같은-숫자는-싫어"><a href="#같은-숫자는-싫어" class="headerlink" title="같은 숫자는 싫어"></a>같은 숫자는 싫어</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function solution(arr)&#123;</span><br><span class="line">  return arr.filter((val, index) &#x3D;&gt; val !&#x3D;&#x3D; arr[index +1])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="나누어-떨어지는-숫자-배열"><a href="#나누어-떨어지는-숫자-배열" class="headerlink" title="나누어 떨어지는 숫자 배열"></a>나누어 떨어지는 숫자 배열</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function solution(arr, divisor)&#123;</span><br><span class="line">  var answer &#x3D; [];</span><br><span class="line"></span><br><span class="line">  arr.map((o) &#x3D;&gt; &#123;</span><br><span class="line">    o % divisor &#x3D;&#x3D;&#x3D; 0 &amp;&amp; answer.push(o)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return answer.length ? answer.sort((a,b) &#x3D;&gt; a-b) : [-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="두-정수의-합"><a href="#두-정수의-합" class="headerlink" title="두 정수의 합"></a>두 정수의 합</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function adder(a, b)&#123;</span><br><span class="line">  let result &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  return (a+b)*(Math.abs(b-a)+1)&#x2F;2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="문자열-내-마음대로-정렬하기"><a href="#문자열-내-마음대로-정렬하기" class="headerlink" title="문자열 내 마음대로 정렬하기"></a>문자열 내 마음대로 정렬하기</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function solution(strings, n) &#123;</span><br><span class="line"></span><br><span class="line">    return strings.sort((s1, s2) &#x3D;&gt; s1[n] &#x3D;&#x3D;&#x3D; s2[n] ? s1.localeCompare(s2) : s1[n].localeCompare(s2[n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;coding test level1&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm, Coding Test" scheme="http://jbj828.github.io/categories/Algorithm-Coding-Test/"/>
    
    
      <category term="algorithm, Coding Test" scheme="http://jbj828.github.io/tags/algorithm-Coding-Test/"/>
    
  </entry>
  
  <entry>
    <title>Greedy Algorithm &amp; Divide and Conquer</title>
    <link href="http://jbj828.github.io/2020/04/06/Al-greedy-algorithm/"/>
    <id>http://jbj828.github.io/2020/04/06/Al-greedy-algorithm/</id>
    <published>2020-04-06T09:30:25.000Z</published>
    <updated>2020-04-06T13:43:15.886Z</updated>
    
    <content type="html"><![CDATA[<p>Greedy Algorithm &amp; Divide and Conquer</p><a id="more"></a><h2 id="Magic-Framework"><a href="#Magic-Framework" class="headerlink" title="Magic Framework"></a>Magic Framework</h2><img src="/2020/04/06/Al-greedy-algorithm/magicFramework.PNG" class="" width="500" height="400" title="magicFramework"><h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><ul><li>Greedy Algorithm is an algorithmic paradigm that builds up a solution piece by piece.</li><li>It always chooses the next piece that offers <code>the most obvious and immediate benefit</code>.</li><li>Greedy fits perfectly for those solutions in which choosing a locally optimal solution also leads to global optimal solution(aka ‘Greedy Choice’).</li></ul><h2 id="Divide-amp-Conquer"><a href="#Divide-amp-Conquer" class="headerlink" title="Divide &amp; Conquer"></a>Divide &amp; Conquer</h2><ul><li>Divide &amp; Conquer is an algorithm design paradigm which works by recursively breaking down a problem into sub-problems of similar type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem.</li></ul><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Greedy Algorithm &amp;amp; Divide and Conquer&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Adding Images to the User Profile &amp; Serving up Files</title>
    <link href="http://jbj828.github.io/2020/04/06/NodeJS-add-image/"/>
    <id>http://jbj828.github.io/2020/04/06/NodeJS-add-image/</id>
    <published>2020-04-06T03:46:25.000Z</published>
    <updated>2020-04-06T02:55:51.533Z</updated>
    
    <content type="html"><![CDATA[<p>Adding Images to the User Profile &amp; Serving up Files</p><a id="more"></a><h2 id="Adding-Images-to-the-User-Profile"><a href="#Adding-Images-to-the-User-Profile" class="headerlink" title="Adding Images to the User Profile"></a>Adding Images to the User Profile</h2><p>A new field needs to be added to the user model to store the avatar image data. The snippet below adds <code>avatar</code> on the user with the type of <code>Buffer</code>. The <code>Buffer</code> type should be used when storing binary data, which is exactly the type of data that multer provides.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const userSchema &#x3D; new mongoose.Schema(&#123;</span><br><span class="line">  avatar : &#123;</span><br><span class="line">    type : Buffer</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>The avatar upload route will be able to change the user profile data, so the route should be put behind authentication. The handler function grabs the binary data and stores it on the <code>avatar</code> field. Finally, the changes are saved.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.post(&#39;&#x2F;users&#x2F;me&#x2F;avatar&#39;, auth, uploda.single(&#39;upload&#39;), async (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  req.user.avatar &#x3D; req.file.buffer</span><br><span class="line">  await req.user.save()</span><br><span class="line">  res.send()</span><br><span class="line">&#125;, (error, req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">  res.status(400).send(&#123; error : error.message&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><h2 id="Serving-up-Files"><a href="#Serving-up-Files" class="headerlink" title="Serving up Files"></a>Serving up Files</h2><p>This is how we serve up user profile images. These images will be served as if they were static assets for the application.</p><p>Serving up the user avatars will require two pieces of data from the server. The first is the image data, and the second is the <code>Content-Type</code> header. The image data is stored on the user profile. The header should be set equal to <code>image/png</code> which lets the client know they’re getting a PNG image back.</p><p>The route below fetches the image data and sets the <code>Content-Type</code> header for the response. The URL could be visited to view the profile picture.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#39;&#x2F;users&#x2F;:id&#x2F;avatar&#39;, async (req, res) &#x3D;&gt;&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      const user &#x3D; await User.findById(req.params.id)</span><br><span class="line"></span><br><span class="line">      if(!user || !user.avatar)&#123;</span><br><span class="line">        throw new Error()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      res.set(&#39;Content-Type&#39;, &#39;image&#x2F;jpg&#39;)</span><br><span class="line">      res.send(user.avatar)</span><br><span class="line">  &#125; catch(e)&#123;</span><br><span class="line">      res.status(404).send()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>출처 : NodeJS course on Udemy by Andrew Mead</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Adding Images to the User Profile &amp;amp; Serving up Files&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Handling Express Errors</title>
    <link href="http://jbj828.github.io/2020/04/05/NodeJS-Express-Errors/"/>
    <id>http://jbj828.github.io/2020/04/05/NodeJS-Express-Errors/</id>
    <published>2020-04-05T13:46:25.000Z</published>
    <updated>2020-04-05T14:07:10.553Z</updated>
    
    <content type="html"><![CDATA[<p>Handling Express Errors</p><a id="more"></a><p>We’ll customize the errors that multer provides. This will give you complete control of what sort of response the client gets when their upload is rejected.</p><h3 id="Handling-Express-Errors"><a href="#Handling-Express-Errors" class="headerlink" title="Handling Express Errors"></a>Handling Express Errors</h3><p>You can handle errors from middleware function by providing a function to Express. As shown below, a new function is passed as the final argument to <code>router.post</code>. This function accepts <code>error, req, res, next</code>. This call signature lets Express know the function is designed to handle errors.</p><p>The function itself sends back a JSON response with the error message from multer.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.post(&#39;&#x2F;users&#x2F;me&#x2F;avatar&#39;, upload.single(&#39;avatar&#39;), (req,res) &#x3D;&gt; &#123;</span><br><span class="line">  res.send()</span><br><span class="line">&#125;, (error, req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">  res.status(400).send(&#123; error : error.message &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handling Express Errors&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>File Uploads with Multer</title>
    <link href="http://jbj828.github.io/2020/04/05/NodeJS-multer/"/>
    <id>http://jbj828.github.io/2020/04/05/NodeJS-multer/</id>
    <published>2020-04-05T11:46:25.000Z</published>
    <updated>2020-04-05T12:15:23.872Z</updated>
    
    <content type="html"><![CDATA[<p>multer</p><a id="more"></a><h3 id="Multer"><a href="#Multer" class="headerlink" title="Multer"></a>Multer</h3><p>Multer is a library in the Express ecosystem that allows your Express application to easily support file uploads. It couldn’t be easier.</p><p>After install the multer library, multer can then be configured to fit your specific needs. The example below shows off a basic configuration where <code>dest</code> ids set to <code>avatars</code>. This will store all uploaded files in a directory called <code>avatars</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const multer &#x3D; require(&#39;multer&#39;)</span><br><span class="line"></span><br><span class="line">const upload &#x3D; multer(&#123;</span><br><span class="line">  dest : &#39;avatars&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Multer is then added as middleware for the specific endpoint that should allow for file uploads. The route below is expecting a single <code>avatar</code> field on the submitted form.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.post(&#39;&#x2F;users&#x2F;me&#x2F;avatar&#39;, upload.single(&#39;avatar&#39;), (req,res)&#x3D;&gt;&#123;</span><br><span class="line">  res.send()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;multer&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/categories/NodeJS/"/>
    
    
      <category term="NodeJS" scheme="http://jbj828.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="http://jbj828.github.io/2020/04/04/Al-dynamic-programming/"/>
    <id>http://jbj828.github.io/2020/04/04/Al-dynamic-programming/</id>
    <published>2020-04-04T03:30:25.000Z</published>
    <updated>2020-04-04T03:32:28.772Z</updated>
    
    <content type="html"><![CDATA[<p>dynamic programming</p><a id="more"></a><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>A method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.</p><p>It only works on problems with <strong>Optimal Substructure</strong> &amp; <strong>Overlapping Subproblems</strong></p><h3 id="Overlapping-Subproblems"><a href="#Overlapping-Subproblems" class="headerlink" title="Overlapping Subproblems"></a>Overlapping Subproblems</h3><p>A problme is said to have <code>overlapping subproblems</code> if it can be broken down into subproblems which are reused several times.</p><p>Ex) Finbonnaci Numbers</p><h3 id="Optimal-Substructure"><a href="#Optimal-Substructure" class="headerlink" title="Optimal Substructure"></a>Optimal Substructure</h3><p>A problem is said to have <code>optimal substructure</code> if an optimal solution can be constructed from optimal solutions of its subproblems.</p><h3 id="Meomoization"><a href="#Meomoization" class="headerlink" title="Meomoization"></a>Meomoization</h3><p>Storing the results of expensive function calls and returning the cached result when the same inputs occur again.</p><h4 id="The-Fibonacci-with-Recursive"><a href="#The-Fibonacci-with-Recursive" class="headerlink" title="The Fibonacci with Recursive"></a>The Fibonacci with Recursive</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fib(num)&#123;</span><br><span class="line">   if(num &lt;&#x3D; 2) return 1;</span><br><span class="line">   return fib(num -1) + fib(num -2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity - O(2^n)</p><h4 id="Meomoization-The-Fibonacci-with-Memoized-solution-Top-Down"><a href="#Meomoization-The-Fibonacci-with-Memoized-solution-Top-Down" class="headerlink" title="Meomoization : The Fibonacci with Memoized solution(Top-Down)"></a>Meomoization : The Fibonacci with Memoized solution(Top-Down)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fib(n, memo&#x3D;[])&#123;</span><br><span class="line">  if(memo[n] !&#x3D;&#x3D; undefined) return memo[n];</span><br><span class="line">  if(n &lt;&#x3D; 2) return 1;</span><br><span class="line">  var res &#x3D; fib(n-1, memo) + fib(n-2, memo);</span><br><span class="line">  memo[n] &#x3D; res;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity - O(n)</p><h3 id="Tabulation"><a href="#Tabulation" class="headerlink" title="Tabulation"></a>Tabulation</h3><p>Storing the result of a previous result in a “table”(usually an array).<br>Usually done using iteration.<br>Better space complexity can be achieved using tabulation.</p><h3 id="Tabulation-The-Fibonacci-with-tabulated-solution-Bottom-up-Approach"><a href="#Tabulation-The-Fibonacci-with-tabulated-solution-Bottom-up-Approach" class="headerlink" title="Tabulation : The Fibonacci with tabulated solution(Bottom-up Approach)"></a>Tabulation : The Fibonacci with tabulated solution(Bottom-up Approach)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fib(n)&#123;</span><br><span class="line">  if(n &lt;&#x3D; 2) return 1;</span><br><span class="line">  var fibNums &#x3D; [0, 1, 1];</span><br><span class="line">  for(var i &#x3D; 3; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">    fibNums[i] &#x3D; fibNums[i-1] + fibNums[i-2];</span><br><span class="line">  &#125;</span><br><span class="line">  return fibNums[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity - O(n)<br>Space Complexity is better than Memoized Version.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dynamic programming&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra&#39;s Algorithm with Binary Heap(Complete Priority Queue)</title>
    <link href="http://jbj828.github.io/2020/04/03/Al-dijkstra-algo-with-binary-heap/"/>
    <id>http://jbj828.github.io/2020/04/03/Al-dijkstra-algo-with-binary-heap/</id>
    <published>2020-04-03T09:30:25.000Z</published>
    <updated>2020-04-03T09:01:18.827Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra’s Algorithm with Binary Heap</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">class WeightedGraph &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.adjacencyList &#x3D; &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    addVertex(vertex)&#123;</span><br><span class="line">        if(!this.adjacencyList[vertex]) this.adjacencyList[vertex] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line">    addEdge(vertex1,vertex2, weight)&#123;</span><br><span class="line">        this.adjacencyList[vertex1].push(&#123;node:vertex2,weight&#125;);</span><br><span class="line">        this.adjacencyList[vertex2].push(&#123;node:vertex1, weight&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(start, finish)&#123;</span><br><span class="line">        const nodes &#x3D; new PriorityQueue();</span><br><span class="line">        const distances &#x3D; &#123;&#125;;</span><br><span class="line">        const previous &#x3D; &#123;&#125;;</span><br><span class="line">        let path &#x3D; [] &#x2F;&#x2F;to return at end</span><br><span class="line">        let smallest;</span><br><span class="line">        &#x2F;&#x2F;build up initial state</span><br><span class="line">        for(let vertex in this.adjacencyList)&#123;</span><br><span class="line">            if(vertex &#x3D;&#x3D;&#x3D; start)&#123;</span><br><span class="line">                distances[vertex] &#x3D; 0;</span><br><span class="line">                nodes.enqueue(vertex, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                distances[vertex] &#x3D; Infinity;</span><br><span class="line">                nodes.enqueue(vertex, Infinity);</span><br><span class="line">            &#125;</span><br><span class="line">            previous[vertex] &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; as long as there is something to visit</span><br><span class="line">        while(nodes.values.length)&#123;</span><br><span class="line">            smallest &#x3D; nodes.dequeue().val;</span><br><span class="line">            if(smallest &#x3D;&#x3D;&#x3D; finish)&#123;</span><br><span class="line">                &#x2F;&#x2F;WE ARE DONE</span><br><span class="line">                &#x2F;&#x2F;BUILD UP PATH TO RETURN AT END</span><br><span class="line">                while(previous[smallest])&#123;</span><br><span class="line">                    path.push(smallest);</span><br><span class="line">                    smallest &#x3D; previous[smallest];</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125; </span><br><span class="line">            if(smallest || distances[smallest] !&#x3D;&#x3D; Infinity)&#123;</span><br><span class="line">                for(let neighbor in this.adjacencyList[smallest])&#123;</span><br><span class="line">                    &#x2F;&#x2F;find neighboring node</span><br><span class="line">                    let nextNode &#x3D; this.adjacencyList[smallest][neighbor];</span><br><span class="line">                    &#x2F;&#x2F;calculate new distance to neighboring node</span><br><span class="line">                    let candidate &#x3D; distances[smallest] + nextNode.weight;</span><br><span class="line">                    let nextNeighbor &#x3D; nextNode.node;</span><br><span class="line">                    if(candidate &lt; distances[nextNeighbor])&#123;</span><br><span class="line">                        &#x2F;&#x2F;updating new smallest distance to neighbor</span><br><span class="line">                        distances[nextNeighbor] &#x3D; candidate;</span><br><span class="line">                        &#x2F;&#x2F;updating previous - How we got to neighbor</span><br><span class="line">                        previous[nextNeighbor] &#x3D; smallest;</span><br><span class="line">                        &#x2F;&#x2F;enqueue in priority queue with new priority</span><br><span class="line">                        nodes.enqueue(nextNeighbor, candidate);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return path.concat(smallest).reverse();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PriorityQueue &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.values &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line">    enqueue(val, priority)&#123;</span><br><span class="line">        let newNode &#x3D; new Node(val, priority);</span><br><span class="line">        this.values.push(newNode);</span><br><span class="line">        this.bubbleUp();</span><br><span class="line">    &#125;</span><br><span class="line">    bubbleUp()&#123;</span><br><span class="line">        let idx &#x3D; this.values.length - 1;</span><br><span class="line">        const element &#x3D; this.values[idx];</span><br><span class="line">        while(idx &gt; 0)&#123;</span><br><span class="line">            let parentIdx &#x3D; Math.floor((idx - 1)&#x2F;2);</span><br><span class="line">            let parent &#x3D; this.values[parentIdx];</span><br><span class="line">            if(element.priority &gt;&#x3D; parent.priority) break;</span><br><span class="line">            this.values[parentIdx] &#x3D; element;</span><br><span class="line">            this.values[idx] &#x3D; parent;</span><br><span class="line">            idx &#x3D; parentIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dequeue()&#123;</span><br><span class="line">        const min &#x3D; this.values[0];</span><br><span class="line">        const end &#x3D; this.values.pop();</span><br><span class="line">        if(this.values.length &gt; 0)&#123;</span><br><span class="line">            this.values[0] &#x3D; end;</span><br><span class="line">            this.sinkDown();</span><br><span class="line">        &#125;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">    sinkDown()&#123;</span><br><span class="line">        let idx &#x3D; 0;</span><br><span class="line">        const length &#x3D; this.values.length;</span><br><span class="line">        const element &#x3D; this.values[0];</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            let leftChildIdx &#x3D; 2 * idx + 1;</span><br><span class="line">            let rightChildIdx &#x3D; 2 * idx + 2;</span><br><span class="line">            let leftChild,rightChild;</span><br><span class="line">            let swap &#x3D; null;</span><br><span class="line"></span><br><span class="line">            if(leftChildIdx &lt; length)&#123;</span><br><span class="line">                leftChild &#x3D; this.values[leftChildIdx];</span><br><span class="line">                if(leftChild.priority &lt; element.priority) &#123;</span><br><span class="line">                    swap &#x3D; leftChildIdx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(rightChildIdx &lt; length)&#123;</span><br><span class="line">                rightChild &#x3D; this.values[rightChildIdx];</span><br><span class="line">                if(</span><br><span class="line">                    (swap &#x3D;&#x3D;&#x3D; null &amp;&amp; rightChild.priority &lt; element.priority) || </span><br><span class="line">                    (swap !&#x3D;&#x3D; null &amp;&amp; rightChild.priority &lt; leftChild.priority)</span><br><span class="line">                ) &#123;</span><br><span class="line">                   swap &#x3D; rightChildIdx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(swap &#x3D;&#x3D;&#x3D; null) break;</span><br><span class="line">            this.values[idx] &#x3D; this.values[swap];</span><br><span class="line">            this.values[swap] &#x3D; element;</span><br><span class="line">            idx &#x3D; swap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">    constructor(val, priority)&#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">        this.priority &#x3D; priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var graph &#x3D; new WeightedGraph()</span><br><span class="line">graph.addVertex(&quot;A&quot;);</span><br><span class="line">graph.addVertex(&quot;B&quot;);</span><br><span class="line">graph.addVertex(&quot;C&quot;);</span><br><span class="line">graph.addVertex(&quot;D&quot;);</span><br><span class="line">graph.addVertex(&quot;E&quot;);</span><br><span class="line">graph.addVertex(&quot;F&quot;);</span><br><span class="line"></span><br><span class="line">graph.addEdge(&quot;A&quot;,&quot;B&quot;, 4);</span><br><span class="line">graph.addEdge(&quot;A&quot;,&quot;C&quot;, 2);</span><br><span class="line">graph.addEdge(&quot;B&quot;,&quot;E&quot;, 3);</span><br><span class="line">graph.addEdge(&quot;C&quot;,&quot;D&quot;, 2);</span><br><span class="line">graph.addEdge(&quot;C&quot;,&quot;F&quot;, 4);</span><br><span class="line">graph.addEdge(&quot;D&quot;,&quot;E&quot;, 3);</span><br><span class="line">graph.addEdge(&quot;D&quot;,&quot;F&quot;, 1);</span><br><span class="line">graph.addEdge(&quot;E&quot;,&quot;F&quot;, 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">graph.Dijkstra(&quot;A&quot;, &quot;E&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dijkstra’s Algorithm with Binary Heap&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra&#39;s Algorithm</title>
    <link href="http://jbj828.github.io/2020/04/03/Al-Dijkstra-algorithm/"/>
    <id>http://jbj828.github.io/2020/04/03/Al-Dijkstra-algorithm/</id>
    <published>2020-04-03T04:30:25.000Z</published>
    <updated>2020-04-03T08:57:06.403Z</updated>
    
    <content type="html"><![CDATA[<p>Dijkstra’s Algorithm</p><a id="more"></a><h3 id="What-is-it"><a href="#What-is-it" class="headerlink" title="What is it?"></a>What is it?</h3><ul><li>One of the most famous and widely used algorithms around.</li><li>Finds the shortest path between two vertices on a graph</li><li>“What’s the fastest way to get from point A to point B?”</li></ul><h3 id="Why-is-it-useful"><a href="#Why-is-it-useful" class="headerlink" title="Why is it useful?"></a>Why is it useful?</h3><ul><li>GPS - finding fastest route</li><li>Networking Routing - finds open shortest path for data</li><li>Biology - used to model the spread of viruses among humans</li><li>Airline tickets - finding cheapest route to your destination</li><li>Many other uses!</li></ul><h3 id="Dijkstra-algorithm-with-Priority-Queue-Naive-version"><a href="#Dijkstra-algorithm-with-Priority-Queue-Naive-version" class="headerlink" title="Dijkstra algorithm with Priority Queue(Naive version)"></a>Dijkstra algorithm with Priority Queue(Naive version)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">class PriorityQueue &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.values &#x3D; [];</span><br><span class="line">  &#125;</span><br><span class="line">  enqueue(val, priority) &#123;</span><br><span class="line">    this.values.push(&#123;val, priority&#125;);</span><br><span class="line">    this.sort();</span><br><span class="line">  &#125;;</span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    return this.values.shift();</span><br><span class="line">  &#125;;</span><br><span class="line">  sort() &#123;</span><br><span class="line">    this.values.sort((a, b) &#x3D;&gt; a.priority - b.priority);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WeightedGraph &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.adjacencyList &#x3D; &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    addVertex(vertex)&#123;</span><br><span class="line">        if(!this.adjacencyList[vertex]) this.adjacencyList[vertex] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line">    addEdge(vertex1,vertex2, weight)&#123;</span><br><span class="line">        this.adjacencyList[vertex1].push(&#123;node:vertex2,weight&#125;);</span><br><span class="line">        this.adjacencyList[vertex2].push(&#123;node:vertex1, weight&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(start, finish)&#123;</span><br><span class="line">        const nodes &#x3D; new PriorityQueue();</span><br><span class="line">        const distances &#x3D; &#123;&#125;;</span><br><span class="line">        const previous &#x3D; &#123;&#125;;</span><br><span class="line">        let path &#x3D; [] &#x2F;&#x2F;to return at end</span><br><span class="line">        let smallest;</span><br><span class="line">        &#x2F;&#x2F;build up initial state</span><br><span class="line">        for(let vertex in this.adjacencyList)&#123;</span><br><span class="line">            if(vertex &#x3D;&#x3D;&#x3D; start)&#123;</span><br><span class="line">                distances[vertex] &#x3D; 0;</span><br><span class="line">                nodes.enqueue(vertex, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                distances[vertex] &#x3D; Infinity;</span><br><span class="line">                nodes.enqueue(vertex, Infinity);</span><br><span class="line">            &#125;</span><br><span class="line">            previous[vertex] &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; as long as there is something to visit</span><br><span class="line">        while(nodes.values.length)&#123;</span><br><span class="line">            smallest &#x3D; nodes.dequeue().val;</span><br><span class="line">            if(smallest &#x3D;&#x3D;&#x3D; finish)&#123;</span><br><span class="line">                &#x2F;&#x2F;WE ARE DONE</span><br><span class="line">                &#x2F;&#x2F;BUILD UP PATH TO RETURN AT END</span><br><span class="line">                while(previous[smallest])&#123;</span><br><span class="line">                    path.push(smallest);</span><br><span class="line">                    smallest &#x3D; previous[smallest];</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125; </span><br><span class="line">            if(smallest || distances[smallest] !&#x3D;&#x3D; Infinity)&#123;</span><br><span class="line">                for(let neighbor in this.adjacencyList[smallest])&#123;</span><br><span class="line">                    &#x2F;&#x2F;find neighboring node</span><br><span class="line">                    let nextNode &#x3D; this.adjacencyList[smallest][neighbor];</span><br><span class="line">                    &#x2F;&#x2F;calculate new distance to neighboring node</span><br><span class="line">                    let candidate &#x3D; distances[smallest] + nextNode.weight;</span><br><span class="line">                    let nextNeighbor &#x3D; nextNode.node;</span><br><span class="line">                    if(candidate &lt; distances[nextNeighbor])&#123;</span><br><span class="line">                        &#x2F;&#x2F;updating new smallest distance to neighbor</span><br><span class="line">                        distances[nextNeighbor] &#x3D; candidate;</span><br><span class="line">                        &#x2F;&#x2F;updating previous - How we got to neighbor</span><br><span class="line">                        previous[nextNeighbor] &#x3D; smallest;</span><br><span class="line">                        &#x2F;&#x2F;enqueue in priority queue with new priority</span><br><span class="line">                        nodes.enqueue(nextNeighbor, candidate);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return path.concat(smallest).reverse();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var graph &#x3D; new WeightedGraph()</span><br><span class="line">graph.addVertex(&quot;A&quot;);</span><br><span class="line">graph.addVertex(&quot;B&quot;);</span><br><span class="line">graph.addVertex(&quot;C&quot;);</span><br><span class="line">graph.addVertex(&quot;D&quot;);</span><br><span class="line">graph.addVertex(&quot;E&quot;);</span><br><span class="line">graph.addVertex(&quot;F&quot;);</span><br><span class="line"></span><br><span class="line">graph.addEdge(&quot;A&quot;,&quot;B&quot;, 4);</span><br><span class="line">graph.addEdge(&quot;A&quot;,&quot;C&quot;, 2);</span><br><span class="line">graph.addEdge(&quot;B&quot;,&quot;E&quot;, 3);</span><br><span class="line">graph.addEdge(&quot;C&quot;,&quot;D&quot;, 2);</span><br><span class="line">graph.addEdge(&quot;C&quot;,&quot;F&quot;, 4);</span><br><span class="line">graph.addEdge(&quot;D&quot;,&quot;E&quot;, 3);</span><br><span class="line">graph.addEdge(&quot;D&quot;,&quot;F&quot;, 1);</span><br><span class="line">graph.addEdge(&quot;E&quot;,&quot;F&quot;, 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">graph.Dijkstra(&quot;A&quot;, &quot;E&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [&quot;A&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;E&quot;]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dijkstra’s Algorithm&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Graph Traversal(BFS, DFS)</title>
    <link href="http://jbj828.github.io/2020/04/02/Al-graph-Graph-Traversal/"/>
    <id>http://jbj828.github.io/2020/04/02/Al-graph-Graph-Traversal/</id>
    <published>2020-04-02T07:30:25.000Z</published>
    <updated>2020-04-03T03:16:59.538Z</updated>
    
    <content type="html"><![CDATA[<p>graph traversal</p><a id="more"></a><h3 id="What-is-Graph-Traversal"><a href="#What-is-Graph-Traversal" class="headerlink" title="What is Graph Traversal?"></a>What is Graph Traversal?</h3><p>Graph traversal refers to the process of visiting each vertex in a graph.</p><h3 id="Types-of-Graph-Traversal"><a href="#Types-of-Graph-Traversal" class="headerlink" title="Types of Graph Traversal"></a>Types of Graph Traversal</h3><ul><li>Breadth First Search(BFS)</li><li>Depth First Search(DFS)</li></ul><h1 id="Breadth-First-Search-BFS"><a href="#Breadth-First-Search-BFS" class="headerlink" title="Breadth First Search(BFS)"></a>Breadth First Search(BFS)</h1><p>BFS is an algorithm for traversing Graph data structures. It starts at some arbitrary node of a graph and explores the neighbor nodes(which are at current level) first, before moving to the next level neighbors.</p><h3 id="Handling-one-Special-Scenario-of-BFS"><a href="#Handling-one-Special-Scenario-of-BFS" class="headerlink" title="Handling one Special Scenario of BFS"></a>Handling one Special Scenario of BFS</h3><ul><li>Disconnected Graph<ul><li>Cannot traverse the graph with BFS. Because the vertecis are disconneted with each other.</li></ul></li></ul><h3 id="Time-Complexity-BFS"><a href="#Time-Complexity-BFS" class="headerlink" title="Time Complexity - BFS"></a>Time Complexity - BFS</h3><ul><li>Time Complexity - O(V+E)</li><li>Space Complexity - O(V+E)</li></ul><br><h1 id="Depth-First-Search-DFS"><a href="#Depth-First-Search-DFS" class="headerlink" title="Depth First Search(DFS)"></a>Depth First Search(DFS)</h1><p>DFS is an algorithm for traversing Graph data structures. It starts selecting some arbitrary node and explores as far as possible along each edge before backtracking.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">class Graph &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.adjacencyList &#x3D; &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    addVertex(vertex)&#123;</span><br><span class="line">        if(!this.adjacencyList[vertex]) this.adjacencyList[vertex] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEdge(vertex1, vertex2)&#123;</span><br><span class="line">        if(this.adjacencyList[vertex1])&#123;</span><br><span class="line">            this.adjacencyList[vertex1].push(vertex2);</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.adjacencyList[vertex2])&#123;</span><br><span class="line">            this.adjacencyList[vertex2].push(vertex1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    removeEdge(v1, v2)&#123;</span><br><span class="line">        if(this.adjacencyList[v1].includes(v2))&#123;</span><br><span class="line">            this.adjacencyList[v1] &#x3D; this.adjacencyList[v1].filter( v &#x3D;&gt; v !&#x3D;&#x3D; v2);</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.adjacencyList[v2].includes(v1))&#123;</span><br><span class="line">            this.adjacencyList[v2] &#x3D; this.adjacencyList[v2].filter( v &#x3D;&gt; v !&#x3D;&#x3D; v1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    removeVertex(vertex)&#123;</span><br><span class="line">        while(this.adjacencyList[vertex].length)&#123;</span><br><span class="line">            const adjacentVertex &#x3D; this.adjacencyList[vertex].pop();</span><br><span class="line">            this.removeEdge(vertex, adjacentVertex);</span><br><span class="line">        &#125;</span><br><span class="line">        delete this.adjacencyList[vertex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    depthFirstRecursive(start)&#123;</span><br><span class="line">        const result &#x3D; [];</span><br><span class="line">        const visited &#x3D; &#123;&#125;;</span><br><span class="line">        const adjacencyList &#x3D; this.adjacencyList;</span><br><span class="line"></span><br><span class="line">        (function dfs(vertex)&#123;</span><br><span class="line">            if(!vertex) return null;</span><br><span class="line">            visited[vertex] &#x3D; true;</span><br><span class="line">            result.push(vertex);</span><br><span class="line">            adjacencyList[vertex].forEach(neighbor &#x3D;&gt; &#123;</span><br><span class="line">                if(!visited[neighbor])&#123;</span><br><span class="line">                    return dfs(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)(start);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depthFirstIterative(start)&#123;</span><br><span class="line">        const stack &#x3D; [start];</span><br><span class="line">        const result &#x3D; [];</span><br><span class="line">        const visited &#x3D; &#123;&#125;;</span><br><span class="line">        let currentVertex;</span><br><span class="line"></span><br><span class="line">        visited[start] &#x3D; true;</span><br><span class="line">        while(stack.length)&#123;</span><br><span class="line">            currentVertex &#x3D; stack.pop();</span><br><span class="line">            result.push(currentVertex);</span><br><span class="line"></span><br><span class="line">            this.adjacencyList[currentVertex].forEach(neighbor &#x3D;&gt; &#123;</span><br><span class="line">                if(!visited[neighbor])&#123;</span><br><span class="line">                    visited[neighbor] &#x3D; true;</span><br><span class="line">                    stack.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    breadthFirstIterative(start)&#123;</span><br><span class="line">       const queue &#x3D; [start];</span><br><span class="line">       const result &#x3D; [];</span><br><span class="line">       const visited &#x3D; &#123;&#125;;</span><br><span class="line">       let currentVertex</span><br><span class="line">       </span><br><span class="line">       visited[start] &#x3D; true;</span><br><span class="line">       </span><br><span class="line">       while(queue.length)&#123;</span><br><span class="line">            currentVertex &#x3D; queue.shift();</span><br><span class="line">            result.push(currentVertex);</span><br><span class="line">            </span><br><span class="line">            this.adjacencyList[currentVertex].forEach(neighbor&#x3D;&gt;&#123;</span><br><span class="line">                if(!visited[neighbor])&#123;</span><br><span class="line">                    visited[neighbor] &#x3D; true;</span><br><span class="line">                    queue.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let g &#x3D; new Graph();</span><br><span class="line"></span><br><span class="line">g.addVertex(&quot;A&quot;)</span><br><span class="line">g.addVertex(&quot;B&quot;)</span><br><span class="line">g.addVertex(&quot;C&quot;)</span><br><span class="line">g.addVertex(&quot;D&quot;)</span><br><span class="line">g.addVertex(&quot;E&quot;)</span><br><span class="line">g.addVertex(&quot;F&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g.addEdge(&quot;A&quot;, &quot;B&quot;)</span><br><span class="line">g.addEdge(&quot;A&quot;, &quot;C&quot;)</span><br><span class="line">g.addEdge(&quot;B&quot;,&quot;D&quot;)</span><br><span class="line">g.addEdge(&quot;C&quot;,&quot;E&quot;)</span><br><span class="line">g.addEdge(&quot;D&quot;,&quot;E&quot;)</span><br><span class="line">g.addEdge(&quot;D&quot;,&quot;F&quot;)</span><br><span class="line">g.addEdge(&quot;E&quot;,&quot;F&quot;)</span><br><span class="line">g.depthFirstRecursive(&quot;A&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;          A</span><br><span class="line">&#x2F;&#x2F;        &#x2F;   \</span><br><span class="line">&#x2F;&#x2F;       B     C</span><br><span class="line">&#x2F;&#x2F;       |     |</span><br><span class="line">&#x2F;&#x2F;       D --- E</span><br><span class="line">&#x2F;&#x2F;        \   &#x2F;</span><br><span class="line">&#x2F;&#x2F;          F</span><br></pre></td></tr></table></figure><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;graph traversal&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Graph</title>
    <link href="http://jbj828.github.io/2020/04/01/Al-graph/"/>
    <id>http://jbj828.github.io/2020/04/01/Al-graph/</id>
    <published>2020-04-01T06:30:25.000Z</published>
    <updated>2020-04-06T09:47:25.059Z</updated>
    
    <content type="html"><![CDATA[<p>graph</p><a id="more"></a><h3 id="What-is-Graph"><a href="#What-is-Graph" class="headerlink" title="What is Graph?"></a>What is Graph?</h3><ul><li>Graph is a pair of sets(V,E), where V is the set of vertices and E is the set of edges, connecting the pairs of vertices.</li></ul><h3 id="Some-Terminologies"><a href="#Some-Terminologies" class="headerlink" title="Some Terminologies"></a>Some Terminologies</h3><ul><li>Vertex : Vertex is the node of the graph</li><li>Edges : Edges are the arcs that connect pairs of vertices</li><li>Unweighted Graph : A graph not having a weight associated with any edge</li><li>Weighted Graph : A graph having a weight associated with each edge</li><li>Undirected Graph : It is a graph that is a set of vertices connected by edges, where the edges don’t have a direction associated with them.</li><li>Directed Graph : It is a graph that is a set of vertices connected by edges, where the edges have a direction associated with them.</li><li>Cyclic Graph : A cyclic graph is a graph having at least on loop.</li><li>Acyclic Graph : An Acyclic graph is a graph having no loop.</li><li>Tree : Tree is a special case of Directed Acyclic Graph(DAG).</li></ul><h3 id="Types-of-Graph"><a href="#Types-of-Graph" class="headerlink" title="Types of Graph"></a>Types of Graph</h3><Br><img src="/2020/04/01/Al-graph/graph.PNG" class="" width="500" height="500" title="Types of Graph"><h3 id="How-is-Graph-represented"><a href="#How-is-Graph-represented" class="headerlink" title="How is Graph represented?"></a>How is Graph represented?</h3><ol><li><p><strong>Adjacency Matrix</strong> : In graph theory, an adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.</p><img src="/2020/04/01/Al-graph/adjacencyMatrix.PNG" class="" width="400" height="400" title="adjacency matrix"></li><li><p><strong>Adjacency List</strong> : In graph theory, an adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a vertex in the graph.</p></li></ol><img src="/2020/04/01/Al-graph/adjacencyList.PNG" class="" width="400" height="400" title="adjacency list"><h5 id="When-to-use-which-representation"><a href="#When-to-use-which-representation" class="headerlink" title="When to use which representation?"></a>When to use which representation?</h5><ul><li>If the graph is a ‘Complete’ or ‘near to complete’ Graph, then we should use <strong>Adjacency Matrix</strong>.</li><li>If the number of ‘Edges’ are few, then we should use <strong>Adjacency List</strong>.</li></ul><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;graph&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Sorting - Quick Sort</title>
    <link href="http://jbj828.github.io/2020/03/31/Al-sort-quick-sort/"/>
    <id>http://jbj828.github.io/2020/03/31/Al-sort-quick-sort/</id>
    <published>2020-03-31T13:30:25.000Z</published>
    <updated>2020-04-01T03:43:28.654Z</updated>
    
    <content type="html"><![CDATA[<p>quick sort</p><a id="more"></a><h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><ul><li>Quick Sort is Divide and Conquer algorithm.</li><li>At each step it finds ‘Pivot’ and then makes sure that all the smaller elements are on the left of ‘Pivot’ and all the bigger elements are on the right side of ‘Pivot’.</li><li>It does this recursively until the entire array is sorted.</li><li>Unlike Merge Sort, it does not requires any external space.</li><li>피봇값을 기준으로 피봇 앞에는 피봇보다 작은 값, 뒤에는 큰 값이 오도록 하여 리스트를 분할하고, 분할된 두 개 리스트 각각에 재귀적으로 이 과정을 반복해 정렬을 완성. 합병정렬과 달리 주어진 배열을 임의로 나누지 않기 때문에 대개는 효율적이지만, 피봇값이 잘못 선택되면 O(n2)이 될 수도 있음.</li></ul><h3 id="Time-amp-Space-Complexity"><a href="#Time-amp-Space-Complexity" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h3><ul><li>Time Complexity - O(n log n)</li><li>Space Complexity - O(n) : system이 모든 요소를 stack에 넣고 pop 할 경우</li></ul><h3 id="When-to-Use-Avoid-Quick-Sort"><a href="#When-to-Use-Avoid-Quick-Sort" class="headerlink" title="When to Use/Avoid Quick Sort"></a>When to Use/Avoid Quick Sort</h3><ul><li><p>When to use:</p><ul><li>When average expected time is O(n log n)</li></ul></li><li><p>When not to use:</p><ul><li>When space is a concern like embedded systems</li><li>When stable sort is required</li></ul></li></ul><h3 id="Coding-Quick-Sort-on-Javascript"><a href="#Coding-Quick-Sort-on-Javascript" class="headerlink" title="Coding Quick Sort on Javascript"></a>Coding Quick Sort on Javascript</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function pivot(arr, start&#x3D;0, end&#x3D;arr.length-1)&#123;</span><br><span class="line">  function swap(array, i, j) &#123;</span><br><span class="line">    var temp &#x3D; array[i];</span><br><span class="line">    array[i] &#x3D; array[j];</span><br><span class="line">    array[j] &#x3D; temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var pivot &#x3D; arr[start];</span><br><span class="line">  var swapIdx &#x3D; start;</span><br><span class="line"></span><br><span class="line">  for(var i &#x3D; start + 1; i &lt; arr.length; i++)&#123;</span><br><span class="line">    if(pivot &gt; arr[i])&#123;</span><br><span class="line">      swapIdx++;</span><br><span class="line">      swap(arr,swapIdx,i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr,start,swapIdx);</span><br><span class="line">  return swapIdx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function quickSort(arr, left&#x3D;0, right&#x3D;arr.length-1)&#123;</span><br><span class="line">  if(left &lt; right)&#123;</span><br><span class="line">    let pivotIndex &#x3D; pivot(arr, left, right);</span><br><span class="line">    &#x2F;&#x2F;left</span><br><span class="line">    quickSort(arr, left, pivotIndex-1);</span><br><span class="line">    &#x2F;&#x2F;right</span><br><span class="line">    quickSort(arr, pivotIndex+1, right);</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;quick sort&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Sorting - Merge Sort</title>
    <link href="http://jbj828.github.io/2020/03/31/Al-sort-merge-sort/"/>
    <id>http://jbj828.github.io/2020/03/31/Al-sort-merge-sort/</id>
    <published>2020-03-31T05:30:25.000Z</published>
    <updated>2020-03-31T13:08:09.066Z</updated>
    
    <content type="html"><![CDATA[<p>merge sort</p><a id="more"></a><h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><ul><li>Merge Sort is a Divide and Conquer algorithm.</li><li>It divides input array in two halves, keeps breaking those 2 halves recursively until they become too small to be broken further.</li><li>Then each of the broken pieces are merged together to inch towards final answer.</li><li>리스트를 잘게 쪼갠 뒤 둘씩 크기를 비교해 정렬하고 분리된 리스트를 재귀적으로 합쳐서 정렬을 완성, 분할된 리스트를 저장해둘 공간이 필요해 메모리 소모량이 큰 편</li></ul><h3 id="Time-amp-Space-Complexity"><a href="#Time-amp-Space-Complexity" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h3><ul><li>Time Complexity - O(n log n)</li><li>Space Complexity - O(n)</li></ul><h3 id="When-to-Use-Avoid-Merge-Sort"><a href="#When-to-Use-Avoid-Merge-Sort" class="headerlink" title="When to Use/Avoid Merge Sort"></a>When to Use/Avoid Merge Sort</h3><ul><li><p>When to use:</p><ul><li>When you need a <code>stable sort</code></li><li>When average expected time is O(n log n)</li></ul></li><li><p>When not to use:</p><ul><li>When space is a concern like embedded systems</li></ul></li></ul><h3 id="Coding-Merge-Sort-on-Javascript"><a href="#Coding-Merge-Sort-on-Javascript" class="headerlink" title="Coding Merge Sort on Javascript"></a>Coding Merge Sort on Javascript</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function merge(arr1, arr2)&#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    let i &#x3D; 0;</span><br><span class="line">    let j &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    while( i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;</span><br><span class="line">        if(arr1[i] &lt; arr2[j])&#123;</span><br><span class="line">            result.push(arr1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(arr2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while( i &lt; arr1.length)&#123;</span><br><span class="line">        result.push(arr1[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    while( j &lt; arr2.length)&#123;</span><br><span class="line">        result.push(arr2[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function mergeSort(arr)&#123;</span><br><span class="line">    if(arr.length &lt;&#x3D; 1) return arr;</span><br><span class="line">    let mid &#x3D; Math.floor(arr.length &#x2F;2);</span><br><span class="line">    let left &#x3D; mergeSort(arr.slice(0, mid));</span><br><span class="line">    let right &#x3D; mergeSort(arr.slice(mid));</span><br><span class="line">    return merge(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;merge sort&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Sorting - Insertion Sort / Bucket Sort</title>
    <link href="http://jbj828.github.io/2020/03/31/Al-hashing-Insertion-sort/"/>
    <id>http://jbj828.github.io/2020/03/31/Al-hashing-Insertion-sort/</id>
    <published>2020-03-30T15:30:25.000Z</published>
    <updated>2020-03-31T03:49:41.268Z</updated>
    
    <content type="html"><![CDATA[<p>insertion sort / bucket sort</p><a id="more"></a><h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><ul><li><p>In Insertion sort algorithm we divide the given array into 2 parts. Sorted &amp; Unsorted.</p></li><li><p>Then from Unsorted, we pick the first element and find its correct position in sorted array.</p></li><li><p>Repeat till Unsorted array is empty.</p></li><li><p>모든 요소에 대해 앞에서부터 차례대로 이미 정렬된 배열(sorted list)과 비교하여 sorted list내 자신의 위치를 찾아 삽입함으로써 정렬을 완성, 입력데이터가 이미 정렬된 상태라면 O(n)의 빠른 속도를 보이지만 그렇지 않은 경우 다른 기법을 적용하는 것이 나음.</p></li></ul><h3 id="Time-amp-Space-Complexity"><a href="#Time-amp-Space-Complexity" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h3><ul><li>Time Complexity - O(n2)</li><li>Space Complexity - O(1)</li></ul><h3 id="When-to-Use-Avoid-Insertion-Sort"><a href="#When-to-Use-Avoid-Insertion-Sort" class="headerlink" title="When to Use/Avoid Insertion Sort"></a>When to Use/Avoid Insertion Sort</h3><ul><li><p>When to use:</p><ul><li>No extra space</li><li>Simple implementation</li><li>Best when we have continuous inflow of numbers and we want to keep the list shorted</li></ul></li><li><p>When to avoid:</p><ul><li>Average case is bad</li></ul></li></ul><h3 id="Coding-Insertion-Sort"><a href="#Coding-Insertion-Sort" class="headerlink" title="Coding Insertion Sort"></a>Coding Insertion Sort</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package sorting;</span><br><span class="line"></span><br><span class="line">public class InsertionSort &#123;</span><br><span class="line"></span><br><span class="line">static void insertionSort(int [] A) &#123;</span><br><span class="line"> for(int  i &#x3D; 1 ; i&lt;A.length;i++) &#123;  </span><br><span class="line"> int  tmp&#x3D;A[i], j&#x3D;i;</span><br><span class="line">     while ( j&gt;0 &amp;&amp; A[j-1]&gt;tmp ) &#123;</span><br><span class="line">        A[j]&#x3D;A[j-1];</span><br><span class="line">        j--;</span><br><span class="line">     &#125;</span><br><span class="line">     A[j] &#x3D; tmp;</span><br><span class="line"> &#125;&#x2F;&#x2F;end of for loop</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void printArray(int []array) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">System.out.print(array[i]+&quot;  &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F;end of class</span><br></pre></td></tr></table></figure><br><h2 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h2><ul><li>Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets.</li><li>Each bucket is then sorted individually.</li><li>데이터를 루트에 넣었을 때 나온 값의 개수만큼 버킷을 두어 데이터를 나누고 버킷별로 정렬한 후 합쳐 정렬을 완성, 데이터 분포가 균등할 경우 계산복잡성을 낮출 수 있으나 그 반대의 경우 효과를 기대하기 어려울 수 있음</li></ul><h3 id="Bucket-Sort-Algorithm"><a href="#Bucket-Sort-Algorithm" class="headerlink" title="Bucket Sort Algorithm"></a>Bucket Sort Algorithm</h3><ul><li>Create Number of buckets = ceil/floor(squareroot of total number of items)</li><li>Iterate through each number and place it in appropriate bucket</li><li>Appropriate bucket = Ceil((Value * number of buckets) / max value in array)</li><li>Sort all the buckets(Using <code>Quick Sort</code> is the best for time complexity)</li><li>Merge all the buckets</li></ul><h3 id="Time-amp-Space-Complexity-1"><a href="#Time-amp-Space-Complexity-1" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h3><ul><li>Time Complexity - O(n log n)</li><li>Space Complexity - O(n)</li></ul><h3 id="When-to-Use-Avoid-Bucket-sort"><a href="#When-to-Use-Avoid-Bucket-sort" class="headerlink" title="When to Use / Avoid Bucket sort"></a>When to Use / Avoid Bucket sort</h3><ul><li><p>When to use:</p><ul><li>When input is uniformly distributed over a range</li></ul></li><li><p>When not to use</p><ul><li>When space is a concern</li></ul></li></ul><h3 id="Coding-Bucket-Sort"><a href="#Coding-Bucket-Sort" class="headerlink" title="Coding Bucket Sort"></a>Coding Bucket Sort</h3><p>BucketSort.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line"></span><br><span class="line">public class BucketSort &#123;</span><br><span class="line"></span><br><span class="line">    int arr[];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; constructor</span><br><span class="line">    public BucketSort(int arr[])&#123;</span><br><span class="line">        this.arr &#x3D; arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prints Array</span><br><span class="line">    public void printArray()&#123;</span><br><span class="line">        int tmp &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.println(arr[i] + &quot; &quot;);</span><br><span class="line">            tmp++;</span><br><span class="line">            if(tmp &#x3D;&#x3D; 20)&#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">                tmp &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prints Buckets</span><br><span class="line">    public void printBucket(ArrayList&lt;Integer&gt;[] buckets)&#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; buckets.length; i++)&#123;</span><br><span class="line">            System.out.println(&quot;\nBucket#&quot; + i + &quot;: &quot;);</span><br><span class="line">            for(int j &#x3D; 0; j&lt; buckets[i].size(); j++)&#123;</span><br><span class="line">                System.out.println(buckets[i].get(j) + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Sorting Method</span><br><span class="line">    public void bucketSort()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create sqrt# of buckets, so that the distribution is even</span><br><span class="line">        int numberOfBuckets &#x3D; (int) Math.ceil(Math.sqrt(arr.length));</span><br><span class="line">        int maxValue &#x3D; Integer.MIN_VALUE;</span><br><span class="line">        int minValue &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Find the min and max value from the array</span><br><span class="line">        for(int value : arr)&#123;</span><br><span class="line">            if(value &lt; minValue)&#123;</span><br><span class="line">                minValue &#x3D; value;</span><br><span class="line">            &#125; else if( value &gt; maxValue)&#123;</span><br><span class="line">                maxValue &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create an Array of Buckets</span><br><span class="line">        ArrayList&lt;Integer&gt;[] buckets &#x3D; new ArrayList[numberOfBuckets];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; initializing empty buckets</span><br><span class="line">        for(int i &#x3D; 0; i &lt; buckets.length; i++)&#123;</span><br><span class="line">            buckets[i] &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int value : arr)&#123;</span><br><span class="line">            int bucketNumber &#x3D; (int) Math.ceil((value * numberOfBuckets) &#x2F; maxValue);</span><br><span class="line">            buckets[bucketNumber -1].add(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Printing buckets before sorting&quot;);</span><br><span class="line">        printBucket(buckets);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Sort Buckets</span><br><span class="line">        for(ArrayList&lt;Integer&gt; bucket: buckets)&#123;</span><br><span class="line">            Collections.sort(bucket);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n\nPrinting buckets after sorting&quot;);</span><br><span class="line">        printBucket(buckets);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Concatenate buckets</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        for(ArrayList&lt;Integer&gt; bucket: buckets)&#123;</span><br><span class="line">            for(int value:bucket)&#123;</span><br><span class="line">                arr[index] &#x3D; value;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int arr[] &#x3D; new int[100];</span><br><span class="line">        &#x2F;&#x2F;Generating 100 random numbers in the range of 0-100</span><br><span class="line">        Random random &#x3D; new Random();</span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++) &#123;</span><br><span class="line">            arr[i] &#x3D; random.nextInt(100)+100;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Passing this array to BucketSort method</span><br><span class="line">        BucketSort bs &#x3D; new BucketSort(arr);</span><br><span class="line">        System.out.println(&quot;Array before Sorting: &quot;);</span><br><span class="line">        bs.printArray();</span><br><span class="line">        bs.bucketSort();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n\nArray after Sorting: &quot;);</span><br><span class="line">        bs.printArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;insertion sort / bucket sort&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Sorting - Bubble Sort / Selection Sort</title>
    <link href="http://jbj828.github.io/2020/03/30/Al-Sorting-bubbleSort/"/>
    <id>http://jbj828.github.io/2020/03/30/Al-Sorting-bubbleSort/</id>
    <published>2020-03-30T02:30:25.000Z</published>
    <updated>2020-03-30T02:49:08.640Z</updated>
    
    <content type="html"><![CDATA[<p>bubble sort / selection sort</p><a id="more"></a><h3 id="What-is-Bubble-Sort"><a href="#What-is-Bubble-Sort" class="headerlink" title="What is Bubble Sort?"></a>What is Bubble Sort?</h3><ul><li>Bubble sort, sometimes is also referred as Sinking sort.</li><li>Repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order.</li><li>주어진 배열의 마지막 위치에 있는 요소를, 정렬되지 않은 직전 요소부터 첫 요소에 이르기까지 비교해 정렬 순서가 맞지 않은 모든 case에 대해 요소 위치를 바꿔줌. 이를 요소 수만큼 반복. 가장 간단하지만 비효율적인 알고리즘.</li></ul><h3 id="Time-amp-Space-Complexity"><a href="#Time-amp-Space-Complexity" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h3><ul><li>Time Complexity - O(n2)</li><li>Space Complexity - O(1)</li></ul><h3 id="When-to-use-avoid"><a href="#When-to-use-avoid" class="headerlink" title="When to use/avoid"></a>When to use/avoid</h3><ul><li><p>When to use:</p><ul><li>When input is already sorted</li><li>Space is a concern</li><li>Easy to implement</li></ul></li><li><p>When to avoid:</p><ul><li>Average case time complexity is poor</li></ul></li></ul><h3 id="Coding-Bubble-Sort"><a href="#Coding-Bubble-Sort" class="headerlink" title="Coding Bubble Sort"></a>Coding Bubble Sort</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package sorting;</span><br><span class="line"></span><br><span class="line">public class BubbleSort &#123;</span><br><span class="line"></span><br><span class="line">void bubbleSort(int arr[]) &#123;</span><br><span class="line">int n &#x3D; arr.length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n - 1; i++) &#x2F;&#x2F;run from first cell to last cell</span><br><span class="line">for (int j &#x3D; 0; j &lt; n - i - 1; j++) &#x2F;&#x2F;run from first cell to &quot;last cell - iteration&quot;</span><br><span class="line">if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">int temp &#x3D; arr[j];</span><br><span class="line">arr[j] &#x3D; arr[j + 1];</span><br><span class="line">arr[j + 1] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;end of method</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* Prints the array *&#x2F;</span><br><span class="line">void printArray(int arr[]) &#123;</span><br><span class="line">int n &#x3D; arr.length;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">System.out.print(arr[i] + &quot; &quot;);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;&#x2F;&#x2F; end of class</span><br></pre></td></tr></table></figure><br><h3 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h3><ul><li>The Selection sort algorithm is based on the idea of finding the minimum or maximum element in an unsorted array and then putting it in its correct position in a sorted array.</li><li>요소 위치 변경 횟수를 줄여 버블정렬을 일부 개선한 알고리즘. 정렬 순서가 맞지 않으면 무조건 자리를 바꿔줬던 버블정렬과 달리, 1회 iteration마다 최소값(혹은 최대값)을 찾고 단 한번만 해당 요소 위치를 바꿔줌.</li></ul><h3 id="Time-amp-Space-Complexity-1"><a href="#Time-amp-Space-Complexity-1" class="headerlink" title="Time &amp; Space Complexity"></a>Time &amp; Space Complexity</h3><ul><li>Time Complexity - O(n2)</li><li>Space Complexity - O(1)</li></ul><h3 id="When-to-use-avoid-1"><a href="#When-to-use-avoid-1" class="headerlink" title="When to use/avoid"></a>When to use/avoid</h3><ul><li><p>When to use:</p><ul><li>When we don’t have additional memory</li><li>Easy to implement</li></ul></li><li><p>When to avoid:</p><ul><li>Average case time complexity is poor</li></ul></li></ul><h3 id="Coding-Selection-Sort"><a href="#Coding-Selection-Sort" class="headerlink" title="Coding Selection Sort"></a>Coding Selection Sort</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">public class SelectionSort &#123;</span><br><span class="line"></span><br><span class="line">    void selectionSort(int arr[])&#123;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">            int minimumIndex &#x3D; i;</span><br><span class="line">            for(int j &#x3D; i+1; j &lt; arr.length; j++)&#123;</span><br><span class="line">                if(arr[j] &lt; arr[minimumIndex])&#123;</span><br><span class="line">                    minimumIndex &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(minimumIndex !&#x3D; i)&#123;</span><br><span class="line">                int temp &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; arr[minimumIndex];</span><br><span class="line">                arr[minimumIndex] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printArray(int arr[])&#123;</span><br><span class="line">        for(int i &#x3D;0; i &lt; arr.length; i++)&#123;</span><br><span class="line">            System.out.println(arr[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bubble sort / selection sort&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Sorting</title>
    <link href="http://jbj828.github.io/2020/03/30/Al-sorting2/"/>
    <id>http://jbj828.github.io/2020/03/30/Al-sorting2/</id>
    <published>2020-03-29T15:30:25.000Z</published>
    <updated>2020-04-01T03:42:35.552Z</updated>
    
    <content type="html"><![CDATA[<p>sorting</p><a id="more"></a><h3 id="What-is-Sorting"><a href="#What-is-Sorting" class="headerlink" title="What is Sorting?"></a>What is Sorting?</h3><p>Sorting refers to arranging data in a particular format : either ascending or descending</p><h3 id="Types-of-Sorting"><a href="#Types-of-Sorting" class="headerlink" title="Types of Sorting"></a>Types of Sorting</h3><img src="/2020/03/30/Al-sorting2/sorting1.PNG" class="" width="500" height="500" title="Types-of-sorting"><br><h3 id="In-Place-vs-Out-Place-Sorting"><a href="#In-Place-vs-Out-Place-Sorting" class="headerlink" title="In-Place vs Out-Place Sorting"></a>In-Place vs Out-Place Sorting</h3><p>입력리스트 내부에서 정렬이 이뤄지는 경우를 가리킵니다. 반대는 정렬 도중에 별도 저장공간을 필요로 하는 경우입니다. 합병정렬의 경우 입력리스트를 분할해 이를 정렬하고 다시 합치는 과정에서 분할된 리스트를 별도로 저장해 두어야 합니다. 카운팅정렬과 래딕스정렬은 입력값의 빈도를 세어서 저장해 두는 변수, 결과리스트를 저장해 둘 변수가 필요합니다. 버킷정렬은 버킷이라는 변수를 만들 공간이 있어야 합니다.</p><h5 id="In-Place-Sort"><a href="#In-Place-Sort" class="headerlink" title="In-Place Sort:"></a>In-Place Sort:</h5><ul><li>Sorting algorithms which does not require any extra space for sorting.</li><li>Example - Bubble Sort</li></ul><h5 id="Out-Place-Sort"><a href="#Out-Place-Sort" class="headerlink" title="Out-Place Sort:"></a>Out-Place Sort:</h5><ul><li>Sorting algorithms which requires extra space for sorting</li><li>Example - Merge sort</li></ul><br><h3 id="Stable-vs-Unstable-Sorting"><a href="#Stable-vs-Unstable-Sorting" class="headerlink" title="Stable vs Unstable Sorting"></a>Stable vs Unstable Sorting</h3><h5 id="Stable-Sort"><a href="#Stable-Sort" class="headerlink" title="Stable Sort:"></a>Stable Sort:</h5><ul><li>If a Sorting algorithm after sorting the contents <strong>does not change the sequence</strong> of similar content in which they appear, is called Stable sorting.</li><li>Example - Insertion sort</li></ul><h5 id="Unstable-Sort"><a href="#Unstable-Sort" class="headerlink" title="Unstable Sort:"></a>Unstable Sort:</h5><ul><li>If a sorting algorithm after sorting the contents, <strong>changes the sequence</strong> of similar content in which they appear, it is called Unstable sorting.</li><li>Example - Quick Sort</li></ul><br><h3 id="Why-“Stable-Sort”-is-important"><a href="#Why-“Stable-Sort”-is-important" class="headerlink" title="Why “Stable Sort” is important?"></a>Why “Stable Sort” is important?</h3><ul><li>Scenarios where ‘sort key’ is not the entire identity of the item.</li><li>Consider a person object with a name and a Age. Let’s say we sorted based on their name. If we were to then sort by age in a stable way, we’d guarentee that our original ordering would be preserved for people with the same age.</li><li>‘group by’ clauses of Database uses this concept very heavily.</li></ul><br><h3 id="Few-Terminologies"><a href="#Few-Terminologies" class="headerlink" title="Few Terminologies"></a>Few Terminologies</h3><ul><li><p>Increasing Order</p><ul><li>If successive element is greater than previous one.</li><li>ex) 1,3,4,6,8,9</li></ul></li><li><p>Decreasing Order</p><ul><li>If successive element is less than current one.</li><li>ex) 9,8,6,4,3,1</li></ul></li><li><p>Non-Increasing Order</p><ul><li>If successive element is less than or equal to its previous element in the sequence. This order occurs when the sequence contains duplicate values.</li><li>ex) 9,8,6,3,3,1</li></ul></li><li><p>Non-Decreasing Order</p><ul><li>If the successive element is greater than or equals to its previous element in the sequence. This order occurs when the sequence contains duplicate values.</li><li>ex) 1,3,3,6,8,9</li></ul></li></ul><h3 id="Sorting-Algorithms-Compared"><a href="#Sorting-Algorithms-Compared" class="headerlink" title="Sorting Algorithms Compared"></a>Sorting Algorithms Compared</h3><img src="/2020/03/30/Al-sorting2/compareSort.PNG" class="" width="500" height="500" title="Compare Sorting Algorithms"><br><p>출처 : “Data Structures &amp; Algorithms” by DS GUY</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sorting&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hashing - Double Probing</title>
    <link href="http://jbj828.github.io/2020/03/29/Al-hashing-double-hashing/"/>
    <id>http://jbj828.github.io/2020/03/29/Al-hashing-double-hashing/</id>
    <published>2020-03-29T12:30:25.000Z</published>
    <updated>2020-03-29T14:06:14.413Z</updated>
    
    <content type="html"><![CDATA[<p>hashing - double probing</p><a id="more"></a><p>DoubleProbing.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class DoubleHashing &#123;</span><br><span class="line">    String[] hashTable;</span><br><span class="line">    int noOfCellsUsedInHashTable;</span><br><span class="line"></span><br><span class="line">    DoubleHashing()&#123;</span><br><span class="line">        hashTable &#x3D; new String[13];</span><br><span class="line">        noOfCellsUsedInHashTable &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; hash function to be used on keys</span><br><span class="line">    public int simpleASCIIHashFunction(String x, int M)&#123;</span><br><span class="line">        char[] ch;</span><br><span class="line">        ch &#x3D; x.toCharArray();</span><br><span class="line">        int i, sum;</span><br><span class="line">        for(i &#x3D; 0, sum &#x3D; 0; i &lt; x.length(); i++)&#123;</span><br><span class="line">            sum +&#x3D; ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Index from Hash Function : &quot; + sum%M);</span><br><span class="line">        return sum % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2nd Hash Function</span><br><span class="line">    int secondHashFunction(String x, int M)&#123;</span><br><span class="line">        char[] ch;</span><br><span class="line">        ch &#x3D; x.toCharArray();</span><br><span class="line">        int i, sum;</span><br><span class="line">        for(i &#x3D; 0, sum &#x3D; 0; i &lt; x.length(); i++)&#123;</span><br><span class="line">            sum +&#x3D; ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">        while(sum &gt; 13)&#123;</span><br><span class="line">            sum &#x3D; addAllTheDigitsTogether(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int addAllTheDigitsTogether(int sum)&#123;</span><br><span class="line">        int value &#x3D; 0;</span><br><span class="line">        while(sum &gt; 0)&#123;</span><br><span class="line">            value &#x3D; sum % 10;</span><br><span class="line">            sum &#x3D; sum &#x2F; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; get Load Factor</span><br><span class="line">    public double getLoadFactor()&#123;</span><br><span class="line">        double loadFactor &#x3D; noOfCellsUsedInHashTable * 1.0 &#x2F; hashTable.length;</span><br><span class="line">        return loadFactor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert key in Hash Table</span><br><span class="line">    public void insertKeyInHashTable(String value)&#123;</span><br><span class="line">        double loadFactor &#x3D; getLoadFactor();</span><br><span class="line">        if(loadFactor &gt;&#x3D; 0.75)&#123;</span><br><span class="line">            System.out.println(&quot;Load Factor of this hash table is over 0.75. We need to rehash!! &quot;);</span><br><span class="line">            rehashKeys(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int firstHashResult &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line">            int secondHashResult &#x3D; secondHashFunction(value, hashTable.length);</span><br><span class="line"></span><br><span class="line">            for(int i &#x3D; 0; i &lt; hashTable.length; i++)&#123;</span><br><span class="line">                int index &#x3D; (firstHashResult + (i * secondHashResult)) % hashTable.length;</span><br><span class="line">                if(hashTable[index] &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    hashTable[index] &#x3D; value;</span><br><span class="line">                    System.out.println(&quot;Succeed in inserting value on the hash table&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;Cannot insert the value on the index of &quot; + index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        noOfCellsUsedInHashTable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Creates a new hash table and rehashing</span><br><span class="line">    public void rehashKeys(String newString)&#123;</span><br><span class="line">        noOfCellsUsedInHashTable &#x3D; 0;</span><br><span class="line">        ArrayList&lt;String&gt; data &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        for(String s : hashTable)&#123;</span><br><span class="line">            if(s !&#x3D; null)&#123;</span><br><span class="line">                data.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data.add(newString);</span><br><span class="line">        hashTable &#x3D; new String[hashTable.length * 2];</span><br><span class="line">        for(String s : data)&#123;</span><br><span class="line">            insertKeyInHashTable(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search for a given key in hash table</span><br><span class="line">    public boolean searchKeyInHashTable(String value)&#123;</span><br><span class="line">        int index &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line">            for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">                int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">                if(hashTable[newIndex] &#x3D;&#x3D; value)&#123;</span><br><span class="line">                    System.out.println(&quot;Found the value!!&quot;);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(&quot;Cannot find the value&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete Key from Hash Table</span><br><span class="line">    public void deleteKeyFromHashTable(String value)&#123;</span><br><span class="line">        int index &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">            int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">            if(hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(value))&#123;</span><br><span class="line">                hashTable[newIndex] &#x3D; null;</span><br><span class="line">                System.out.println(&quot;Delete the value on the hash table&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;No value on the hash Table&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Display the hash table</span><br><span class="line">    public void displayTheHashTable()&#123;</span><br><span class="line">        if(hashTable &#x3D;&#x3D; null)&#123;</span><br><span class="line">            System.out.println(&quot;Hash Table is not exist&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; hashTable.length; i++)&#123;</span><br><span class="line">            System.out.println(hashTable[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete entire hash table</span><br><span class="line">    public void deleteEntireHashTable()&#123;</span><br><span class="line">        hashTable &#x3D; null;</span><br><span class="line">        System.out.println(&quot;Delete the hash table&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hashing - double probing&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hashing - Quadratic Probing</title>
    <link href="http://jbj828.github.io/2020/03/29/Al-hashing-quadrotic-probing/"/>
    <id>http://jbj828.github.io/2020/03/29/Al-hashing-quadrotic-probing/</id>
    <published>2020-03-29T08:30:25.000Z</published>
    <updated>2020-03-29T14:06:39.430Z</updated>
    
    <content type="html"><![CDATA[<p>Hashing - Quadratic Probing</p><a id="more"></a><p>QuadraticProbing.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class QuadraticProbing &#123;</span><br><span class="line"></span><br><span class="line">     String[] hashTable;</span><br><span class="line">     int noOfCellUsedInHashTable;</span><br><span class="line"></span><br><span class="line">     QuadraticProbing()&#123;</span><br><span class="line">         hashTable &#x3D; new String[13];</span><br><span class="line">         noOfCellUsedInHashTable &#x3D; 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Hash Function to be used on keys</span><br><span class="line">    public int simpleASCIIHashFunction(String x, int M)&#123;</span><br><span class="line">         char ch[];</span><br><span class="line">         ch &#x3D; x.toCharArray();</span><br><span class="line">         int sum, i;</span><br><span class="line">         for(i &#x3D; 0, sum &#x3D; 0; i &lt; ch.length; i++)&#123;</span><br><span class="line">             sum +&#x3D; ch[i];</span><br><span class="line">         &#125;</span><br><span class="line">         return sum % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Returns load factor of Hash Table</span><br><span class="line">    public double getLoadFactor()&#123;</span><br><span class="line">         double loadFactor &#x3D; noOfCellUsedInHashTable * 1.0 &#x2F; hashTable.length;</span><br><span class="line">         return loadFactor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert Key in Hash Table</span><br><span class="line">    public void insertKeyInHashTable(String value)&#123;</span><br><span class="line">         double loadFactor &#x3D; getLoadFactor();</span><br><span class="line">         if(loadFactor &gt;&#x3D; 0.75)&#123;</span><br><span class="line">             System.out.println(&quot;The hash table is full. Rehash the table&quot;);</span><br><span class="line">             rehashing(value);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             System.out.println(&quot;Inserting key in Hash Table&quot;);</span><br><span class="line">             int index &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line">             int counter &#x3D; 0;</span><br><span class="line">             for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">                 int newIndex &#x3D; (index + (counter*counter)) % hashTable.length;</span><br><span class="line">                 if(hashTable[newIndex] &#x3D;&#x3D; null)&#123;</span><br><span class="line">                     hashTable[newIndex] &#x3D; value;</span><br><span class="line">                     break;</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     System.out.println(&quot;Index is not blank&quot;);</span><br><span class="line">                 &#125;</span><br><span class="line">                 counter++;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         noOfCellUsedInHashTable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create a new Hash Table and Rehashing</span><br><span class="line">    public void rehashing(String newString)&#123;</span><br><span class="line">        noOfCellUsedInHashTable &#x3D; 0;</span><br><span class="line">        ArrayList&lt;String&gt; data &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        for(String s : hashTable)&#123;</span><br><span class="line">            if(s !&#x3D; null)</span><br><span class="line">                data.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        data.add(newString);</span><br><span class="line">        hashTable &#x3D; new String[hashTable.length *2];</span><br><span class="line">        for(String s : data)&#123;</span><br><span class="line">            insertKeyInHashTable(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search for a given key in Hash Table</span><br><span class="line">    public boolean searchKeyOnHashTable(String key)&#123;</span><br><span class="line"></span><br><span class="line">         int index &#x3D; simpleASCIIHashFunction(key, hashTable.length);</span><br><span class="line">         for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">             int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">             if(hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(key))&#123;</span><br><span class="line">                 System.out.println(&quot;Found the key!!&quot;);</span><br><span class="line">                 return true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;Cannot find the key&quot;);</span><br><span class="line">         return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete Key From Hash Table</span><br><span class="line">    public void deleteKeyFromHashTable(String key)&#123;</span><br><span class="line">         int index &#x3D; simpleASCIIHashFunction(key, hashTable.length);</span><br><span class="line"></span><br><span class="line">         for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">             int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">             if(hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(key))&#123;</span><br><span class="line">                 hashTable[newIndex] &#x3D; null;</span><br><span class="line">                 System.out.println(&quot;Delete the key&quot;);</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;Cannot find the key&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Display the hash table</span><br><span class="line">    public void displayTheHashTable()&#123;</span><br><span class="line">         if(hashTable &#x3D;&#x3D; null)&#123;</span><br><span class="line">             System.out.println(&quot;HashTable is not exist&quot;);</span><br><span class="line">         &#125; else&#123;</span><br><span class="line">             for(int i &#x3D; 0; i &lt; hashTable.length; i++)&#123;</span><br><span class="line">                 System.out.println(hashTable[i]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete Entire hash table</span><br><span class="line">    public void deleteEntireHashTable()&#123;</span><br><span class="line">         hashTable &#x3D; null;</span><br><span class="line">        System.out.println(&quot;Hash Table is deleted&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hashing - Quadratic Probing&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hashing - Linear Probing</title>
    <link href="http://jbj828.github.io/2020/03/28/Al-hash-linear-probing/"/>
    <id>http://jbj828.github.io/2020/03/28/Al-hash-linear-probing/</id>
    <published>2020-03-28T14:30:25.000Z</published>
    <updated>2020-03-28T13:24:26.432Z</updated>
    
    <content type="html"><![CDATA[<p>hashing - linear probing</p><a id="more"></a><p>LinearProbing.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">package com.chung;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class LinearProbing &#123;</span><br><span class="line"></span><br><span class="line">    String[] hashTable;</span><br><span class="line">    int noOfCellsUsedInHashTable;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Constructor</span><br><span class="line">    LinearProbing()&#123;</span><br><span class="line">        hashTable &#x3D; new String[13];</span><br><span class="line">        noOfCellsUsedInHashTable &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Hash function to be used on keys</span><br><span class="line">    public int simpleASCIIHashFunction(String x, int M)&#123;</span><br><span class="line">        char ch[];</span><br><span class="line">        ch &#x3D; x.toCharArray();</span><br><span class="line">        int i, sum;</span><br><span class="line">        for(sum &#x3D;0, i &#x3D; 0; i &lt; x.length(); i++)&#123;</span><br><span class="line">            sum &#x3D; sum + ch[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Returns LoadFactor of HashTable</span><br><span class="line">    public double getLoadFactor()&#123;</span><br><span class="line">        double loadFactor &#x3D; noOfCellsUsedInHashTable * 1.0 &#x2F; hashTable.length;</span><br><span class="line">        return loadFactor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Insert key in hash table</span><br><span class="line">    public void insertKeyInHashTable(String value)&#123;</span><br><span class="line">        double loadFactor&#x3D; getLoadFactor();</span><br><span class="line">        if(loadFactor &gt;&#x3D; 0.75)&#123;</span><br><span class="line">            rehashKeys(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Inserting \&quot;&quot; + value + &quot;\&quot; in HashTable...&quot;);</span><br><span class="line">            int index &#x3D; simpleASCIIHashFunction(value, hashTable.length);</span><br><span class="line">            for(int i &#x3D; index; i &lt; index+ hashTable.length; i++)&#123;</span><br><span class="line">                int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">                if(hashTable[newIndex] &#x3D;&#x3D; null)&#123;</span><br><span class="line">                    hashTable[newIndex] &#x3D; value;</span><br><span class="line">                    System.out.println(&quot;Successfully insert the value on the index &quot; + newIndex);</span><br><span class="line">                    break;</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    System.out.println(&quot;Failed to insert the value on the index &quot; + newIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        noOfCellsUsedInHashTable++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create a new HashTable and Rehashing</span><br><span class="line">    public void rehashKeys(String newStringToBeInserted)&#123;</span><br><span class="line">        noOfCellsUsedInHashTable &#x3D; 0;</span><br><span class="line">        ArrayList&lt;String&gt; data &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">        for(String s : hashTable)&#123;</span><br><span class="line">            if(s !&#x3D; null)&#123;</span><br><span class="line">                data.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data.add(newStringToBeInserted);</span><br><span class="line">        hashTable &#x3D; new String[hashTable.length * 2];</span><br><span class="line">        for(String s : data)&#123;</span><br><span class="line">            insertKeyInHashTable(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search for a given key in Hash Table</span><br><span class="line">    public boolean searchKeyInHashTable(String key) &#123;</span><br><span class="line">        int index &#x3D; simpleASCIIHashFunction(key, hashTable.length);</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; index; i &lt; index + hashTable.length; i++) &#123;</span><br><span class="line">            int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">            if (hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(key)) &#123;</span><br><span class="line">                System.out.println(&quot;The key is found on the index of &quot; + newIndex);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Not Found&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Delete Key from HashTable</span><br><span class="line">    public void deleteKeyInHashTable(String key)&#123;</span><br><span class="line">        int index &#x3D; simpleASCIIHashFunction(key, hashTable.length);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; index; i &lt; index + hashTable.length; i++)&#123;</span><br><span class="line">            int newIndex &#x3D; i % hashTable.length;</span><br><span class="line">            if(hashTable[newIndex] !&#x3D; null &amp;&amp; hashTable[newIndex].equals(key))&#123;</span><br><span class="line">                hashTable[newIndex] &#x3D; null;</span><br><span class="line">                System.out.println(&quot;Delete the key you want&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Failed to delete the key&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Display the Hash Table</span><br><span class="line">    public void displayHashTable()&#123;</span><br><span class="line">        if(hashTable &#x3D;&#x3D; null)&#123;</span><br><span class="line">            System.out.println(&quot;No hashTable&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; hashTable.length; i++)&#123;</span><br><span class="line">            System.out.println(hashTable[i] + &quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Deletes entire Hash table</span><br><span class="line">    public void deleteEntireHashTable()&#123;</span><br><span class="line">        if(hashTable &#x3D;&#x3D; null)&#123;</span><br><span class="line">            System.out.println(&quot;No hash table!! Check again!!&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        hashTable &#x3D; null;</span><br><span class="line">        System.out.println(&quot;Completely deleted!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hashing - linear probing&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://jbj828.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="http://jbj828.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Vuex - Actions</title>
    <link href="http://jbj828.github.io/2020/03/28/VueJS-actions/"/>
    <id>http://jbj828.github.io/2020/03/28/VueJS-actions/</id>
    <published>2020-03-28T09:46:25.000Z</published>
    <updated>2020-03-28T03:22:56.832Z</updated>
    
    <content type="html"><![CDATA[<p>actions</p><a id="more"></a><h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions?"></a>Actions?</h3><p>Mutations에는 순차적인 로직들만 선언하고 Actions에는 비순차적 또는 비동기 처리 로직들을 선언한다. </p><p>Mutations의 역할은 State 관리이다. 상태관리 자체는 한 데이터에 대해 여러 개의 컴포넌트가 관여하는 것을 효율적으로 관리하기 위한 것이다. 하지만 Mutations에 비동기 처리 로직들이 포함되면 같은 값에 대해 여러 개의 컴포넌트에서 변경을 요청했을 때, 변경 순서 파악이 어렵게 된다. </p><p>이 문제를 사전에 차단하기 위해 비동기 처리 로직은 Actions로, 동기 처리 로직은 Mutations로  나눠서 구현한다.</p><p>따라서, <code>setTimeout()</code>이나 서버와의 http 통신 처리 같이 결과를 받아올 타이밍이 예측되지 않은 로직은 Actions에 선언한다.</p><h5 id="Actions-등록"><a href="#Actions-등록" class="headerlink" title="Actions 등록"></a>Actions 등록</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js</span><br><span class="line">export const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  mutations : &#123;</span><br><span class="line">    addCounter : function(state, payload)&#123;</span><br><span class="line">      return state.counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions : &#123;</span><br><span class="line">    addCounter : function(context)&#123;</span><br><span class="line">      &#x2F;&#x2F; commit의 대상인 addCounter는 mutations의 메서드를 의미</span><br><span class="line">      return context.commit(&#39;addCounter&#39;); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>상태가 변화하는 걸 추적하기 위해 actions는 결국 mutations의 메서드를 호출(commit)하는 구조가 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js</span><br><span class="line">export const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  actions : &#123;</span><br><span class="line">    getServerData : function(context)&#123;</span><br><span class="line">      return axios.get(&quot;sample.json&quot;).then(function()&#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    delayFewMinutes : function(context)&#123;</span><br><span class="line">      return setTimeout(function()&#123;</span><br><span class="line">        commit(&#39;addCounter&#39;);</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>HTTP get 요청이나 setTimeout과 같은 비동기 처리 로직들은 actions에 선언해준다.</p><h5 id="Actions-사용"><a href="#Actions-사용" class="headerlink" title="Actions 사용"></a>Actions 사용</h5><p>앞에선 mutations를 이용하여 counter를 하나씩 늘렸다. 이번엔 actions를 이용해보자. actions를 호출할 때는 아래와 같이 <strong>dispatch()</strong>를 이용한다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">methods : &#123;</span><br><span class="line">  &#x2F;&#x2F;Mutations를 이용할 때</span><br><span class="line">  addCounter()&#123;</span><br><span class="line">    this.$store.commit(&#39;addCounter&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Actions를 이용할 때</span><br><span class="line">  addCounter()&#123;</span><br><span class="line">    this.$store.dispatch(&#39;addCounter&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Actions에-인자-값-넘기기"><a href="#Actions에-인자-값-넘기기" class="headerlink" title="Actions에 인자 값 넘기기"></a>Actions에 인자 값 넘기기</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click&#x3D;&quot;asyncIncrement(&#123;by : 50, duration: 500&#125;)&quot;&gt;Increment&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  actions : &#123;</span><br><span class="line">    &#x2F;&#x2F; payload는 일반적으로 사용하는 인자 명</span><br><span class="line">    asyncIncrement : function(context, payload)&#123;</span><br><span class="line">      return setTimeout(function()&#123;</span><br><span class="line">        context.commit(&#39;increment&#39;, payload.by);</span><br><span class="line">      &#125;, payload.duration);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>출처 : <a href="https://joshua1988.github.io/web-development/vuejs/vuex-getters-mutations/" target="_blank" rel="noopener">Captain Pangyo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;actions&lt;/p&gt;
    
    </summary>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/categories/VueJS/"/>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/tags/VueJS/"/>
    
  </entry>
  
  <entry>
    <title>Vuex - Getters and Mutations</title>
    <link href="http://jbj828.github.io/2020/03/28/VueJS-getters-and-mutations/"/>
    <id>http://jbj828.github.io/2020/03/28/VueJS-getters-and-mutations/</id>
    <published>2020-03-28T06:46:25.000Z</published>
    <updated>2020-03-28T02:43:37.848Z</updated>
    
    <content type="html"><![CDATA[<p>getters and mutations</p><a id="more"></a><h3 id="Getters"><a href="#Getters" class="headerlink" title="Getters?"></a>Getters?</h3><p>중앙 데이터 관리식 구조에서 발생하는 문제점 중 하나는 각 컴포넌트에서 Vuex의 데이터를 접근할 때 중복된 코드를 반복호출 하게 되는 것이다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">computed: &#123;</span><br><span class="line">  doubleCounter() &#123;</span><br><span class="line">    return this.$store.state.counter * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Child.vue</span><br><span class="line">computed: &#123;</span><br><span class="line">  doubleCounter() &#123;</span><br><span class="line">    return this.$store.state.counter * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>여러 컴포넌트에서 같은 로직을 비효율적으로 중복 사용하고 있다. 이 때, Vuex의 데이터(state) 변경을 각 컴포넌트에서 수행하는 게 아니라, Vuex에서 수행하도록 하고 각 컴포넌트에서 수행 로직을 호출하면, 코드 가독성도 올라가고 성능에서도 이점이 생긴다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js (Vuex)</span><br><span class="line">getters : &#123;</span><br><span class="line">  doubleCounter : function(state)&#123;</span><br><span class="line">    return state.counter * 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">computed : &#123;</span><br><span class="line">  doubleCounter()&#123;</span><br><span class="line">    return this.$store.getters.doubleCounter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Child.vue</span><br><span class="line">computed : &#123;</span><br><span class="line">  doubleCounter()&#123;</span><br><span class="line">    return this.$store.getters.doubleCounter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>참고로, <code>computed</code>의 장점인Caching 효과는 단순히 state 값을 반환하는 것이 아니라, getters에 선언된 속성에서 filter(), reverse() 등의 추가적인 계산 로직이 들어갈 때 발휘된다.</p><h4 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h4><p>Vuex에 내장된 helper 함수, mapGetter로 이미 위에서 한 번 가독성이 올라간 코드를 더 직관적이게 작성할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  Parent counter : &#123;&#123; parentCounter&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">import &#123; mapGetters &#125; from &quot;vuex&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">computed : mapGetters(&#123;</span><br><span class="line">  parentCounter : &#39;getCounter&#39; &#x2F;&#x2F; getCounter는 Vuex의 getters에 선언된 속성 이름</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>여기서 주의할 점은 위 방법은 컴포넌트 자체에서 사용할 computed 속성과 함께 사용할 수 없다는 점이다. 해결방안은 ES6의 문법 <code>...</code>을 사용하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line"></span><br><span class="line">import &#123; mapGetters &#125; from &quot;vuex&quot;</span><br><span class="line"></span><br><span class="line">computed : &#123;</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    &#39;getCounter&#39;</span><br><span class="line">  ]),</span><br><span class="line">  anotherCounter()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다만 <code>...</code> 문법을 사용하려면 Babel stage-2 라이브러리 설치 및 babel preset에 추가가 필요하다.</p><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations?"></a>Mutations?</h3><p>Mutations란 Vuex의 데이터, 즉 state 값을 변경하는 로직들을 의미한다. Getters와 차이점은</p><ol><li>인자를 받아 Vuex에 넘겨줄 수 있고</li><li>computed가 아닌 methods에 등록</li></ol><p>Actions와의 차이점은</p><ol><li>Mutations는 동기적 로직을 정의</li><li>Actions는 비동기적 로직을 정의</li></ol><p><strong>Mutations의 성격상 안에 정의한 로직들이 순차적으로 일어나야 각 컴포넌트의 반영 여부를 제대로 추적할 수가 있기 때문이다</strong></p><p><code>commit</code>을 이용하여 state를 변경한다.</p><h5 id="Mutations-등록"><a href="#Mutations-등록" class="headerlink" title="Mutations 등록"></a>Mutations 등록</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; store.js</span><br><span class="line">export const store &#x3D; new Vuex.Store(&#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  mutations : &#123;</span><br><span class="line">    addCounter : function(state, payload)&#123;</span><br><span class="line">      return state.counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Mutations-사용"><a href="#Mutations-사용" class="headerlink" title="Mutations 사용"></a>Mutations 사용</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  Parent counter : &#123;&#123; parentCounter&#125;&#125; &lt;br&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;addCounter&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">methods : &#123;</span><br><span class="line">  addCounter()&#123;</span><br><span class="line">    &#x2F;&#x2F; this.$store.state.counter++;</span><br><span class="line">    this.$store.commit(&#39;addCounter&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 주목할 부분은 getters처럼 <code>this.$store.mutations.addCounter</code> 같은 접근이 불가능하고, commit을 이용하여 mutations 이벤트를 호출해야 한다는 점이다. 앞서 설명한 추적 가능한 상태 변화를 위해 프레임워크가 이렇게 구조화 되어 있는 것이다.</p><h5 id="Mutations에-인자-값-넘기기"><a href="#Mutations에-인자-값-넘기기" class="headerlink" title="Mutations에 인자 값 넘기기"></a>Mutations에 인자 값 넘기기</h5><p>각 컴포넌트에서 Vuex의 state를 조작하는 데 필요한 특정 값들을 넘기고 싶을 때는 <code>commit()</code>에 두번째 인자를 추가한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit(&#39;addCounter&#39;, 10);</span><br><span class="line">this.$store.commit(&#39;addCounter&#39;, &#123;</span><br><span class="line">  value : 10,</span><br><span class="line">  arr : [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vuex에서 아래와 같이 받을 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations : &#123;</span><br><span class="line">  &#x2F;&#x2F; payload가 &#123; value : 10&#125; 일 경우</span><br><span class="line">  addCounter: function(state, payload)&#123;</span><br><span class="line">    state.counter &#x3D; payload.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>데이터 인자 명은 보통 <code>payload</code>를 많이 쓴다.</p><ul><li>변경 된 state 값을 받아오는 <strong>Getters</strong></li><li>state 값을 변경하기 위한 메서드를 정의하는 <strong>Mutations</strong></li></ul><p>출처 : <a href="https://joshua1988.github.io/web-development/vuejs/vuex-getters-mutations/" target="_blank" rel="noopener">Captain Pangyo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;getters and mutations&lt;/p&gt;
    
    </summary>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/categories/VueJS/"/>
    
    
      <category term="VueJS" scheme="http://jbj828.github.io/tags/VueJS/"/>
    
  </entry>
  
</feed>
